<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spawnfailed解决方式</title>
    <url>/2022/06/06/Spawn-failed%E8%A7%A3%E5%86%B3%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="Hexo部署出现错误err-Error-Spawn-failed解决方式"><a href="#Hexo部署出现错误err-Error-Spawn-failed解决方式" class="headerlink" title="Hexo部署出现错误err: Error: Spawn failed解决方式"></a>Hexo部署出现错误err: Error: Spawn failed解决方式</h1><p>Hexo部署过程中可能会出现错误</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">FATAL &#123;<br>  err: Error: Spawn failed<br>      at ChildProcess.&lt;anonymous&gt; (E:\Hexo\wesker\myblog\node_modules\hexo-util\lib\spawn.js:51:21)<br>      at ChildProcess.emit (events.js:400:28)<br>      at ChildProcess.cp.emit (E:\Hexo\wesker\myblog\node_modules\cross-spawn\lib\enoent.js:34:29)<br>      at Process.ChildProcess._handle.onexit (internal/child_process.js:277:12) &#123;<br>    code: 128<br>  &#125;<br>&#125; Something&#x27;s wrong. Maybe you can find the solution here: %s https://hexo.io/docs/troubleshooting.html<br></code></pre></td></tr></table></figure>

<p>解决方式一：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">##进入站点根目录</span><br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span>hexo<span class="hljs-regexp">/hanyubolg/</span><br><br><span class="hljs-comment">##删除git提交内容文件夹</span><br>rm -rf .deploy_git/<br><br><span class="hljs-comment">##执行</span><br>git config --global core.autocrlf false<br><br><span class="hljs-comment">##最后</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure>



<p>解决方式二：有可能是你的git repo配置地址不正确,可以将http方式变更为ssh方式</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">##进入站点根目录</span><br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span>hexo<span class="hljs-regexp">/hanyubolg/</span><br><br><span class="hljs-comment">##删除git提交内容文件夹</span><br>vim _config.yml<br><br><span class="hljs-comment">##修改</span><br>deploy:<br><br>type: git<br><br>repo: https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/yourname/y</span>ourname.github.io.git -&gt; git@github.com:a956551943/weixiaohui.github.io.git<br><br>branch: master<br><br><span class="hljs-comment">##最后</span><br>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d<br></code></pre></td></tr></table></figure>

<p>解决方式三：不建议</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">##进入站点根目录</span><br>cd <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/src/</span>hexo<span class="hljs-regexp">/hanyubolg/</span><br><br><span class="hljs-comment">##进入depoly文件夹</span><br>cd .deploy_git/<br><br><span class="hljs-comment">##强制推送</span><br>git push -f<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringCloud</title>
    <url>/2022/04/08/SpringCloud/</url>
    <content><![CDATA[<h1 id="1、微服务概述"><a href="#1、微服务概述" class="headerlink" title="1、微服务概述"></a>1、微服务概述</h1><h2 id="1-1-什么是微服务？"><a href="#1-1-什么是微服务？" class="headerlink" title="1.1.什么是微服务？"></a>1.1.什么是微服务？</h2><p>​        微服务（Microservice Architecture）是近几年流行的一种架构思想，就目前而言，对于微服务，业界并没有一个人统一的标准的定义，但通常而言，微服务架构是一种结构模式，或者说是一种架构风格，它提倡<strong>将单一的应用程序划分成一组小的服务</strong>，每个服务运行在其独立的自己的进程内，服务之间相互协调，互相配置，为用户提供最终价值。服务之间采用轻量级的通信机制互相沟通，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境当中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言，工具进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</p>
<p>可能有的人觉得官方的话太过生涩，我们从技术维度来理解下:<br>        微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</p>
<h2 id="1-2-微服务架构四个核心问题？"><a href="#1-2-微服务架构四个核心问题？" class="headerlink" title="1.2.微服务架构四个核心问题？"></a>1.2.微服务架构四个核心问题？</h2><p>​    1.服务很多，客户端怎么访问？</p>
<p>​    2.服务之间如何通信？</p>
<p>​    3.如何治理？</p>
<p>​    4.服务挂了怎么办？</p>
<h2 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3.解决方案"></a>1.3.解决方案</h2><p>​    SpringCloud  生态！   SpringBoot</p>
<p>​    1.SpringCloud NetFlix  一站式解决方案！</p>
<p>​        api网关，zuul组件</p>
<p>​        Feign    —-HttClient —-   http通信方式，同步，阻塞</p>
<p>​        服务注册发现：Eureka</p>
<p>​        熔断机制：Hystrix</p>
<p>​    2.Apache Dubbo zookeeper  半自动，需要整合别人的</p>
<p>​        API：没有，找第三方组件</p>
<p>​        Dubbo</p>
<p>​        zookeeper</p>
<p>​        方案不完善</p>
<p>​    3.SpringCloud alibaba 一站式解决方案！更简单</p>
<h1 id="2、微服务与微服务架构"><a href="#2、微服务与微服务架构" class="headerlink" title="2、微服务与微服务架构"></a>2、微服务与微服务架构</h1><h2 id="2-1-微服务"><a href="#2-1-微服务" class="headerlink" title="2.1.微服务"></a>2.1.微服务</h2><p>​        强调的是服务的大小，他关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看做是IDEA中的一个个微服务工程，或者Moudel</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">IDEA工具里面使用Maven开发的一个个独立的小Moudle，它具体是使用springboot开发的一个小模块，专业的事<br>情交给专业的模块来做，一个模块就做着一件事情<br>强调的是一个个的个体，每个个体完成一个具体的任务或者功能!<br></code></pre></td></tr></table></figure>



<h2 id="2-2-微服务架构"><a href="#2-2-微服务架构" class="headerlink" title="2.2.微服务架构"></a>2.2.微服务架构</h2><p>​        —种新的架构形式,Martin Fowler，2014提出。<br>​        微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务于服务间采用轻量级的通信机制互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言，工具对其进行构建。</p>
<h3 id="2-2-1-微服务优缺点"><a href="#2-2-1-微服务优缺点" class="headerlink" title="2.2.1.微服务优缺点"></a>2.2.1.微服务优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；</li>
<li>开发简单，开发效率提高，一个服务可能就是专一的只干一件事;</li>
<li>微服务能够被小团队单独开发，这个小团队是2~5人的开发人员组成;</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的</li>
<li>微服务能使用不同的语言开发。</li>
<li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson,bamboo</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果。无需通过合作才能体现价值。</li>
<li>微服务允许你利用融合最新技术。</li>
<li><strong>微服务只是业务逻辑的代码，不会和HTML, CSS或其他界面混合</strong></li>
<li><strong>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一数据库</strong></li>
</ul>
<p><strong>缺点:</strong></p>
<ul>
<li>开发人员要处理分布式系统的复杂性</li>
<li>多服务运维难度，随着服务的增加，运维的压力也在增大·系统部署依赖</li>
<li>服务间通信成本数据一致性。系统集成测试性能监控…..</li>
</ul>
<h3 id="2-2-2-微服务技术栈有哪些？"><a href="#2-2-2-微服务技术栈有哪些？" class="headerlink" title="2.2.2.微服务技术栈有哪些？"></a>2.2.2.微服务技术栈有哪些？</h3><table>
<thead>
<tr>
<th>微服务条目</th>
<th>落地技术</th>
</tr>
</thead>
<tbody><tr>
<td>服务开发</td>
<td>SpringBoot，Spring，SpringMVC</td>
</tr>
<tr>
<td>服务配置与管理</td>
<td>Netflix公司的Archaius，阿里的Diamond等</td>
</tr>
<tr>
<td>服务注册与发现</td>
<td>Eureka、Consul、Zookeeper等</td>
</tr>
<tr>
<td>服务调用</td>
<td>Rest、RPC、gRPC</td>
</tr>
<tr>
<td>服务熔断器</td>
<td>Hystrix、Envoy等</td>
</tr>
<tr>
<td>负载均衡</td>
<td>Ribbon、Nginx等</td>
</tr>
<tr>
<td>服务接口调用（客户端调用服务的简化工具）</td>
<td>Feign等</td>
</tr>
<tr>
<td>消息队列</td>
<td>Kafka、RabbitMQ、ActiveMQ等</td>
</tr>
<tr>
<td>服务配置中心管理</td>
<td>SpringCloudConfig、Chef等</td>
</tr>
<tr>
<td>服务路由（API网关）</td>
<td>Zuul等</td>
</tr>
<tr>
<td>服务监控</td>
<td>Zabbix、Nagios、Metrics、Specatator等</td>
</tr>
<tr>
<td>全链路追踪</td>
<td>Zipkin、Brave、Dapper等</td>
</tr>
<tr>
<td>服务部署</td>
<td>Docker、OpenStack、Kubernetes等</td>
</tr>
<tr>
<td>数据流操作开发包</td>
<td>SpringCloudStream（封装Redis、Rabbit、Kafka等发送接受消息）</td>
</tr>
<tr>
<td>事件消息总栈</td>
<td>SpringCloud Bus</td>
</tr>
</tbody></table>
<h3 id="2-2-3-为什么选择SpringCloud作为微服务架构"><a href="#2-2-3-为什么选择SpringCloud作为微服务架构" class="headerlink" title="2.2.3.为什么选择SpringCloud作为微服务架构"></a>2.2.3.为什么选择SpringCloud作为微服务架构</h3><p><strong>1、选型依据</strong></p>
<ul>
<li>​    整体解决方案和框架成熟度</li>
<li>​    社区热度</li>
<li>​    可维护性</li>
<li>​    学习曲线</li>
</ul>
<p><strong>2、当前各大IT公司用的微服务架构都有哪些？</strong></p>
<ul>
<li>​    阿里：dubbo+HFS</li>
<li>​    京东：JSF</li>
<li>​    新浪：Motan</li>
<li>​    当当网：DubboX</li>
</ul>
<h1 id="3、SpringCloud入门概述"><a href="#3、SpringCloud入门概述" class="headerlink" title="3、SpringCloud入门概述"></a>3、SpringCloud入门概述</h1><h2 id="3-1-SpringCloud是什么"><a href="#3-1-SpringCloud是什么" class="headerlink" title="3.1.SpringCloud是什么"></a>3.1.SpringCloud是什么</h2><p>Spring官网：<a href="https://spring.io/">https://spring.io/</a></p>
<p>SpringCloud,基于SpringBoot提供了一套微服务解决方案，包括服务注册与发现，配置中心，全链路监控，服务网关，负载均衡，熔断器等组件，除了基于NetFlix的开源组件做高度抽象封装之外，还有一些选型中立的开源组件。</p>
<p>SpringCloud利用SpringBoot的开发便利性，巧妙地简化了分布式系统基础设施的开发，SpringCloud为开发人员提供了快速构建分布式系统的一些工具，<strong>包括配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁,决策竞选，分布式会话等等，</strong>他们都可以用SpringBoot的开发风格做到一键启动和部署。<br>SpringBoot并没有重复造轮子，它只是将目前各家公司开发的比较成熟，经得起实际考研的服务框架组合起来，通过SpringBoot风格进行再封装，屏蔽掉了复杂的配置和实现原理，<strong>最终给开发者留出了一套简单易懂，易部署和易维护的分布式系统开发工具包</strong></p>
<p>SpringCloud是分布式微服务架构下的一站式解决方案，是各个微服务架构落地技术的集合体，俗称微服务全家桶。</p>
<h2 id="3-2-SpringCloud和SpringBoot关系"><a href="#3-2-SpringCloud和SpringBoot关系" class="headerlink" title="3.2.SpringCloud和SpringBoot关系"></a>3.2.SpringCloud和SpringBoot关系</h2><p>●ISpringBoot专注于快速方便的开发单个个体微服务。<br>●SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一 个个单体微服务整合并管理起<br>来，为各个微服务之间提供:配置管理，服务发现，断路器，路由，微代理，事件总线，全局锁，决策竞选,分布式会话等等集成服务。<br>●SpringBoot可以离开SpringClooud独立使用,开发项目,但是SpringCloud离不开SpringBoot, 属于依赖关系<br>●<strong>SpringBoot专注于快速、方便的开发单个个体微服务, SpringCloud关注全局的服务治理框架</strong></p>
<h1 id="5、Eureka服务注册与发现"><a href="#5、Eureka服务注册与发现" class="headerlink" title="5、Eureka服务注册与发现"></a>5、Eureka服务注册与发现</h1><h2 id="5-1-什么是Eureka"><a href="#5-1-什么是Eureka" class="headerlink" title="5.1.什么是Eureka"></a>5.1.什么是Eureka</h2><ul>
<li>Eureka:怎么读?</li>
<li>Netflix在设计Eureka时，遵循的就是AP原则</li>
<li>Eureka是Netflix的一个子模块，也是核心模块之一。Eureka是一个基于REST的服务，<code>用于定位服务，以实现云端中间层服务发现和故障转移</code>，服务注册与发现对于微服务来说是非常重要的，有了服务发现与注册，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper;</li>
</ul>
<h2 id="5-2-原理讲解"><a href="#5-2-原理讲解" class="headerlink" title="5.2.原理讲解"></a>5.2.原理讲解</h2><h3 id="5-2-1-Eureka的基本架构"><a href="#5-2-1-Eureka的基本架构" class="headerlink" title="5.2.1.Eureka的基本架构"></a>5.2.1.Eureka的基本架构</h3><ul>
<li>SpringCloud封装了NetFlix公司开发的Eureka模块来实现服务注册和发现(对比Zookeeper)o Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心</li>
<li>而系统中的其他微服务。使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，SpringCloud的一些其他模块（比如Zuul）就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑;</li>
<li>和Dubbo架构对比</li>
</ul>
<h3 id="5-2-2-三大角色"><a href="#5-2-2-三大角色" class="headerlink" title="5.2.2.三大角色"></a>5.2.2.三大角色</h3><ul>
<li>Eureka ServeF:提供服务的注册与发现。</li>
<li>Service Provider:将自身服务注册到Eureka中，从而使消费方能够找到。</li>
<li>Service Consumer:服务消费方从Eureka中获取注册服务列表，从而找到消费服务。</li>
</ul>
<p><strong>自我保护机制:好死不如赖活着</strong><br>一句话总结:某时刻某一个微服务不可以用了，eureka不会立刻清理，依旧会对该微服务的信息进行保存!<br>●默认情况下，如果EurekaServer在一 定时间内没有接收到某个微服务实例的心跳，EurekaServer将会注销该<br>实例(默认90秒)。但是当网络分区故障发生时，微服务与Eureka之间无法正常通行，以上行为可能变得非常危险了一因为微服务本身其实是健康的,此时本不应该注销这个服务。Eureka通过 自我保护机制来解决这个问题，当EurekaServer节点在短时间内丢失过多客户端时(可能发生了网络分区故障),那么这个节点就会进入自我保护模式。一旦进入该模式，EurekaServer就会保护服务注册表中的信息，不再删除服务注册表中的数据(也就是不会注销任何微服务)。当网络故障恢复后，该EurekaServer节 点会自动退出自我保护模式。<br>●在自我保护模式中，EurekaServer会保护服务注册表中的信息，不再注销任何服务实例。当它收到的心跳数<br>重新恢复到阈值以上时，该EurekaServer节 点就会自动退出自我保护模式。它的设计哲学就是宁可保留错误<br>的服务注册信息，也不盲目注销任何可能健康的服务实例。<strong>一句话:好死不如赖活着</strong><br>●综上，自我保护模式是一种应对网络异常的安全保护措施。它的架构哲学是宁可同时保留所有微服务(健康的<br>微服务和不健康的微服务都会保留)，也不盲目注销任何健康的微服务。使用自我保护模式，可以让Eureka集群更加的健壮和稳定<br>●在SpringCloud中， 可以使用<code>eureka. server . enable-self-preservation = false</code>禁用自我保护模式<br>[不推荐关闭自我保护机制]</p>
<h3 id="作为服务注册中心，Eureka比zookeeper好在哪里"><a href="#作为服务注册中心，Eureka比zookeeper好在哪里" class="headerlink" title="作为服务注册中心，Eureka比zookeeper好在哪里?"></a><strong>作为服务注册中心，Eureka比zookeeper好在哪里?</strong></h3><p><strong>ACID是什么?</strong></p>
<ul>
<li>A (Atomicity)       原子性. </li>
<li>C (Consistency)   一致性. </li>
<li>l (lsolation)          隔离性.</li>
<li>D (Durability)      持久性</li>
</ul>
<p><strong>CAP是什么?</strong></p>
<ul>
<li>C(Consistency)                   强一致性</li>
<li>A (Availability)                    可用性</li>
<li>P(Partition tolerance)       分区容错性</li>
</ul>
<p>CAP的三进二:CA、AP、CP</p>
<p>著名的CAP理论指出，一个分布式系统不可能同时满足C(一致性)、A (可用性)、P(容错性)。由于分区容错性P在分布式系统中是必须要保证的，因此我们只能在A和C之间进行权衡。</p>
<ul>
<li>Zookeeper保证的是CP;</li>
<li>Eureka保证的是AP;</li>
</ul>
<p><strong>Zookeeper保证的是CP</strong></p>
<p>​        当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接受服务直接down掉不可用。也就是说，服务注册功能对可用性的要求要高于一致性。但是zk会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长,30~120s，且选举期间整个zk集群都是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zk集群失去master节点是较大概率会发生的事件，虽然服务最终能够恢复，但是漫长的选举时间导致的注册长期不可用是不能容忍的。</p>
<p><strong>Eureka保证的是AP</strong></p>
<p>​        Eureka看明白了这一点，因此在设计时就优先保证可用性。Eureka各个节点都是平等的，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有一种自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况:</p>
<ol>
<li><p>Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务</p>
</li>
<li><p>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上(即保证当前节点依然可用)3.当网络稳定时，当前实例新的注册信息会被同步到其他节点中</p>
<p><strong>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</strong></p>
</li>
</ol>
<h1 id="6、Ribbon"><a href="#6、Ribbon" class="headerlink" title="6、Ribbon"></a>6、Ribbon</h1><h2 id="6-1-Ribbon简介"><a href="#6-1-Ribbon简介" class="headerlink" title="6.1.Ribbon简介"></a>6.1.Ribbon简介</h2><p><strong>ribbon是什么?</strong><br>        Spring Cloud Ribbon是基于Netflix Ribbon实现的==<strong>一套客户端负载均衡的工具</strong>==。<br>        简单的说，Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将NetFlix的中间层服务连接在一起。Ribbon的客户端组件提供一系列完整的配置项如:连接超时、重试等等。简单的说，就是在配置文件中列出LoadBalancer(简称LB:负载均衡）后面所有的机器，Ribbon会自动的帮助你基于某种规则(如简单轮询，随机连接等等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法!</p>
<p><strong>ribbon能干嘛?</strong></p>
<ul>
<li>LB，即负载均衡(Load Balance)，在微服务或分布式集群中经常用的一种应用。</li>
<li>负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA（高可用)。</li>
<li>常见的负载均衡软件有Nginx，Lvs等等</li>
<li>dubbo、SpringCloud中均给我们提供了负载均衡，SpringCloud的负载均衡算法可以自定义</li>
<li>负载均衡简单分类:</li>
</ul>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Springboot入门</title>
    <url>/2021/10/06/Springboot/</url>
    <content><![CDATA[<h1 id="1-SpringBoot简介"><a href="#1-SpringBoot简介" class="headerlink" title="1.SpringBoot简介"></a>1.SpringBoot简介</h1><h2 id="1-1-原有Spring优缺点分析"><a href="#1-1-原有Spring优缺点分析" class="headerlink" title="1.1 原有Spring优缺点分析"></a>1.1 原有Spring优缺点分析</h2><h3 id="1-1-1-Spring的优点分析"><a href="#1-1-1-Spring的优点分析" class="headerlink" title="1.1.1 Spring的优点分析"></a>1.1.1 Spring的优点分析</h3><p>Spring是Java企业版（Java Enterprise Edition，javeEE）的轻量级代替品。无需开发重量级的Enterprise JavaBean（EJB），Spring为企业级Java开发提供了一种相对简单的方法，通过依赖注入和面向切面编程，用简单的Java对象（Plain Old Java Object，POJO）实现了EJB的功能。</p>
<h3 id="1-1-2-Spring的缺点分析"><a href="#1-1-2-Spring的缺点分析" class="headerlink" title="1.1.2 Spring的缺点分析"></a>1.1.2 Spring的缺点分析</h3><p><strong>虽然Spring的组件代码是轻量级的，但它的配置却是重量级的。</strong></p>
<p>不论是一开始的基于XML的配置，还是Spring2.5引入的基于注解的组件扫描，还是Spring 3.0引入的基于Java的配置，这些都代表了开发时的额外损耗。</p>
<p>因为在思考Spring配置和解决业务问题之间需要进行思维切换，甚至还带来了何种方式配置更好的无谓争论，所以编写配置挤占了编写应用程序逻辑的时间。和所有框架一样，Spring实用，但与此同时它要求的回报也不少。</p>
<p>除此之外，项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发进度。</p>
<h2 id="1-2-SpringBoot的概述"><a href="#1-2-SpringBoot的概述" class="headerlink" title="1.2 SpringBoot的概述"></a>1.2 SpringBoot的概述</h2><p>SpringBoot对上述Spring的缺点进行的改善和优化，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。</p>
<h3 id="1-2-1-SpringBoot的特点"><a href="#1-2-1-SpringBoot的特点" class="headerlink" title="1.2.1 SpringBoot的特点"></a>1.2.1 SpringBoot的特点</h3><ul>
<li><p>SpringBoot不是对Spring功能上的增强，而是提供了一种快速构建Spring的方式</p>
</li>
<li><p>开箱即用，没有代码生成，也无需XML配置。同时也可以修改默认值来满足特定的需求</p>
</li>
<li><p>提供了一些大型项目中常见的非功能性特性，如嵌入式服务器（嵌入Tomcat，无需部署WAR文件）、安全、指标，健康检测、外部配置等</p>
</li>
</ul>
<h3 id="1-2-2-SpringBoot的核心功能"><a href="#1-2-2-SpringBoot的核心功能" class="headerlink" title="1.2.2 SpringBoot的核心功能"></a>1.2.2 SpringBoot的核心功能</h3><ul>
<li>起步依赖<br>起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。<br>简单的说，起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能。</li>
<li>自动配置<br>Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</li>
</ul>
<p>后面会详细说明起步依赖与自动配置的原理解析。</p>
<h1 id="2-SpringBoot实例"><a href="#2-SpringBoot实例" class="headerlink" title="2.SpringBoot实例"></a>2.SpringBoot实例</h1><h2 id="2-1-使用Spring-Initializr创建SpringBoot"><a href="#2-1-使用Spring-Initializr创建SpringBoot" class="headerlink" title="2.1.使用Spring Initializr创建SpringBoot"></a>2.1.使用Spring Initializr创建SpringBoot</h2><h3 id="2-1-1-选择Spring-Initializr"><a href="#2-1-1-选择Spring-Initializr" class="headerlink" title="2.1.1.选择Spring Initializr"></a>2.1.1.选择Spring Initializr</h3><p><img src="/2021/10/06/Springboot/image-20211006173459168.png"></p>
<h3 id="2-1-2-填写基本信息"><a href="#2-1-2-填写基本信息" class="headerlink" title="2.1.2.填写基本信息"></a>2.1.2.填写基本信息</h3><p><img src="/2021/10/06/Springboot/image-20211006174011669.png"></p>
<h3 id="2-1-3-选择依赖"><a href="#2-1-3-选择依赖" class="headerlink" title="2.1.3.选择依赖"></a>2.1.3.选择依赖</h3><p>也可以不选，继续”next”</p>
<p><img src="/2021/10/06/Springboot/image-20211006174125910.png"></p>
<p>OK，点击”next”springboot项目就搭建好了</p>
<h3 id="2-1-4-项目结构"><a href="#2-1-4-项目结构" class="headerlink" title="2.1.4.项目结构"></a>2.1.4.项目结构</h3><p><img src="/2021/10/06/Springboot/image-20211006174448999.png"></p>
<h3 id="2-1-5-pom-xml文件"><a href="#2-1-5-pom-xml文件" class="headerlink" title="2.1.5.pom.xml文件"></a>2.1.5.pom.xml文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.foreknow<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_demo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot_demo<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 配置工程字符编码集 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="2-1-6-工程主启动类"><a href="#2-1-6-工程主启动类" class="headerlink" title="2.1.6.工程主启动类"></a>2.1.6.工程主启动类</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.springboot_demo;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootDemoApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringbootDemoApplication.class, args);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-1-7-创建Controller"><a href="#2-1-7-创建Controller" class="headerlink" title="2.1.7.创建Controller"></a>2.1.7.创建Controller</h3><p>在SpringbootDemoApplication包下创建controller包，并创建HelloController类</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.foreknow.springboot_demo.controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-meta-string">&quot;/hello&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String say()&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello....&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>@RestController 注解标识当前类为Controller组件，并且直接响应json数据。</code></p>
<h3 id="2-1-8-测试"><a href="#2-1-8-测试" class="headerlink" title="2.1.8.测试"></a>2.1.8.测试</h3><p>执行SpringbootDemoApplication类的入口方法，显示如下信息代表执行成功</p>
<p><img src="/2021/10/06/Springboot/image-20211006175753425.png"></p>
<p>浏览器输入<code>http://localhost:8080/hello</code>打印“hello….”</p>
<p><img src="/2021/10/06/Springboot/image-20211006175934716.png"></p>
<h1 id="2-SpringBoot整合MyBatis"><a href="#2-SpringBoot整合MyBatis" class="headerlink" title="2.SpringBoot整合MyBatis"></a>2.SpringBoot整合MyBatis</h1><h2 id="2-1-添加MyBatis相关依赖"><a href="#2-1-添加MyBatis相关依赖" class="headerlink" title="2.1.添加MyBatis相关依赖"></a>2.1.添加MyBatis相关依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--输出日志--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="2-2-添加MyBatis相关配置"><a href="#2-2-添加MyBatis相关配置" class="headerlink" title="2.2.添加MyBatis相关配置"></a>2.2.添加MyBatis相关配置</h2><p>在application.properties配置文件中配置MyBatis相关信息</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/elm</span><br><span class="hljs-meta">logging.level.org.springframework</span>=<span class="hljs-string">debug</span><br><span class="hljs-comment">## 配置mapper输出日志级别</span><br><span class="hljs-meta">logging.level.com.neusoft.demo.mapper</span>=<span class="hljs-string">debug</span><br><span class="hljs-comment">## 配置数据源信息</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">486934.0</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/elm?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC</span><br><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br><span class="hljs-comment">## 配置mapper映射文件路径</span><br><span class="hljs-meta">mybatis.mapper-locations</span>=<span class="hljs-string">classpath:mapper/*.xml</span><br><span class="hljs-comment">## 配置扫描实体包，给实体类设置别名</span><br><span class="hljs-meta">mybatis.type-aliases-package</span>=<span class="hljs-string">com.foreknow.springboot_demo.po</span><br></code></pre></td></tr></table></figure>

<h2 id="2-3-创建mapper接口"><a href="#2-3-创建mapper接口" class="headerlink" title="2.3.创建mapper接口"></a>2.3.创建mapper接口</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Mapper</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-meta">@Select(&quot;select * from user&quot;)</span><br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">listAllUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>注意：必须要使用 @Mapper 标识此mapper接口</code></p>
<h2 id="2-4-创建service接口与实现类"><a href="#2-4-创建service接口与实现类" class="headerlink" title="2.4.创建service接口与实现类"></a>2.4.创建service接口与实现类</h2><p>接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function">List&lt;User&gt; <span class="hljs-title">listAllUser</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">listAllUser</span><span class="hljs-params">()</span> </span>&#123;<br>        List&lt;User&gt; users = userMapper.listAllUser();<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-创建controller"><a href="#2-5-创建controller" class="headerlink" title="2.5.创建controller"></a>2.5.创建controller</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br>    <span class="hljs-meta">@RequestMapping(&quot;/listAllUser&quot;)</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;User&gt; <span class="hljs-title">listAllUser</span><span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-keyword">return</span>  userService.listAllUser();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6.测试"></a>2.6.测试</h2><p><img src="/2021/10/06/Springboot/image-20211007130439697.png"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Springboot</tag>
        <tag>框架</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Springcloud面试题</title>
    <url>/2022/06/01/Springcloud%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<h1 id="1-什么是微服务架构"><a href="#1-什么是微服务架构" class="headerlink" title="1.什么是微服务架构"></a>1.什么是微服务架构</h1><p>​        微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。 </p>
<h1 id="2-为什么需要学习Spring-Cloud"><a href="#2-为什么需要学习Spring-Cloud" class="headerlink" title="2.为什么需要学习Spring Cloud"></a>2.为什么需要学习Spring Cloud</h1><ul>
<li>首先springcloud基于spingboot的优雅简洁，可还记得我们被无数xml支配的恐惧？可还记得 springmvc、mybatis错综复杂的配置，有了spingboot，这些东西都不需要了，spingboot好处不 再赘诉，springcloud就基于SpringBoot把市场上优秀的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理。</li>
<li>什么叫做开箱即用？即使是当年的黄金搭档dubbo+zookeeper下载配置起来也是颇费心神的！而springcloud完成这些只需要一个jar的依赖就可以了！</li>
<li>springcloud大多数子模块都是直击痛点，像zuul解决的跨域，fegin解决的负载均衡，hystrix的熔断机制等等等等</li>
</ul>
<h1 id="3-Spring-Cloud-是什么"><a href="#3-Spring-Cloud-是什么" class="headerlink" title="3.Spring Cloud 是什么"></a>3.Spring Cloud 是什么</h1><ul>
<li>Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地简化了分布式系统基础设施的开发，如服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等，都可以用Spring Boot的开发风格做到一键启动和部署。</li>
<li>Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的分布式系统开发工具包。</li>
</ul>
<h1 id="4-SpringCloud的优缺点"><a href="#4-SpringCloud的优缺点" class="headerlink" title="4.SpringCloud的优缺点"></a>4.SpringCloud的优缺点</h1><p>优点：</p>
<p>1.耦合度比较低。不会影响其他模块的开发。</p>
<p>2.减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发。</p>
<p>3.配置比较简单，基本用注解就能实现，不用使用过多的配置文件。</p>
<p>4.微服务跨平台的，可以用任何一种语言开发。</p>
<p>5.每个微服务可以有自己的独立的数据库也有用公共的数据库。</p>
<p>6.直接写后端的代码，不用关注前端怎么开发，直接写自己的后端代码即可，然后暴露接口，通过组件进行服务通信。</p>
<p>缺点：</p>
<p>1.部署比较麻烦，给运维工程师带来一定的麻烦。</p>
<p>2.针对数据的管理比麻烦，因为微服务可以每个微服务使用一个数据库。</p>
<p>3.系统集成测试比较麻烦</p>
<p>4.性能的监控比较麻烦。【最好开发一个大屏监控系统】</p>
<pre><code>总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。 
</code></pre>
<h1 id="5-SpringBoot和SpringCloud的区别？"><a href="#5-SpringBoot和SpringCloud的区别？" class="headerlink" title="5. SpringBoot和SpringCloud的区别？"></a>5. SpringBoot和SpringCloud的区别？</h1><ul>
<li>SpringBoot专注于快速方便的开发单个个体微服务。</li>
<li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务整合并管理起来，为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务</li>
<li>SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系</li>
<li>SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。 </li>
</ul>
<h1 id="6-SpringCloud由什么组成"><a href="#6-SpringCloud由什么组成" class="headerlink" title="6. SpringCloud由什么组成"></a>6. SpringCloud由什么组成</h1><p>这就有很多了，我讲几个开发中最重要的</p>
<ul>
<li>Spring Cloud Eureka：服务注册与发现</li>
<li>Spring Cloud Zuul：服务网关</li>
<li>Spring Cloud Ribbon：客户端负载均衡</li>
<li>Spring Cloud Feign：声明性的Web服务客户端</li>
<li>Spring Cloud Hystrix：断路器</li>
<li>Spring Cloud Confifig：分布式统一配置管理</li>
</ul>
<p>等20几个框架，开源一直在更新</p>
<h1 id="7-Spring-Cloud-和dubbo区别"><a href="#7-Spring-Cloud-和dubbo区别" class="headerlink" title="7.Spring Cloud 和dubbo区别"></a>7.Spring Cloud 和dubbo区别</h1><ol>
<li>服务调用方式：dubbo是RPC springcloud Rest Api</li>
<li>注册中心：dubbo 是zookeeper springcloud是eureka，也可以是zookeeper</li>
<li>服务网关，dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。 </li>
</ol>
<h1 id="8-服务注册和发现是什么意思？Spring-Cloud-如何实现？"><a href="#8-服务注册和发现是什么意思？Spring-Cloud-如何实现？" class="headerlink" title="8.服务注册和发现是什么意思？Spring Cloud 如何实现？"></a>8.服务注册和发现是什么意思？Spring Cloud 如何实现？</h1><p>当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。Eureka 服务注册和发现可以在这种情况下提供帮助。由于所有服务都在Eureka 服务器上注册并通过调用Eureka服务器完成查找，因此无需处理服务地点的任何更改和处理。</p>
<h1 id="9-什么是Eureka"><a href="#9-什么是Eureka" class="headerlink" title="9.什么是Eureka"></a>9.什么是Eureka</h1><p>Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过EurekaService来监控各个微服务是否运行正常。</p>
<h1 id="10-Eureka怎么实现高可用"><a href="#10-Eureka怎么实现高可用" class="headerlink" title="10.Eureka怎么实现高可用"></a>10.Eureka怎么实现高可用</h1><p>采用集群的方式注册多台Eureka   ，然后把   SpringCloud   服务互相注册，客户端从   Eureka   获取信息时，按照Eureka   的顺序来访问。   </p>
<h1 id="11-什么是Eureka的自我保护模式"><a href="#11-什么是Eureka的自我保护模式" class="headerlink" title="11.什么是Eureka的自我保护模式"></a>11.什么是Eureka的自我保护模式</h1><p>默认情况下，如果 Eureka Service 在一定时间内没有接收到某个微服务的心跳， Eureka Service 会进入自我保护模式，在该模式下Eureka Service 会保护服务注册表中的信息，不在删除注册表中的数据，当网络故障恢复后，Eureka Servic 节点会自动退出自我保护模式 </p>
<h1 id="12-DiscoveryClient的作用"><a href="#12-DiscoveryClient的作用" class="headerlink" title="12.DiscoveryClient的作用"></a>12.DiscoveryClient的作用</h1><p>可以从注册中心中根据服务别名获取注册的服务器信息。 </p>
<h1 id="13-Eureka和ZooKeeper"><a href="#13-Eureka和ZooKeeper" class="headerlink" title="13.Eureka和ZooKeeper"></a>13.Eureka和ZooKeeper</h1><ol>
<li><p>ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从</p>
</li>
<li><p>Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的</p>
</li>
<li><p>Eureka本质上是一个工程,而ZooKeeper只是一个进程</p>
</li>
<li><p>Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪</p>
</li>
<li><p>ZooKeeper保证的是CP，Eureka保证的是AP</p>
</li>
</ol>
<p>CAP： C：一致性&gt;Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性&gt;Availability; P：分区容错性&gt;Partition tolerance;</p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>Springcloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown语法总结</title>
    <url>/2021/09/28/first-blog/</url>
    <content><![CDATA[<h2 id="1、Markdown-简介"><a href="#1、Markdown-简介" class="headerlink" title="1、Markdown 简介"></a>1、Markdown 简介</h2><p>Markdown 是一种可以使用普通文本编辑器编写的 标记语言，通过简单的 标记语法，它可以使普通文本内容具有一定的格式    –<a href="https://baike.baidu.com/item/markdown/3245829?fr=aladdin">百度百科</a></p>
<p>基于 Markdown 语法的简洁性，它已经成为目前世界上最流行的用于书写博客的语言</p>
<h2 id="2、Markdown-语法"><a href="#2、Markdown-语法" class="headerlink" title="2、Markdown 语法"></a>2、Markdown 语法</h2><p>在编写 Markdown 时，博主强烈的推荐给大家一款简洁易用的 Markdown 编辑器 —— Typora</p>
<p>按照官方的说法就是 简单而强大，它不仅支持原生的语法，也支持对应的快捷键，更重要的是它还可以 实时预览</p>
<p>这里附上 Typora 的下载地址：<a href="https://www.typora.io/">https://www.typora.io/</a>，有兴趣的朋友可以下载来试试</p>
<p>好，下面开始进入正题，介绍一些常用的 Markdown 语法</p>
<p><strong>（1）标题</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"># 一级标题<br>## 二级标题<br>### 三级标题<br>#### 四级标题<br>##### 五级标题<br>###### 六级标题<br></code></pre></td></tr></table></figure>

<p><strong>Typora 快捷键：</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">1</span>：一级标题<br><br><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">2</span>：二级标题<br><br><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">3</span>：三级标题<br><br><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">4</span>：四级标题<br><br><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">5</span>：五级标题<br><br><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">6</span> ：六级标题<br><br><span class="hljs-attribute">Ctrl</span>+<span class="hljs-number">0</span>：段落<br></code></pre></td></tr></table></figure>

<p><strong>（2）粗体、斜体、删除线和下划线</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-strong">*斜体*</span><br><span class="hljs-strong">**粗体**</span><br><span class="hljs-strong">***加粗斜体**</span>*<br>~~删除线~~<br></code></pre></td></tr></table></figure>

<p><strong>Typora 快捷键：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">Ctrl+<span class="hljs-selector-tag">I</span>：斜体<br>Ctrl+<span class="hljs-selector-tag">B</span>：粗体<br>Ctrl+U：下划线<br>Alt+Shift+<span class="hljs-number">5</span>：删除线<br></code></pre></td></tr></table></figure>

<p><strong>（3）引用块</strong><br><strong>Markdown 语法：</strong></p>
<blockquote>
<p>&gt; 文字引用</p>
</blockquote>
<p><strong>Typora 快捷键：</strong> Ctrl+Shift+Q</p>
<p><strong>（4）代码块</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight autohotkey"><table><tr><td class="code"><pre><code class="hljs autohotkey">`行内代码`<br><br>```<br>多行代码<br>多行代码<br>```<br></code></pre></td></tr></table></figure>

<p><strong>Typora 快捷键：</strong></p>
<p>行内代码：Ctrl+Shift+`</p>
<p>多行代码：Ctrl+Shift+K</p>
<p><strong>（5）公式块</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight gams"><table><tr><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>数学公式<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure>


<p><strong>Typora 快捷键： Ctrl+Shift+M</strong></p>
<p><strong>（6）分割线</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight brainfuck"><table><tr><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">方法一：</span>--<span class="hljs-literal">-</span><br><br><span class="hljs-comment">方法二：</span>++<span class="hljs-literal">+</span><br><br><span class="hljs-comment">方法三：***</span><br></code></pre></td></tr></table></figure>


<p><strong>（7）列表</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有序列表项<br><br><span class="hljs-bullet">*</span> 无序列表项<br><br><span class="hljs-bullet">+</span> 无序列表项<br><br><span class="hljs-bullet">-</span> 无序列表项<br></code></pre></td></tr></table></figure>

<p><strong>Typora 快捷键：</strong></p>
<p>有序列表项：Ctrl+Shift+[</p>
<p>无序列表项：Ctrl+Shift+]</p>
<p><strong>（8）表格</strong><br><strong>Markdown 语法：</strong></p>
<figure class="highlight gherkin"><table><tr><td class="code"><pre><code class="hljs gherkin">表头1|<span class="hljs-string">表头2</span><br><span class="hljs-string">-</span>|<span class="hljs-string">-</span>|<span class="hljs-string">-</span><br><span class="hljs-string">内容11</span>|<span class="hljs-string">内容12</span><br><span class="hljs-string">内容21</span>|<span class="hljs-string">内容22</span><br></code></pre></td></tr></table></figure>


<p><strong>Typora 快捷键： Ctrl+T</strong></p>
<p><strong>（9）超链接</strong><br><strong>Markdown语法：</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">方法一：<span class="hljs-selector-attr">[链接文字]</span>(链接地址 <span class="hljs-string">&quot;链接描述&quot;</span>)<br>例如：<span class="hljs-selector-attr">[示例链接]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.example.com/ &quot;示例链接&quot;)</span><br><br>方法二：&lt;链接地址&gt;<br>例如：&lt;<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.example.com/&gt;</span><br></code></pre></td></tr></table></figure>


<p><strong>Typora快捷键： Ctrl+K</strong></p>
<p><strong>（10）图片</strong><br><strong>Markdown语法：</strong></p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less">!<span class="hljs-selector-attr">[图片文字]</span>(图片地址 <span class="hljs-string">&quot;图片描述&quot;</span>)<br>例如：!<span class="hljs-selector-attr">[示例图片]</span>(<span class="hljs-attribute">https</span>:<span class="hljs-comment">//www.example.com/example.PNG &quot;示例图片&quot;)</span><br></code></pre></td></tr></table></figure>


<p><strong>Typora快捷键： Ctrl+Shift+I</strong></p>
<p><strong>说明：</strong>在 Hexo中 插入图片时，请按照以下的步骤进行设置</p>
<p>将 <strong>站点配置文件</strong> 中的 <code>post_asset_folder</code> 选项的值设置为 true</p>
<p>在站点文件夹中打开 git bash，输入命令 <code>npm install hexo-asset-image --save</code> 安装插件</p>
<p>这样，当使用 <code>hexo new title</code> 创建文章时，将同时在 <code>source/_post</code> 文件夹中生成一个与 title 同名的文件夹，我们只需将图片放进此文件夹中，然后在文章中通过 Markdown 语法进行引用即可</p>
<p>例如，在资源文件夹（就是那个与 title 同名的文件夹）中添加图片 example.PNG，则可以在对应的文章中使用语句 <code>![示例图片](title/example.PNG &quot;示例图片&quot;)</code> 添加图片</p>
<p><strong>3、高级设置</strong><br><strong>（1）模板设置</strong><br>当我们使用命令 <code>hexo new &quot;title&quot;</code> 创建文章时，Hexo 会根据 <code>/scaffolds/post.md</code> 对新文章进行初始化</p>
<p>换言之，<code>/scaffolds/post.md</code> 就是新文章的 模板，所以我们可以修改它来适应自己的写作习惯</p>
<p>一个简单的示例如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">title: &#123;&#123; title &#125;&#125;<br>date: &#123;&#123; date &#125;&#125;<br><span class="hljs-keyword">tags:</span> <br>categories: <br></code></pre></td></tr></table></figure>


<p><strong>（2）头部设置</strong><br>在每篇利用 Hexo 创建的文章的开头，都会有对文章进行说明的文字，叫做 文章头部</p>
<p>文章的头部除了可以设置文章标题、发布日期等基础信息外，还可以为文章添加标签、分类等</p>
<p>一个简单的示例如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">title: Title<br>date: YYYY-MM-DD HH:MM:SS<br><span class="hljs-keyword">tags:</span> [tag1, tag2, ...]<br>categories: category<br></code></pre></td></tr></table></figure>


<p><strong>注意：</strong>属性和属性值之间必须有一个空格，否则会解析错误</p>
<p><strong>（3）首页显示</strong><br>在利用 Hexo 框架搭建的博客网站中，首页会显示文章的内容，且默认显示文章的全部内容</p>
<p>如果当文章太长的时候就会显得十分冗余，所以我们有必要对其进行精简</p>
<p>这时，我们只需在文章中使用 <code>&lt;!--more--&gt;</code> 标志即可，表示只会显示标志前面的内容</p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>总结</tag>
        <tag>技术</tag>
      </tags>
  </entry>
  <entry>
    <title>mysql出现2059</title>
    <url>/2022/06/20/mysql%E5%87%BA%E7%8E%B02059/</url>
    <content><![CDATA[<h1 id="mysql出现2059的解决方法"><a href="#mysql出现2059的解决方法" class="headerlink" title="mysql出现2059的解决方法"></a>mysql出现2059的解决方法</h1><p>原因：mysql8之前版本中加密规则为mysql_native_password，mysql8以后的加密规则为caching_sha2_password，将mysql用户登录加密规则修改为mysql_native_password即可！</p>
<p><img src="/2022/06/20/mysql%E5%87%BA%E7%8E%B02059/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NjkxMTA3,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<ol>
<li><p><code>mysql -u root -p</code>登录数据库</p>
</li>
<li><p>输入<code>use mysql;</code> 出现Database changed</p>
</li>
<li><p>输入<code>select user,host from user;</code> 目的为了查看user的root 对应host是什么 我的对应为%</p>
</li>
<li><p>修改加密规则：输入<code>ALTER USER ‘root’@’%’ IDENTIFIED WITH mysql_native_password BY ‘root’;</code>   </p>
</li>
<li><p>注:第一个root为数据库用户名 第二个root为数据库密码 切记换成自己的用户名和密码</p>
</li>
<li><p>如果你查看到的root对应的host为localhost，将该句改成<code>ALTER USER ‘root’@‘localhost’ IDENTIFIED WITH mysql_native_password BY ‘root’;</code></p>
</li>
<li><p>连接成功！</p>
</li>
</ol>
<p><img src="/2022/06/20/mysql%E5%87%BA%E7%8E%B02059/image-20220620200701704.png" alt="image-20220620200701704"></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>系统重装和激活</title>
    <url>/2021/09/29/reset-system/</url>
    <content><![CDATA[<h2 id="1、准备"><a href="#1、准备" class="headerlink" title="1、准备"></a>1、准备</h2><p>① 准备8G或8G以上的空U盘。（制作U盘会格式化U盘，U盘内重要数据要事先备份好）。<br>② 为了保证电脑内的资料安全，安装系统前需要将电脑内所有磁盘的所有重要数据备份到<br>移动储存介质（不要备份到安装系统使用的U盘）。<br>③ 如有预装Office，务必记住自己激活Office时使用的Microsoft账户和密码，以免重装后无法激活。</p>
<h2 id="2、下载工具"><a href="#2、下载工具" class="headerlink" title="2、下载工具"></a>2、下载工具</h2><p><a href="https://www.microsoft.com/zh-cn/software-download/windows10/">点击我下载工具</a>,打开微软下载Win10系统的页面</p>
<p><img src="/2021/09/29/reset-system/%E9%87%8D%E8%A3%85%E5%B7%A5%E5%85%B7%E4%B8%8B%E8%BD%BD.png"></p>
<h2 id="3、制作启动盘"><a href="#3、制作启动盘" class="headerlink" title="3、制作启动盘"></a>3、制作启动盘</h2><p>选择<code>【立即下载工具】</code>，然后选择<code>【运行】</code> 运行<code>MediaCreationTool1803.exe</code>会出现如下界面。</p>
<p><img src="/2021/09/29/reset-system/%E5%AE%89%E8%A3%85.png"></p>
<p>稍等一小会，弹出来的界面点击<code>【接受】</code>。</p>
<p><img src="/2021/09/29/reset-system/%E6%8E%A5%E5%8F%97.png"></p>
<p>选择<code>【为另一台电脑创建安装介质】</code>，然后选择<code>【下一步】</code></p>
<p><img src="/2021/09/29/reset-system/%E4%B8%BA%E5%8F%A6%E4%B8%80%E5%8F%B0%E5%AE%89%E8%A3%85.png"></p>
<p>选择对应的Windows版本，然后点击<code>【下一步】</code> 如果机器预装的是Windows 10家庭中文版则选择家庭中文版，如果预装的是专业版则选择Windows 10。</p>
<p><img src="/2021/09/29/reset-system/%E9%80%89%E6%8B%A9%E7%89%88%E6%9C%AC.png"></p>
<p>选择U盘，然后选择<code>【下一步】</code>，耐心等待即可</p>
<p><img src="/2021/09/29/reset-system/%E9%80%89%E6%8B%A9%E4%BC%98%E7%9B%98.png"></p>
<p>点击U盘并<code>【下一步】</code></p>
<p><img src="/2021/09/29/reset-system/%E9%80%89%E6%8B%A9%E4%BC%98%E7%9B%981.png"></p>
<p>耐心等待就好。。。。</p>
<p><img src="/2021/09/29/reset-system/%E5%B0%B1%E7%BB%AA.png"></p>
<p><strong>到这里U盘启动盘已经制作完成了！！！</strong></p>
<h2 id="4、安装"><a href="#4、安装" class="headerlink" title="4、安装"></a>4、安装</h2><p>制作好U盘之后，在关机状态下把U盘插在需要安装系统的电脑（台式机或一体机需要插在后置的USB接口， 笔记本建议插在黑色的USB2.0接口），然后在开机的时候不断敲击启动热键，不同品牌的电脑启动热键不同，如下：</p>
<p><img src="/2021/09/29/reset-system/%E5%90%AF%E5%8A%A8%E7%83%AD%E9%94%AE.png"></p>
<p>选择<code>“Boot Menu”</code>并敲击回车键，并在启动菜单中选择带有<code>[USB]</code>的选项，并敲击回车</p>
<p><img src="/2021/09/29/reset-system/bootmenu.png"></p>
<p>此处默认不用修改，直接点击<code>【下一步】</code></p>
<p><img src="/2021/09/29/reset-system/%E4%B8%8B%E4%B8%80%E6%AD%A5.png"></p>
<p>点击<code>【现在安装】</code></p>
<p><img src="/2021/09/29/reset-system/%E7%82%B9%E5%87%BB%E5%AE%89%E8%A3%85.png"></p>
<p>点击<code>【我没有产品密钥】</code>。</p>
<p><img src="/2021/09/29/reset-system/%E6%B2%A1%E6%9C%89%E4%BA%A7%E5%93%81%E5%AF%86%E9%92%A5.png"></p>
<p>选择<code>“家庭单语言版”</code>，然后点击<code>“下一步”</code>。</p>
<p><img src="/2021/09/29/reset-system/%E5%AE%89%E8%A3%85-%E9%80%89%E6%8B%A9%E7%89%88%E6%9C%AC.png"></p>
<p>勾选<code>“我接受许可条件”</code>，然后点击<code>“下一步”</code>。</p>
<p><img src="/2021/09/29/reset-system/%E6%8E%A5%E5%8F%97%E8%AE%B8%E5%8F%AF.png"></p>
<p>点击<code>“自定义”</code>。</p>
<p><img src="/2021/09/29/reset-system/%E8%87%AA%E5%AE%9A%E4%B9%89.png"></p>
<p>这里要注意选择主分区，分配一个大概<code>100g</code>左右大小的分区，选中此分区点击<code>下一步</code>，意思就是把系统装在 此分区，或者删除需要安装系统的磁盘（删除之后会变成未分配），直接点击<code>【下一步】</code>。 安装好之后自己再去分区，分区不会可以百度。</p>
<p><img src="/2021/09/29/reset-system/%E5%88%86%E5%8C%BA.png"></p>
<p>这个时候系统会自动安装，耐心等待即可。</p>
<p><img src="/2021/09/29/reset-system/%E6%AD%A3%E5%9C%A8%E5%AE%89%E8%A3%85.png"></p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">很关键的一步，当进度条走完也就意味着安装成功，这个时候你要把U盘拔掉 不然电脑重启时依旧是U盘启动，这个时候他还会提示你装系统的步骤，谨记。<br></code></pre></td></tr></table></figure>

<p><strong>下面就等待重启</strong></p>
<p><img src="/2021/09/29/reset-system/%E7%AD%89%E5%BE%85%E9%87%8D%E5%90%AF.png"></p>
<p><img src="/2021/09/29/reset-system/%E7%AD%89%E5%BE%85%E9%87%8D%E5%90%AF1.png"></p>
<p>接下来的步骤按照个人喜好或者可以按图操作。</p>
<p><img src="/2021/09/29/reset-system/%E5%8C%BA%E5%9F%9F%E8%AE%BE%E7%BD%AE.png"></p>
<p><img src="/2021/09/29/reset-system/%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80.png"></p>
<p><img src="/2021/09/29/reset-system/%E7%AC%AC%E4%BA%8C%E7%A7%8D%E9%94%AE%E7%9B%98.png"></p>
<p>登陆Microsoft账户或者选择脱机账户。</p>
<p><img src="/2021/09/29/reset-system/%E7%99%BB%E5%BD%95%E5%BE%AE%E8%BD%AF.png"></p>
<p>选择<code>【脱机账户】</code>后这里选择<code>【否】</code>。</p>
<p><img src="/2021/09/29/reset-system/%E8%BD%AC%E8%80%8C%E7%99%BB%E5%BD%95.png"></p>
<p>输入本地账户名并点击下一步。根据你自己喜好输一个名字</p>
<p><img src="/2021/09/29/reset-system/%E8%BE%93%E5%85%A5%E8%B4%A6%E6%88%B7%E5%90%8D%E7%A7%B0.png"></p>
<p>自由选择输入密码，如不想设置可以直接下一步。</p>
<p><img src="/2021/09/29/reset-system/%E6%B7%BB%E5%8A%A0%E5%AF%86%E7%A0%81.png"></p>
<p><img src="/2021/09/29/reset-system/%E4%B8%AA%E4%BA%BA%E5%8A%A9%E7%90%86.png"></p>
<p><img src="/2021/09/29/reset-system/%E9%9A%90%E7%A7%81%E8%AE%BE%E7%BD%AE.png"></p>
<p>接下来就到了大家非常熟悉的界面。</p>
<p><img src="/2021/09/29/reset-system/%E6%A1%8C%E9%9D%A2.png"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>系统重装</tag>
        <tag>激活</tag>
      </tags>
  </entry>
  <entry>
    <title>常用Linux命令</title>
    <url>/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h1 id="1-系统服务管理"><a href="#1-系统服务管理" class="headerlink" title="1.系统服务管理"></a>1.系统服务管理</h1><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="[systemctl]"></a>[systemctl]</h3><blockquote>
<p><code>systemctl</code>命令是<code>service</code>和<code>chkconfig</code>命令的组合体，可用于管理系统。</p>
</blockquote>
<ul>
<li>输出系统中各个服务的状态：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl list-units --<span class="hljs-built_in">type</span>=service<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031130728536.png"></p>
<ul>
<li>查看服务的运行状态：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">systemctl status firewalld<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031130413869.png" alt="image-20211031130622285"></p>
<p><code>这时服务状态显示active,表示正在运行</code></p>
<ul>
<li>关闭服务：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">systemctl stop firewalld<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031130509523.png"></p>
<p><code>运行了关闭服务命令后查看服务状态，显示inactive,表示关闭状态</code></p>
<ul>
<li>启动服务：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">systemctl start firewalld<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031131637581.png"></p>
<ul>
<li>重新启动服务（不管当前服务是启动还是关闭）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">systemctl restart firewalld<br></code></pre></td></tr></table></figure>

<ul>
<li>重新载入配置信息而不中断服务：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">systemctl reload firewalld<br></code></pre></td></tr></table></figure>

<ul>
<li>禁止服务开机自启动：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">disable</span> firewalld<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031132137028.png"></p>
<ul>
<li>设置服务开机自启动：</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl <span class="hljs-built_in">enable</span> firewalld<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031132653263.png"></p>
<h1 id="2-文件管理"><a href="#2-文件管理" class="headerlink" title="2.文件管理"></a>2.文件管理</h1><h3 id="ls"><a href="#ls" class="headerlink" title="[ls]"></a>[ls]</h3><p>列出指定目录下的所有文件，列出<code>1803130230</code>目录下的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">ls -l 1803130230<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031133004369.png"></p>
<h3 id="pwd"><a href="#pwd" class="headerlink" title="[pwd]"></a>[pwd]</h3><p>获取目前所在工作目录的绝对路径：</p>
<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031133256803.png"></p>
<h3 id="cd"><a href="#cd" class="headerlink" title="[cd]"></a>[cd]</h3><p>改变当前工作目录：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> 1803130230<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031133454125.png" alt="image-20211031133454125"></p>
<h3 id="date"><a href="#date" class="headerlink" title="[date]"></a>[date]</h3><p>显示或修改系统时间与日期；</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">date <span class="hljs-string">&#x27;+%Y-%m-%d %H:%M:%S&#x27;</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031133619405.png"></p>
<h3 id="passwd"><a href="#passwd" class="headerlink" title="[passwd]"></a>[passwd]</h3><p>用于设置用户密码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">passwd root<br></code></pre></td></tr></table></figure>

<h3 id="su"><a href="#su" class="headerlink" title="[su]"></a>[su]</h3><p>改变用户身份（切换到超级用户）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">su -<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031162707373.png"></p>
<h3 id="clear"><a href="#clear" class="headerlink" title="[clear]"></a>[clear]</h3><p>用于清除屏幕信息</p>
<h3 id="man"><a href="#man" class="headerlink" title="[man]"></a>[man]</h3><p>显示指定命令的帮助信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">man ls<br></code></pre></td></tr></table></figure>

<h3 id="who"><a href="#who" class="headerlink" title="[who]"></a>[who]</h3><ul>
<li>查询系统处于什么运行级别：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">who -r<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031163321021.png"></p>
<p>显示目前登录到系统的用户：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">who -buT<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031163454252.png"></p>
<h3 id="free"><a href="#free" class="headerlink" title="[free]"></a>[free]</h3><p>显示系统内存状态（单位MB）：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">free -m<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031163622875.png"></p>
<h3 id="ps"><a href="#ps" class="headerlink" title="[ps]"></a>[ps]</h3><ul>
<li>显示系统进程运行动态：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">ps -ef<br></code></pre></td></tr></table></figure>

<ul>
<li>查看<code>sshd</code>进程的运行动态：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">ps -ef | grep sshd<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031164216771.png"></p>
<h3 id="top"><a href="#top" class="headerlink" title="[top]"></a>[top]</h3><p>查看即时活跃的进程，类似Windows的任务管理器。</p>
<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031164652111.png"></p>
<h3 id="mkdir"><a href="#mkdir" class="headerlink" title="[mkdir]"></a>[mkdir]</h3><p>创建目录：</p>
<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031164927069.png"></p>
<h3 id="more"><a href="#more" class="headerlink" title="[more]"></a>[more]</h3><p>用于分页查看文件，例如每页10行查看<code>boot.log</code>文件：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">more -c <span class="hljs-number">-10</span> /var/log/boot.log<br></code></pre></td></tr></table></figure>

<h3 id="cat"><a href="#cat" class="headerlink" title="[cat]"></a>[cat]</h3><p>用于查看文件，例如查看Linux启动日志文件文件，并标明行号：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp">cat -Ab /var/log/boot.log<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/webp.webp"></p>
<h3 id="touch"><a href="#touch" class="headerlink" title="[touch]"></a>[touch]</h3><p>用于创建文件，例如创建<code>text.txt</code>文件：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">touch text<span class="hljs-selector-class">.txt</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211031170903003.png"></p>
<h3 id="rm"><a href="#rm" class="headerlink" title="[rm]"></a>[rm]</h3><ul>
<li>删除文件：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">rm text<span class="hljs-selector-class">.txt</span><br></code></pre></td></tr></table></figure>

<ul>
<li>强制删除某个目录及其子目录：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">rm -rf <br></code></pre></td></tr></table></figure>

<h3 id="cp"><a href="#cp" class="headerlink" title="[cp]"></a>[cp]</h3><p>用于拷贝文件，例如将<code>test1</code>目录复制到<code>test2</code>目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">cp -r data/ newdata<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101162152294.png"></p>
<h3 id="mv"><a href="#mv" class="headerlink" title="[mv]"></a>[mv]</h3><p>用于移动或覆盖文件：</p>
<p>将data下的test.txt文件移动到newdata文件夹下</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">mv data/test<span class="hljs-selector-class">.txt</span> newdata/<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101162605506.png"></p>
<h1 id="3-压缩与解压"><a href="#3-压缩与解压" class="headerlink" title="3.压缩与解压"></a>3.压缩与解压</h1><h3 id="tar"><a href="#tar" class="headerlink" title="[tar]"></a>[tar]</h3><ul>
<li>将<code>data</code>文件夹中的文件归档到文件<code>data.tar</code>（并不会进行压缩）：</li>
</ul>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">tar</span> -cvf <span class="hljs-class"><span class="hljs-keyword">data</span>.tar <span class="hljs-keyword">data</span></span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101174830289.png"></p>
<ul>
<li>用<code>gzip</code>压缩文件夹<code>newdata</code>中的文件到文件<code>newdata.tar.gz</code>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">tar -zcvf newdata.tar.gz newdata<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101175324591.png"></p>
<ul>
<li>用<code>bzip2</code>压缩文件夹<code>newdata</code>到文件<code>data/etc.tar.bz2</code>：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">tar -jcvf data/newdata.tar.bz2 newdata<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101175545102.png"></p>
<ul>
<li>分页查看压缩包中内容（gzip）：</li>
</ul>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">tar <span class="hljs-operator">-</span>ztvf newdata.tar.gz <span class="hljs-operator">|</span>more <span class="hljs-operator">-</span>c <span class="hljs-operator">-</span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure>

<ul>
<li>解压文件到当前目录（gzip）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">tar -zxvf newdata.tar.gz<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101181027805.png"></p>
<ul>
<li>解压文件到指定目录（gzip）：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">tar -zxvf newdata.tar.gz -C data<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101181141639.png"></p>
<h1 id="4-磁盘和网络管理"><a href="#4-磁盘和网络管理" class="headerlink" title="4.磁盘和网络管理"></a>4.磁盘和网络管理</h1><h3 id="df"><a href="#df" class="headerlink" title="[df]"></a>[df]</h3><p>查看磁盘空间占用情况：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">df -hT<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101181502648.png"></p>
<h3 id="dh"><a href="#dh" class="headerlink" title="[dh]"></a>[dh]</h3><p>查看当前目录下的文件及文件夹所占大小：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><code class="hljs swift">du <span class="hljs-operator">-</span>h <span class="hljs-operator">--</span>max<span class="hljs-operator">-</span>depth<span class="hljs-operator">=</span><span class="hljs-number">1</span> <span class="hljs-operator">./*</span><br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101182036752.png"></p>
<h3 id="ifconfig"><a href="#ifconfig" class="headerlink" title="[ifconfig]"></a>[ifconfig]</h3><p>显示当前网络接口状态：</p>
<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101182131655.png"></p>
<h3 id="netstat"><a href="#netstat" class="headerlink" title="[netstat]"></a>[netstat]</h3><ul>
<li>查看当前路由信息：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">netstat -rn<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101182312832.png"></p>
<ul>
<li>查看所有有效TCP连接：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">netstat -an<br></code></pre></td></tr></table></figure>

<ul>
<li>查看系统中启动的监听服务：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">netstat -tulnp<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101182919141.png"></p>
<ul>
<li>查看处于连接状态的系统资源信息：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs undefined">netstat -atunp<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101183352262.png"></p>
<h3 id="wget"><a href="#wget" class="headerlink" title="[wget]"></a>[wget]</h3><p>从网络上下载文件</p>
<p><img src="/2021/10/31/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/image-20211101193153936.png">![image-</p>
]]></content>
      <tags>
        <tag>Linux命令</tag>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>常见经典排序</title>
    <url>/2021/11/09/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1.冒泡排序"></a>1.冒泡排序</h1><p>思想：两两相比较，每一轮比较依次得出最大值（最小值），然后得出第二大的值（第二小的值）….以此类推。</p>
<p>代码实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length-<span class="hljs-number">1</span>; i++) &#123;   <span class="hljs-comment">//比较的轮数</span><br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;arr.length-<span class="hljs-number">1</span>-i; j++) &#123;  <span class="hljs-comment">//一轮比较的次数</span><br>             <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+<span class="hljs-number">1</span>]) &#123;       <span class="hljs-comment">//交换</span><br>                 <span class="hljs-keyword">int</span> temp =arr[j];<br>                 arr[j]=arr[j+<span class="hljs-number">1</span>];<br>                 arr[j+<span class="hljs-number">1</span>]=temp;<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p><code>注意：每次比较完成都会得出最大值或是最小值，因此下一次就没必要再将最大值或是最小值进行比较，也就是随着轮数的增加，比较的次数会依次减少。</code></p>
<h1 id="2-快速排序"><a href="#2-快速排序" class="headerlink" title="2.快速排序"></a>2.快速排序</h1><p>思想：</p>
<ol>
<li>选取基准值base</li>
<li>将大于基准值base的数字放在base的右边</li>
<li>将小于基准值base的数字放在base的左边</li>
<li>分别对左右子序列重复上述操作</li>
</ol>
<p>代码实现：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static void quick<span class="hljs-constructor">Sort(<span class="hljs-params">int</span>[] <span class="hljs-params">arr</span>, <span class="hljs-params">int</span> <span class="hljs-params">left</span>, <span class="hljs-params">int</span> <span class="hljs-params">right</span>)</span>&#123;<br>    <span class="hljs-comment">//先判断左边是否大于右边，如果大于，则结束方法</span><br>    <span class="hljs-keyword">if</span>(left &gt; right)&#123;<br>        return ;<br>    &#125;<br>    <span class="hljs-comment">//定义基准值</span><br>    <span class="hljs-built_in">int</span> base = arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span>;<br>    <span class="hljs-built_in">int</span> i = left;<br>    <span class="hljs-built_in">int</span> j = right;<br>    <span class="hljs-keyword">while</span>(i != j)&#123;<br>        <span class="hljs-comment">//先从右往左找</span><br>        <span class="hljs-keyword">while</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> &gt;= base<span class="hljs-operator"> &amp;&amp; </span>i &lt; j)&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//再从左往右找</span><br>        <span class="hljs-keyword">while</span>(arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> &lt;= base<span class="hljs-operator"> &amp;&amp; </span>i &lt; j)&#123;<br>            i++;<br>        &#125;<br>        <span class="hljs-comment">//这时j的位置是比基准值小的值，i的位置是比基准值大的值</span><br>        <span class="hljs-comment">//交换他俩的位置</span><br>        <span class="hljs-built_in">int</span> temp = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span>;<br>        arr<span class="hljs-literal">[<span class="hljs-identifier">j</span>]</span> = temp;<br>    &#125;<br>    <span class="hljs-comment">//这时 i == j ，交换这个位置与基准值的值</span><br>    arr<span class="hljs-literal">[<span class="hljs-identifier">left</span>]</span> = arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>;<br>    arr<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = base;<br>    <span class="hljs-comment">//递归调用方法排序基准值左边的值</span><br>    quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">left</span>, <span class="hljs-params">i</span> - 1)</span>;<br>    <span class="hljs-comment">//排序右边的值</span><br>    quick<span class="hljs-constructor">Sort(<span class="hljs-params">arr</span>, <span class="hljs-params">j</span> + 1, <span class="hljs-params">right</span>)</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="3-插入排序"><a href="#3-插入排序" class="headerlink" title="3.插入排序"></a>3.插入排序</h1><p>思想：数组的第一个数和第二个数比较，形成一个有序的数组，然后第三个数再和第二个比，再和第一个比，插入适合的位置，第四个再和第三个，第二个，第一个比，依次类推。</p>
<p>代码实现：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">package com.foreknow.demo1;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InsertionSort</span> &#123;</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-keyword">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> arr[]=&#123;<span class="hljs-number">5</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>&#125;;<br>        <span class="hljs-built_in">sort</span>(arr);<br>        <span class="hljs-built_in">print</span>(arr);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arr[],<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp=arr[i];<br>        arr[i]=arr[j];<br>        arr[j]=temp;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;<span class="hljs-number">0</span> ; j--) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j]&lt;arr[j<span class="hljs-number">-1</span>])&#123;<br>                    <span class="hljs-built_in">swap</span>(arr,j,j<span class="hljs-number">-1</span>);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;   <br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i :<br>                arr) &#123;<br>            System.out.<span class="hljs-built_in">print</span>(i+<span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4.希尔排序"></a>4.希尔排序</h1><p>思想：希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序;随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">5</span>; i &lt;arr.length; i++) &#123;    <span class="hljs-comment">//第一轮分为五组,两两一组，</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i-<span class="hljs-number">5</span>; j &gt;=<span class="hljs-number">0</span> ; j-=<span class="hljs-number">5</span>) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+<span class="hljs-number">5</span>]) &#123;<br>                <span class="hljs-keyword">int</span> temp=arr[j];<br>                arr[j]=arr[j+<span class="hljs-number">5</span>];<br>                arr[j+<span class="hljs-number">5</span>]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    System.out.println(Arrays.toString(arr));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;arr.length; i++) &#123;   <span class="hljs-comment">//  5/2=2.5 取整数2 分为2组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i-<span class="hljs-number">2</span>; j &gt;=<span class="hljs-number">0</span> ; j-=<span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+<span class="hljs-number">2</span>]) &#123;<br>                <span class="hljs-keyword">int</span> temp=arr[j];<br>                arr[j]=arr[j+<span class="hljs-number">2</span>];<br>                arr[j+<span class="hljs-number">2</span>]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>    System.out.println(Arrays.toString(arr));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;arr.length; i++) &#123;   <span class="hljs-comment">//最后分为1组</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i-<span class="hljs-number">1</span>; j &gt;=<span class="hljs-number">0</span> ; j-=<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+<span class="hljs-number">1</span>]) &#123;<br>                <span class="hljs-keyword">int</span> temp=arr[j];<br>                arr[j]=arr[j+<span class="hljs-number">1</span>];<br>                arr[j+<span class="hljs-number">1</span>]=temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="/2021/11/09/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F/image-20211110174930803.png"></p>
<p>根据规律改良:</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> shellSort(<span class="hljs-keyword">int</span>[] arr)&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.length<span class="hljs-regexp">/2; gap &gt;0 ; gap/</span>=<span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt;arr.length; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i-gap; j &gt;=<span class="hljs-number">0</span> ; j-=gap) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j]&gt;arr[j+gap]) &#123;<br>                    <span class="hljs-keyword">int</span> temp=arr[j];<br>                    arr[j]=arr[j+gap];<br>                    arr[j+gap]=temp;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上述比较规则为分组之后组内从后往前一次两两相比较，然后进行交换，这种方式叫做交换法，而这样显然效率会很低，不妨找到该数应该插入的位置后再将其插入，这种方法叫做移位法。</p>
<p>移位法实现：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> newshellSort(<span class="hljs-keyword">int</span>[] arr) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> gap = arr.length <span class="hljs-regexp">/ 2; gap &gt; 0; gap /</span>= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = gap; i &lt; arr.length; i++) &#123;<br>            <span class="hljs-keyword">int</span> j = i;<br>            <span class="hljs-keyword">int</span> temp = arr[j];<br>            <span class="hljs-keyword">if</span> (arr[j] &lt; arr[j - gap]) &#123;<br>                <span class="hljs-keyword">while</span> (j - gap &gt;= <span class="hljs-number">0</span> &amp;&amp; temp &lt; arr[j - gap]) &#123;<br>                    arr[j] = arr[j - gap];<br>                    j -= gap;<br>                &#125;<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>移位法相较于交换法以及插入法效率会快很多</p>
<p>验证：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public static void main(String args<span class="hljs-literal">[]</span>) &#123;<br>    <span class="hljs-built_in">int</span><span class="hljs-literal">[]</span> random = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">RandomBuilder</span>.</span></span>get<span class="hljs-constructor">Random(80000)</span>;  <span class="hljs-comment">//随机生成8万个数</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GetCurtime</span>.</span></span>get<span class="hljs-constructor">Curtime()</span>;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ShellSort</span>.</span></span>shell<span class="hljs-constructor">Sort(<span class="hljs-params">random</span>)</span>;     <span class="hljs-comment">//希尔排序交换法</span><br>    <span class="hljs-comment">//NewShellSort.newshellSort(random); // 希尔排序移位法</span><br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">GetCurtime</span>.</span></span>get<span class="hljs-constructor">Curtime()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试时间大概为16秒</p>
<p><img src="/2021/11/09/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F/image-20211110191652201.png"></p>
<p>而移位法几乎只用了一秒钟的时间，明显移位法效率高了很多</p>
<p><img src="/2021/11/09/%E5%B8%B8%E8%A7%81%E7%BB%8F%E5%85%B8%E6%8E%92%E5%BA%8F/image-20211110191825017.png"></p>
<h1 id="5-选择排序"><a href="#5-选择排序" class="headerlink" title="5.选择排序"></a>5.选择排序</h1><p>思想：</p>
<ol>
<li>将第一个值看成最小值</li>
<li>然后和后续的比较找出最小值和下标</li>
<li>交换本次遍历的起始值和最小值</li>
</ol>
<p><code>说明：每次遍历的时候，将前面找出的最小值，看成一个有序的列表，后面的看成无序的列表，然后每次遍历无序列表找出最小值。</code></p>
<p>实现：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectionSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> minIndex=i;                 <span class="hljs-comment">//默认第1个数最小</span><br>        <span class="hljs-keyword">int</span> min=arr[minIndex];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt;arr.length ; j++) &#123;         <span class="hljs-comment">//从第二个数开始与默认最小值比较</span><br>            <span class="hljs-keyword">if</span> (arr[j]&lt;arr[minIndex]) &#123;            <span class="hljs-comment">//如果第j个数比默认最小的那个数小则记录其索引</span><br>                minIndex=j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(minIndex!=i)&#123;            <span class="hljs-comment">//说明找到了比默认最小值小的数</span><br>            <span class="hljs-keyword">int</span> temp=arr[i];<br>            arr[i]=arr[minIndex];<br>            arr[minIndex]=temp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6.归并排序"></a>6.归并排序</h1><p>思想：</p>
<ol>
<li> 将列表按照对等的方式进行拆分</li>
<li>拆分小最小快的时候，在将最小块按照原来的拆分，进行合并</li>
<li>合并的时候，通过左右两块的左边开始比较大小。小的数据放入新的块中</li>
</ol>
<p>实现：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> mergeSort(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> <span class="hljs-keyword">start</span>, <span class="hljs-type">int</span> <span class="hljs-keyword">end</span>) &#123;<br>    //判断拆分的不为最小单位<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">end</span> - <span class="hljs-keyword">start</span> &gt; <span class="hljs-number">0</span>) &#123;<br>        //再一次拆分，直到拆成一个一个的数据<br>        mergeSort(arr, <span class="hljs-keyword">start</span>, (<span class="hljs-keyword">start</span> + <span class="hljs-keyword">end</span>) / <span class="hljs-number">2</span>);<br>        mergeSort(arr, (<span class="hljs-keyword">start</span> + <span class="hljs-keyword">end</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, <span class="hljs-keyword">end</span>);<br>        //记录开始/结束位置<br>        <span class="hljs-type">int</span> left = <span class="hljs-keyword">start</span>;<br>        <span class="hljs-type">int</span> right = (<span class="hljs-keyword">start</span> + <span class="hljs-keyword">end</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>        //记录每个小单位的排序结果<br>        <span class="hljs-type">int</span> <span class="hljs-keyword">index</span> = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span>[] result = <span class="hljs-built_in">new</span> <span class="hljs-type">int</span>[<span class="hljs-keyword">end</span> - <span class="hljs-keyword">start</span> + <span class="hljs-number">1</span>];<br>        //如果查分后的两块数据，都还存在<br>        <span class="hljs-keyword">while</span> (left &lt;= (<span class="hljs-keyword">start</span> + <span class="hljs-keyword">end</span>) / <span class="hljs-number">2</span> &amp;&amp; right &lt;= <span class="hljs-keyword">end</span>) &#123;<br>            //比较两块数据的大小，然后赋值，并且移动下标<br>            <span class="hljs-keyword">if</span> (arr[left] &lt;= arr[right]) &#123;<br>                result[<span class="hljs-keyword">index</span>] = arr[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[<span class="hljs-keyword">index</span>] = arr[right];<br>                right++;<br>            &#125;<br>            //移动单位记录的下标<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        //当某一块数据不存在了时<br>        <span class="hljs-keyword">while</span> (left &lt;= (<span class="hljs-keyword">start</span> + <span class="hljs-keyword">end</span>) / <span class="hljs-number">2</span> || right &lt;= <span class="hljs-keyword">end</span>) &#123;<br>            //直接赋值到记录下标<br>            <span class="hljs-keyword">if</span> (left &lt;= (<span class="hljs-keyword">start</span> + <span class="hljs-keyword">end</span>) / <span class="hljs-number">2</span>) &#123;<br>                result[<span class="hljs-keyword">index</span>] = arr[left];<br>                left++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result[<span class="hljs-keyword">index</span>] = arr[right];<br>                right++;<br>            &#125;<br>            <span class="hljs-keyword">index</span>++;<br>        &#125;<br>        //最后将新的数据赋值给原来的列表，并且是对应分块后的下标。<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-keyword">start</span>; i &lt;= <span class="hljs-keyword">end</span>; i++) &#123;<br>            arr[i] = result[i - <span class="hljs-keyword">start</span>];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/06/23/Redis/</url>
    <content><![CDATA[<h1 id="Redis入门"><a href="#Redis入门" class="headerlink" title="Redis入门"></a>Redis入门</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Redis是什么</p>
</blockquote>
<p>Redis（Remote Dictionary Server )，即==远程字典服务==，是一个开源的使用ANSI C语言编写、支持网络、可基于内存亦==可持久化==的日志型、Key-Value数据库，并提供多种语言的API。也被人们称之为结构化数据库</p>
<p>—来自<a href="https://baike.baidu.com/item/Redis">百度百科</a></p>
<blockquote>
<p>Redis能干嘛</p>
</blockquote>
<p>1、内存存储、持久化（rdb，aof）</p>
<p>2、效率高，可以用于告诉缓存</p>
<p>3、发布订阅系统</p>
<p>4、地图信息分析</p>
<p>5、计时器、计数器（浏览量）</p>
<p>6、。。。</p>
<blockquote>
<p>特性</p>
</blockquote>
<p>1、多样的数据类型</p>
<p>2、持久化</p>
<p>3、集群</p>
<p>4、事物</p>
<blockquote>
<p>学习Redis需要的东西</p>
</blockquote>
<p>1、狂神公众号</p>
<p>2、官网：<a href="https://redis.io/">https://redis.io/</a></p>
<p>3、中文网：<a href="http://www.redis.cn/">http://www.redis.cn/</a></p>
<h2 id="Windows安装"><a href="#Windows安装" class="headerlink" title="Windows安装"></a>Windows安装</h2><p>1、下载安装包</p>
<p><a href="https://github.com/microsoftarchive/redis/releases">https://github.com/microsoftarchive/redis/releases</a></p>
<p><img src="/2022/06/23/Redis/image-20220625205058175.png" alt="image-20220625205058175"></p>
<p>2、解压</p>
<p><img src="/2022/06/23/Redis/image-20220625205150113.png" alt="image-20220625205150113"></p>
<p>3、开启Redis，双击redis-server.exe即可</p>
<p><img src="/2022/06/23/Redis/image-20220625205407530.png" alt="image-20220625205407530"></p>
<p>4、使用客户端连接Redis</p>
<p><img src="/2022/06/23/Redis/image-20220625205546630.png" alt="image-20220625205546630"></p>
<p>测试连接：</p>
<p><img src="/2022/06/23/Redis/image-20220625210004502.png" alt="image-20220625210004502"></p>
<p>windows下使用很简单，但是Redis建议使用Linux来使用—-来自<a href="http://www.redis.cn/topics/introduction">Redis介绍</a></p>
<p><img src="/2022/06/23/Redis/image-20220625210347560.png" alt="image-20220625210347560"></p>
<h2 id="Linux安装"><a href="#Linux安装" class="headerlink" title="Linux安装"></a>Linux安装</h2><p>1、下载安装包<a href="https://download.redis.io/releases/">https://download.redis.io/releases/</a></p>
<p>2、解压Redis安装包，一般放到opt目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost opt]# tar -zxvf redis-5.0.8.tar.gz <br><br>[root@localhost opt]# ls<br>redis-5.0.8  redis-5.0.8.tar.gz<br></code></pre></td></tr></table></figure>

<p>3、进入解压后的文件</p>
<p><img src="/2022/06/23/Redis/image-20220625213922391.png" alt="image-20220625213922391"></p>
<p>4、安装基本环境</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost redis-5.0.8]# yum install gcc c++<br><br>make<br><br>make install<br></code></pre></td></tr></table></figure>

<p>5、Redis默认安装路径<code>/usr/local/bin</code></p>
<p><img src="/2022/06/23/Redis/image-20220625215239887.png" alt="image-20220625215239887"></p>
<p>6、将Redis配置文件复制到当前目录下</p>
<p><img src="/2022/06/23/Redis/image-20220625221034083.png" alt="image-20220625221034083"></p>
<p>7、Redis默认不是后台启动，我们需要配置conf文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost bin]# vim wconfig/redis.conf <br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/23/Redis/image-20220625221327016.png" alt="image-20220625221327016"></p>
<p>8、启动服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost bin]# redis-server wconfig/redis.conf <br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/23/Redis/image-20220625221703754.png" alt="image-20220625221703754"></p>
<p>9、启动客户端，连接服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost bin]# redis-cli -p 6379			#6379<br>127.0.0.1:6379&gt; ping		#测试<br>PONG<br>127.0.0.1:6379&gt; set name wesker<br>OK<br>127.0.0.1:6379&gt; get name<br>&quot;wesker&quot;<br>127.0.0.1:6379&gt; keys *		#查看所有的key<br>1) &quot;name&quot;<br></code></pre></td></tr></table></figure>

<p>10、查看Redis的进程是否开启</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs SHELL">[root@localhost bin]# ps -ef|grep redis<br>root      16171      1  0 22:16 ?        00:00:07 redis-server 127.0.0.1:6379<br>root      16422   2345  0 22:32 pts/0    00:00:00 redis-cli -p 6379<br>root      16603  16554  0 22:44 pts/1    00:00:00 grep --color=auto redis<br></code></pre></td></tr></table></figure>

<p>11、如何关闭Redis服务？</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; shutdown	#关闭Redis<br>not connected&gt; exit			#退出<br>[root@localhost bin]# ps -ef|grep redis		#再次查看进程<br>root      16636  16554  0 22:47 pts/1    00:00:00 grep --color=auto redis<br>[root@localhost bin]# <br></code></pre></td></tr></table></figure>

<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p><strong>redis-benchmark</strong></p>
<p>官方自带的性能测试参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost bin]# ll<br>总用量 32776<br>-rw-r--r-- 1 root root     110 6月  25 22:46 dump.rdb<br>-rwxr-xr-x 1 root root 4366856 6月  25 22:05 redis-benchmark<br>-rwxr-xr-x 1 root root 8125048 6月  25 22:05 redis-check-aof<br>-rwxr-xr-x 1 root root 8125048 6月  25 22:05 redis-check-rdb<br>-rwxr-xr-x 1 root root 4807840 6月  25 22:05 redis-cli<br>lrwxrwxrwx 1 root root      12 6月  25 22:05 redis-sentinel -&gt; redis-server<br>-rwxr-xr-x 1 root root 8125048 6月  25 22:05 redis-server<br>drwxr-xr-x 2 root root      24 6月  25 22:13 wconfig<br></code></pre></td></tr></table></figure>

<p>性能测试可选参数如下：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>选项</th>
<th>描述</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td><strong>-h</strong></td>
<td>指定服务器主机名</td>
<td>127.0.0.1</td>
</tr>
<tr>
<td>2</td>
<td><strong>-p</strong></td>
<td>指定服务器端口</td>
<td>6379</td>
</tr>
<tr>
<td>3</td>
<td><strong>-s</strong></td>
<td>指定服务器 socket</td>
<td></td>
</tr>
<tr>
<td>4</td>
<td><strong>-c</strong></td>
<td>指定并发连接数</td>
<td>50</td>
</tr>
<tr>
<td>5</td>
<td><strong>-n</strong></td>
<td>指定请求数</td>
<td>10000</td>
</tr>
<tr>
<td>6</td>
<td><strong>-d</strong></td>
<td>以字节的形式指定 SET/GET 值的数据大小</td>
<td>2</td>
</tr>
<tr>
<td>7</td>
<td><strong>-k</strong></td>
<td>1=keep alive 0=reconnect</td>
<td>1</td>
</tr>
<tr>
<td>8</td>
<td><strong>-r</strong></td>
<td>SET/GET/INCR 使用随机 key, SADD 使用随机值</td>
<td></td>
</tr>
<tr>
<td>9</td>
<td><strong>-P</strong></td>
<td>通过管道传输 <numreq> 请求</numreq></td>
<td>1</td>
</tr>
<tr>
<td>10</td>
<td><strong>-q</strong></td>
<td>强制退出 redis。仅显示 query/sec 值</td>
<td></td>
</tr>
<tr>
<td>11</td>
<td><strong>–csv</strong></td>
<td>以 CSV 格式输出</td>
<td></td>
</tr>
<tr>
<td>12</td>
<td>***-l*（L 的小写字母）**</td>
<td>生成循环，永久执行测试</td>
<td></td>
</tr>
<tr>
<td>13</td>
<td><strong>-t</strong></td>
<td>仅运行以逗号分隔的测试命令列表。</td>
<td></td>
</tr>
<tr>
<td>14</td>
<td>***-I*（i 的大写字母）**</td>
<td>Idle 模式。仅打开 N 个 idle 连接并等待。</td>
<td></td>
</tr>
</tbody></table>
<p>​                                                                        —–来自<a href="https://www.runoob.com/redis/redis-benchmarks.html">菜鸟教程</a></p>
<p><strong>测试</strong></p>
<p>100个并发，10000个请求（默认是50个并发，10000个请求）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost bin]# redis-benchmark -h localhost -p 6379 -c 100  -n 100000<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/23/Redis/image-20220626134400163.png" alt="image-20220626134400163"></p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><p>Redis默认有16个数据库</p>
<p><img src="/2022/06/23/Redis/image-20220626134755958.png" alt="image-20220626134755958"></p>
<p>默认使用的是第0个数据库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; select 3		#选择第三个数据库<br>OK<br>127.0.0.1:6379[3]&gt; dbsize			#查看当前数据库大小<br>(integer) 0<br>127.0.0.1:6379[3]&gt; set name wei		<br>OK<br>127.0.0.1:6379[3]&gt; select 5<br>OK<br>127.0.0.1:6379[5]&gt; get name<br>(nil)<br>127.0.0.1:6379[5]&gt; select 3<br>OK<br>127.0.0.1:6379[3]&gt; get name<br>&quot;wei&quot;<br>127.0.0.1:6379[3]&gt; dbsize<br>(integer) 1<br>127.0.0.1:6379[3]&gt; keys *		#查看当前数据库所有的key<br>1) &quot;name&quot;<br>127.0.0.1:6379[3]&gt; flushdb		#清空当前数据库<br>OK<br>127.0.0.1:6379[3]&gt; keys *<br>(empty list or set)<br>127.0.0.1:6379[3]&gt; select 0		#切换0号数据库<br>OK<br>127.0.0.1:6379&gt; set name wesker		#设置name为wesker<br>OK<br>127.0.0.1:6379&gt; keys *		#查看当前数据库所有的key<br>1) &quot;name&quot;<br>127.0.0.1:6379&gt; select 3 	#切换回3号数据库<br>OK<br>127.0.0.1:6379[3]&gt; flushall		#执行flush命令（清空所有数据库）<br>OK<br>127.0.0.1:6379[3]&gt; select 0		#切换回0号数据库<br>OK<br>127.0.0.1:6379&gt; keys *		#查看所有的key<br>(empty list or set)		#显示为空<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<p>为什么端口号是6379？明星名字九宫格对应的数字6379</p>
<blockquote>
<p>Redis是单线程的</p>
</blockquote>
<p>Redis很快的，基于内存操作，CPU不是Redis的性能瓶颈，而是机器的内存和带宽，既然能够使用单线程来实现所以就是用了单线程</p>
<p><strong>Redis单线程为什么这么快？</strong></p>
<p> 1、误区1：高性能的服务器一定是多线程的</p>
<p>2、误区2：多线程（CPU上下文会切换，耗时间）一定必单线程效率高</p>
<p>核心：Redis是将所有的数据放在内存中的，所以说使用单线程操作效率就是最高的，对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存情况下，这个方案就是最佳的</p>
<h1 id="五大数据类型"><a href="#五大数据类型" class="headerlink" title="五大数据类型"></a>五大数据类型</h1><p>Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 它支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。 </p>
<h2 id="Redis-key"><a href="#Redis-key" class="headerlink" title="Redis-key"></a>Redis-key</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; set name wesker				#设置name 值为wesker<br>OK<br>127.0.0.1:6379&gt; set age 18					#设置age 值为18<br>OK<br>127.0.0.1:6379&gt; keys *						#查询所有的key<br>1) &quot;age&quot;<br>2) &quot;name&quot;<br><br>127.0.0.1:6379&gt; move age 1					#移除一个指定的key<br>(integer) 1<br>127.0.0.1:6379&gt; keys *				<br>1) &quot;name&quot;<br>127.0.0.1:6379&gt; EXISTS name					#查询是否存在指定的key<br>(integer) 1									#返回1表示存在<br>127.0.0.1:6379&gt; EXISTS name1<br>(integer) 0									#返回0便是不存在<br>127.0.0.1:6379&gt; EXPIRE name 10				#设置指定的key的过期时间，单位为秒<br>(integer) 1<br>127.0.0.1:6379&gt; TTL name					#查看指定key的剩余时间<br>(integer) -2								#负数代表已经过期<br>127.0.0.1:6379&gt; keys *<br>(empty list or set)<br>127.0.0.1:6379&gt; set name wesker<br>OK<br>127.0.0.1:6379&gt; TYPE name					#查看指定键的类型<br>string<br>127.0.0.1:6379&gt; <br></code></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>String(字符串)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> k1 hello				<span class="hljs-comment">#设置键值对，key为k1,value为hello</span><br>OK<br>127.0.0.1:6379&gt; KEYS *						<span class="hljs-comment">#查看所有的key</span><br>1) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; get k1						<span class="hljs-comment">#通过指定的key获取value</span><br><span class="hljs-string">&quot;hello&quot;</span><br>127.0.0.1:6379&gt; EXISTS k1					<span class="hljs-comment">#查询指定的key是否存在</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; APPEND k1 <span class="hljs-string">&quot;,hello&quot;</span>			<span class="hljs-comment">#通过指定的key在value后追加内容，返回字符串长度</span><br>(<span class="hljs-built_in">integer</span>) 11<br>127.0.0.1:6379&gt; get k1<br><span class="hljs-string">&quot;hello,hello&quot;</span><br>127.0.0.1:6379&gt; STRLEN k1					<span class="hljs-comment">#查询指定key的value的长度</span><br>(<span class="hljs-built_in">integer</span>) 11<br>127.0.0.1:6379&gt; APPEND k1 <span class="hljs-string">&quot;,world&quot;</span><br>(<span class="hljs-built_in">integer</span>) 17<br>127.0.0.1:6379&gt; get k1<br><span class="hljs-string">&quot;hello,hello,world&quot;</span><br>127.0.0.1:6379&gt; KEYS *<br>1) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; APPEND k2 <span class="hljs-string">&quot;hello world&quot;</span>		<span class="hljs-comment">#如果不存在指定的key，则相当于set</span><br>(<span class="hljs-built_in">integer</span>) 11<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;k2&quot;</span><br>2) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> views 0					<span class="hljs-comment">#创建views</span><br>OK<br>127.0.0.1:6379&gt; TYPE views					<span class="hljs-comment">#查看类型</span><br>string<br>127.0.0.1:6379&gt; incr views					<span class="hljs-comment">#执行一次自增1，类似i++</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; incr views<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; incr views<br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; decr views					<span class="hljs-comment">#执行一次自减1</span><br>(<span class="hljs-built_in">integer</span>) 3<br>127.0.0.1:6379&gt; decr views<br>(<span class="hljs-built_in">integer</span>) 2<br>127.0.0.1:6379&gt; decr views<br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; INCRBY views 10				<span class="hljs-comment">#自增，步长为10</span><br>(<span class="hljs-built_in">integer</span>) 10<br>127.0.0.1:6379&gt; INCRBY views 10<br>(<span class="hljs-built_in">integer</span>) 20<br>127.0.0.1:6379&gt; DECRBY views 5				<span class="hljs-comment">#自减，步长为5</span><br>(<span class="hljs-built_in">integer</span>) 15<br>127.0.0.1:6379&gt; DECRBY views 5<br>(<span class="hljs-built_in">integer</span>) 10<br><br><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key1 <span class="hljs-string">&quot;hello,wesker&quot;</span>		<br>OK<br>127.0.0.1:6379&gt; get key1<br><span class="hljs-string">&quot;hello,wesker&quot;</span><br>127.0.0.1:6379&gt; GETRANGE key1 0 5			<span class="hljs-comment">#截取第0个到第5个字符的字符串[0,5]</span><br><span class="hljs-string">&quot;hello,&quot;</span><br>127.0.0.1:6379&gt; GETRANGE key1 0 -1			<span class="hljs-comment">#获取所有字符串</span><br><span class="hljs-string">&quot;hello,wesker&quot;</span><br><br><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> key2 abcdef<br>OK<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;abcdef&quot;</span><br>127.0.0.1:6379&gt; SETRANGE key2 1 xx			<span class="hljs-comment">#将第1个字符的位置换位xx</span><br>(<span class="hljs-built_in">integer</span>) 6<br>127.0.0.1:6379&gt; get key2<br><span class="hljs-string">&quot;axxdef&quot;</span><br><br><span class="hljs-comment">#setex(set with expire)  设置过期时间</span><br><span class="hljs-comment">#setnx(set if not exist) 如果不存在再设置</span><br>127.0.0.1:6379&gt; setex key3 30 wesker		<span class="hljs-comment">#设置过期时间30秒</span><br>OK<br>127.0.0.1:6379&gt; ttl key3					<span class="hljs-comment">#查看剩余时间</span><br>(<span class="hljs-built_in">integer</span>) 17<br>127.0.0.1:6379&gt; setnx key4 <span class="hljs-string">&quot;radis&quot;</span>			<span class="hljs-comment">#如果不存在该key，则设置</span><br>(<span class="hljs-built_in">integer</span>) 1<br>127.0.0.1:6379&gt; get key4<br><span class="hljs-string">&quot;radis&quot;</span><br>127.0.0.1:6379&gt; setnx key4 <span class="hljs-string">&quot;mongoDB&quot;</span>		<span class="hljs-comment">#已存在该key，返回值是0</span><br>(<span class="hljs-built_in">integer</span>) 0<br><br><br><br>127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3      <span class="hljs-comment">#一次性设置多个键值对</span><br>OK<br>127.0.0.1:6379&gt; keys *<br>1) <span class="hljs-string">&quot;k2&quot;</span><br>2) <span class="hljs-string">&quot;k3&quot;</span><br>3) <span class="hljs-string">&quot;k1&quot;</span><br>127.0.0.1:6379&gt; get k2<br><span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6379&gt; mget k1 k2 					<span class="hljs-comment">#一次性根据多个key获取value</span><br>1) <span class="hljs-string">&quot;v1&quot;</span><br>2) <span class="hljs-string">&quot;v2&quot;</span><br>127.0.0.1:6379&gt; msetnx k1 v1 k4 v4			<span class="hljs-comment">#如果不存在再创建</span><br>(<span class="hljs-built_in">integer</span>) 0<br>127.0.0.1:6379&gt; get k4<br>(nil)<br><br><br><span class="hljs-comment">#创建对象</span><br>127.0.0.1:6379&gt; <span class="hljs-built_in">set</span> user:1 &#123;name:wesker,age:18&#125; <span class="hljs-comment">#设置键值对，key为user：1，value为JSON字符串，值为&#123;name:wesker,age:18&#125;</span><br><br><br>127.0.0.1:6379&gt; mset user:1:name wesker user:1:age 22<br>OK<br>127.0.0.1:6379&gt; mget user:1:name<br>1) <span class="hljs-string">&quot;wesker&quot;</span><br><br><br>127.0.0.1:6379&gt; getset k1 redis				<span class="hljs-comment">#先获取原来的值，再设置新的值，如果没有则返回nil</span><br>(nil)<br>127.0.0.1:6379&gt; getset k1 mongoDB<br><span class="hljs-string">&quot;redis&quot;</span><br>127.0.0.1:6379&gt; get k1<br><span class="hljs-string">&quot;mongoDB&quot;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><p>在Redis里面，可以把list玩成栈，队列、阻塞队列</p>
<p>list所有的命令都是以l开头的</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; LPUSH list one			#将一个值或者多个值放在列表头部（左边）<br>(integer) 1<br>127.0.0.1:6379&gt; LPUSH list two<br>(integer) 2<br>127.0.0.1:6379&gt; LPUSH list three<br>(integer) 3<br>127.0.0.1:6379&gt; LRANGE list 0 -1		#根据区间获取list中具体的值<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>127.0.0.1:6379&gt; LRANGE list 0 1			#倒着存的<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br><br><br>127.0.0.1:6379&gt; RPUSH list right		#将一个值或者多个值放在列表尾部部（右边）<br>(integer) 4<br>127.0.0.1:6379&gt; keys *<br>1) &quot;list&quot;<br>127.0.0.1:6379&gt; get list<br>(error) WRONGTYPE Operation against a key holding the wrong kind of value<br>127.0.0.1:6379&gt; LRANGE list<br>(error) ERR wrong number of arguments for &#x27;lrange&#x27; command<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;two&quot;<br>3) &quot;one&quot;<br>4) &quot;right&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除元素</span><br>127.0.0.1:6379&gt; lpop list		#删除左边一个元素<br>&quot;three&quot;<br>127.0.0.1:6379&gt; rpop list		#删除右边一个元素<br>&quot;right&quot;<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;two&quot;<br>2) &quot;one&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">根据下标获取元素</span><br>127.0.0.1:6379&gt; lindex list 0<br>&quot;two&quot;<br>127.0.0.1:6379&gt; lindex list 1<br>&quot;one&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取list的长度</span><br>127.0.0.1:6379&gt; LPUSH list one<br>(integer) 1<br>127.0.0.1:6379&gt; LPUSH list two<br>(integer) 2<br>127.0.0.1:6379&gt; LPUSH list three<br>(integer) 3<br>127.0.0.1:6379&gt; llen list<br>(integer) 3<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除指定list中的值</span><br>127.0.0.1:6379&gt; LPUSH list three			#再添加一个three<br>(integer) 4<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;three&quot;<br>3) &quot;two&quot;<br>4) &quot;one&quot;<br>127.0.0.1:6379&gt; lrem list 1 one				#删除一个key为list的集合中值为one的元素<br>(integer) 1<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;three&quot;<br>3) &quot;two&quot;<br>127.0.0.1:6379&gt; lrem list 2 two				#删除两个key为list的集合中值为two的元素<br>(integer) 1<br>127.0.0.1:6379&gt; lrem list 2 two			#list只有一个two，删除两个，和删除一个的命令效果一样<br>(integer) 0<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>1) &quot;three&quot;<br>2) &quot;three&quot;<br>127.0.0.1:6379&gt; lrem list 2 three			##删除两个key为list的集合中值为three的元素<br>(integer) 2<br>127.0.0.1:6379&gt; LRANGE list 0 -1<br>(empty list or set)<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">根据下标截取指定的list中的value，闭区间</span><br>127.0.0.1:6379&gt; RPUSH mylist helllo1<br>(integer) 1<br>127.0.0.1:6379&gt; RPUSH mylist helllo2<br>(integer) 2<br>127.0.0.1:6379&gt; RPUSH mylist helllo3<br>(integer) 3<br>127.0.0.1:6379&gt; RPUSH mylist helllo4<br>(integer) 4<br>127.0.0.1:6379&gt; LTRIM mylist 1 2		#截取第1个到第2个元素，list已经被修改<br>OK<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;helllo2&quot;<br>2) &quot;helllo3&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">移除列表最后一个元素（从左到右），并将这个元素移到一个新的list中</span><br>127.0.0.1:6379&gt; LRANGE mylist 0 -1		<br>1) &quot;one&quot;<br>2) &quot;two&quot;<br>3) &quot;three&quot;<br>127.0.0.1:6379&gt; RPOPLPUSH mylist mynewlist<br>&quot;three&quot;<br>127.0.0.1:6379&gt; keys *		#创建了名为mynewlist的新list<br>1) &quot;mynewlist&quot;<br>2) &quot;mylist&quot;<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1		#查看原来的list<br>1) &quot;one&quot;<br>2) &quot;two&quot;<br>127.0.0.1:6379&gt; LRANGE mynewlist 0 -1		#查看新的list<br>1) &quot;three&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">根据下标更新指定list中的值</span><br>127.0.0.1:6379&gt; EXISTS mylist			#查看是否存在指定的list<br>(integer) 0<br>127.0.0.1:6379&gt; LSET mylist 0 newvalue	#如果不存在执行lset就会报错<br>(error) ERR no such key<br>127.0.0.1:6379&gt; LPUSH mylist value1		#先往list中添加元素<br>(integer) 1<br>127.0.0.1:6379&gt; LPUSH mylist value2<br>(integer) 2<br>127.0.0.1:6379&gt; LSET mylist 0 newvalue1	#修改第0个元素的值，newvalue<br>OK<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1		#查看list所有的值<br>1) &quot;newvalue1&quot;<br>2) &quot;value1&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">在指定的list中的指定value前面或是后面插入一个值</span><br>127.0.0.1:6379&gt; RPUSH mylist hello<br>(integer) 1<br>127.0.0.1:6379&gt; RPUSH mylist world<br>(integer) 2<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;hello&quot;<br>2) &quot;world&quot;<br>127.0.0.1:6379&gt; LINSERT mylist before world my #在“world”前面添加一个值，my<br>(integer) 3<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;hello&quot;<br>2) &quot;my&quot;<br>3) &quot;world&quot;<br>127.0.0.1:6379&gt; LINSERT mylist after  hello &quot;welcome to&quot; 	#在“hello”后面添加一个值<br>(integer) 4<br>127.0.0.1:6379&gt; LRANGE mylist 0 -1<br>1) &quot;hello&quot;<br>2) &quot;welcome to&quot;<br>3) &quot;my&quot;<br>4) &quot;world&quot;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>小结</p>
</blockquote>
<table>
<thead>
<tr>
<th>命令</th>
<th>解释</th>
</tr>
</thead>
<tbody><tr>
<td>lpush key value [value …]</td>
<td>从左边依次往list中存放元素</td>
</tr>
<tr>
<td>rpush key value [value …]</td>
<td>从右边依次往list中存放元素</td>
</tr>
<tr>
<td>lrange key start stop</td>
<td>根据索引范围获取list中对应的元素</td>
</tr>
<tr>
<td>lpop key</td>
<td>删除最左边的一个元素</td>
</tr>
<tr>
<td>rpop</td>
<td>删除最右边的一个元素</td>
</tr>
<tr>
<td>lindex key index</td>
<td>根据下标获取元素</td>
</tr>
<tr>
<td>llen key</td>
<td>获取list长度</td>
</tr>
<tr>
<td>lrem key count value</td>
<td>删除指定list中的值，count表示删除的数量</td>
</tr>
<tr>
<td>ltrim key start stop</td>
<td>根据索引范围截取指定的list中的值，原来的list修改</td>
</tr>
<tr>
<td>RPOPLPUSH source destination</td>
<td>移除列表最后一个元素（从左到右），并将这个元素移到一个新的list中</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>根据下标更新指定list中的值</td>
</tr>
<tr>
<td>linsert key before|after pivot value</td>
<td>在指定的list中的指定value前面或是后面插入一个值</td>
</tr>
</tbody></table>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>set中的值不能重复</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; sadd myset hello			#set集合中添加元素<br>(integer) 1<br>127.0.0.1:6379&gt; sadd myset world<br>(integer) 1<br>127.0.0.1:6379&gt; SMEMBERS myset				#查看set的所有元素<br>1) &quot;world&quot;<br>2) &quot;hello&quot;<br>127.0.0.1:6379&gt; SISMEMBER myset hello		#判断set中是否存在某个元素<br>(integer) 1<br>127.0.0.1:6379&gt; SISMEMBER myset wesker<br>(integer) 0<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取指定<span class="hljs-built_in">set</span>的元素个数</span><br>127.0.0.1:6379&gt; SCARD myset<br>(integer) 2<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除指定<span class="hljs-built_in">set</span>中的元素</span><br>127.0.0.1:6379&gt; SREM myset hello<br>(integer) 1<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;world&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">随机获取<span class="hljs-built_in">set</span>中的元素，默认一个</span><br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;world&quot;<br>2) &quot;hello&quot;<br>3) &quot;wesker&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;wesker&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;world&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;hello&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;wesker&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset<br>&quot;wesker&quot;<br>127.0.0.1:6379&gt; SRANDMEMBER myset 2		#指定随机获取两个元素<br>1) &quot;world&quot;<br>2) &quot;hello&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">删除指定的元素，随机删除</span><br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;world&quot;<br>2) &quot;hello&quot;<br>3) &quot;wesker&quot;<br>127.0.0.1:6379&gt; SPOP myset<br>&quot;wesker&quot;<br>127.0.0.1:6379&gt; SPOP myset<br>&quot;world&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">将一个指定的值移动到另一个<span class="hljs-built_in">set</span>集合中</span><br>127.0.0.1:6379&gt; sadd myset world wesker tom	#同时添加多个元素<br>(integer) 3<br>127.0.0.1:6379&gt; SMEMBERS myset<br>1) &quot;world&quot;<br>2) &quot;tom&quot;<br>3) &quot;hello&quot;<br>4) &quot;wesker&quot;<br>127.0.0.1:6379&gt; sadd mynewset newset	#新增一个新的set，并添加一个元素newset<br>(integer) 1<br>127.0.0.1:6379&gt; SMOVE myset mynewset wesker	#将一个指定的值移动到另一个set集合中<br>(integer) 1<br>127.0.0.1:6379&gt; SMEMBERS mynewset<br>1) &quot;newset&quot;<br>2) &quot;wesker&quot;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">差集，交集，并集</span><br>127.0.0.1:6379&gt; SMEMBERS set1<br>1) &quot;c&quot;<br>2) &quot;d&quot;<br>3) &quot;b&quot;<br>4) &quot;a&quot;<br>127.0.0.1:6379&gt; SMEMBERS set2<br>1) &quot;d&quot;<br>2) &quot;e&quot;<br>3) &quot;b&quot;<br>127.0.0.1:6379&gt; SDIFF set1 set2			#取差集<br>1) &quot;c&quot;<br>2) &quot;a&quot;<br>127.0.0.1:6379&gt; SINTER set1 set2		#取交集<br>1) &quot;d&quot;<br>2) &quot;b&quot;<br>127.0.0.1:6379&gt; SUNION set1 set2		#取并集<br>1) &quot;b&quot;<br>2) &quot;a&quot;<br>3) &quot;e&quot;<br>4) &quot;c&quot;<br>5) &quot;d&quot;<br></code></pre></td></tr></table></figure>

<h2 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h2><p>hash里面存的也是value，只是value对应的是map集合，key-map，本质和string没有太大区别</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; hset myhash key1 value1	#创建名为myhash的hash，添加一个键值对<br>(integer) 1<br>127.0.0.1:6379&gt; hget myhash key1<br>&quot;value1&quot;<br>127.0.0.1:6379&gt; hset myhash key2 value2<br>(integer) 1<br>127.0.0.1:6379&gt; hset myhash key3 value3<br>(integer) 1<br>127.0.0.1:6379&gt; hmset myhash key4 value4 key5 value5 key6 value6	#往hash里添加多个键值对<br>OK<br>127.0.0.1:6379&gt; hmget myhash key4 key5		#获取指定hash中的多个key指定的value<br>1) &quot;value4&quot;<br>2) &quot;value5&quot;<br>127.0.0.1:6379&gt; hgetall myhash			#获取指定hash的所有key和value<br> 1) &quot;key1&quot;<br> 2) &quot;value1&quot;<br> 3) &quot;key2&quot;<br> 4) &quot;value2&quot;<br> 5) &quot;key3&quot;<br> 6) &quot;value3&quot;<br> 7) &quot;key4&quot;<br> 8) &quot;value4&quot;<br> 9) &quot;key5&quot;<br>10) &quot;value5&quot;<br>11) &quot;key6&quot;<br>12) &quot;value6&quot;<br>127.0.0.1:6379&gt; hdel myhash key1 key2	#删除指定hash内的键值对，也删除了对应的value<br>(integer) 2<br>127.0.0.1:6379&gt; hgetall myhash<br>1) &quot;key3&quot;<br>2) &quot;value3&quot;<br>3) &quot;key4&quot;<br>4) &quot;value4&quot;<br>5) &quot;key5&quot;<br>6) &quot;value5&quot;<br>7) &quot;key6&quot;<br>8) &quot;value6&quot;<br>127.0.0.1:6379&gt; HLEN myhash			#获取指定hash的长度<br>(integer) 4<br>127.0.0.1:6379&gt; HEXISTS myhash key3		#判断是否存在某个值<br>(integer) 1<br>127.0.0.1:6379&gt; HEXISTS myhash key1<br>(integer) 0<br>127.0.0.1:6379&gt; hkeys myhash	#根据hash的key查询该hash内的所有字段（map里面的key）<br>1) &quot;field1&quot;<br>2) &quot;field2&quot;<br>3) &quot;field3&quot;<br>127.0.0.1:6379&gt; hvals myhash	#根据hash的key查询该hash内的所有value<br>1) &quot;value1&quot;<br>2) &quot;value2&quot;<br>3) &quot;value3&quot;<br><br><br><br>127.0.0.1:6379&gt; hset myhash field 3<br>(integer) 1<br>127.0.0.1:6379&gt; HINCRBY myhash field 1		#自增<br>(integer) 4<br>127.0.0.1:6379&gt; HINCRBY myhash field 2<br>(integer) 6<br>127.0.0.1:6379&gt; HINCRBY myhash field 1<br>(integer) 7<br>127.0.0.1:6379&gt; HINCRBY myhash field -1<br>(integer) 6<br>127.0.0.1:6379&gt; hsetnx myhash field1 value2		#如果不存在则可以设置<br>(integer) 1<br>127.0.0.1:6379&gt; hsetnx myhash field value2		#如果存在则可以设置<br>(integer) 0<br><br></code></pre></td></tr></table></figure>

<h2 id="zset"><a href="#zset" class="headerlink" title="zset"></a>zset</h2><p>有序集合，在set的集合上，增加了一个值</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">127.0.0.1:6379&gt; zadd myzset 1 one				#添加一个一个值<br>(integer) 1<br>127.0.0.1:6379&gt; zadd myzset 2 two 3 three		#添加多个值<br>(integer) 2<br>127.0.0.1:6379&gt; ZRANGE myzset 0 -1<br>1) &quot;one&quot;<br>2) &quot;two&quot;<br>3) &quot;three&quot;<br><br><br><br>127.0.0.1:6379&gt; zadd salary 5000 wekser		#添加三个值<br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 5100 tom<br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 4800 kitty<br>(integer) 1<br>127.0.0.1:6379&gt; zadd salary 5100 bob<br>(integer) 1<br>127.0.0.1:6379&gt; ZRANGE salary 0 -1		#显示所有用户<br>1) &quot;kitty&quot;<br>2) &quot;wekser&quot;<br>3) &quot;bob&quot;<br>4) &quot;tom&quot;<br><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf		#显示从小到大<br>1) &quot;kitty&quot;<br>2) &quot;wekser&quot;<br>3) &quot;bob&quot;<br>4) &quot;tom&quot;<br><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf +inf withscores	#显示从小到大，带score<br>1) &quot;kitty&quot;<br>2) &quot;4800&quot;<br>3) &quot;wekser&quot;<br>4) &quot;5000&quot;<br>5) &quot;bob&quot;<br>6) &quot;5100&quot;<br>7) &quot;tom&quot;<br>8) &quot;5100&quot;<br>127.0.0.1:6379&gt; ZREVRANGE salary 0 -1 withscores		#显示从小到大，带score<br>1) &quot;tom&quot;<br>2) &quot;5100&quot;<br>3) &quot;bob&quot;<br>4) &quot;5100&quot;<br>5) &quot;wekser&quot;<br>6) &quot;5000&quot;<br><br>127.0.0.1:6379&gt; ZRANGEBYSCORE salary -inf 5000  withscores#查询5000以下的值，包括5000，升序排列<br>1) &quot;kitty&quot;<br>2) &quot;4800&quot;<br>3) &quot;wekser&quot;<br>4) &quot;5000&quot;<br><br><br>127.0.0.1:6379&gt; zrange salary 0 -1<br>1) &quot;kitty&quot;<br>2) &quot;wekser&quot;<br>3) &quot;bob&quot;<br>4) &quot;tom&quot;<br>127.0.0.1:6379&gt; zrem salary kitty		#移除一个元素<br>(integer) 1<br>127.0.0.1:6379&gt; zrange salary 0 -1<br>1) &quot;wekser&quot;<br>2) &quot;bob&quot;<br>3) &quot;tom&quot;<br>127.0.0.1:6379&gt; ZCARD salary		#获取有序集合中的个数<br>(integer) 3<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">获取指定区间的成员数量</span><br>127.0.0.1:6379&gt; zadd zset1 1 hello 2 wesker 3 world<br>(integer) 3<br>127.0.0.1:6379&gt; ZRANGE zset1 0 -1<br>1) &quot;hello&quot;<br>2) &quot;wesker&quot;<br>3) &quot;world&quot;<br>127.0.0.1:6379&gt; ZCOUNT zset1 1 3	#获取指定区间的成员数量<br>(integer) 3<br><br></code></pre></td></tr></table></figure>

<h1 id="三种特殊数据类型"><a href="#三种特殊数据类型" class="headerlink" title="三种特殊数据类型"></a>三种特殊数据类型</h1>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring入门</title>
    <url>/2021/10/07/Spring/</url>
    <content><![CDATA[<h1 id="Spring框架"><a href="#Spring框架" class="headerlink" title="Spring框架"></a>Spring框架</h1><h1 id="1-软件框架技术简介"><a href="#1-软件框架技术简介" class="headerlink" title="1.软件框架技术简介"></a>1.软件框架技术简介</h1><p>软件框架（software framework），通常指的是为了实现某个业界标准或完成特定基本任务的软件组件规范，也指为了实现某个软件组件规范时，提供规范所要求之基础功能的软件产品。</p>
<p>框架的功能类似于基础设施，与具体的软件应用无关，但是提供并实现最为基础的软件架构和体系。</p>
<p>1.为什么需要框架技术：</p>
<ol>
<li><p>帮我们更快更好地构建程序</p>
</li>
<li><p>是一个应用程序的半成品</p>
</li>
<li><p>提供可重用的公共结构</p>
</li>
<li><p>按一定规则组织的一组组件</p>
</li>
</ol>
<p>2.优势：</p>
<ol>
<li><p>不用再考虑公共问题</p>
</li>
<li><p>专心在业务实现上</p>
</li>
<li><p>结构统一，易于学习、维护</p>
</li>
<li><p>新手也可写出好程序</p>
</li>
</ol>
<p><code>不要重复造轮子（Stop Trying to Reinvent the Wheel），已经成为开发人员的基本原则。</code></p>
<p>Java世界中的主流框架技术： Spring、SpringMVC、MyBatis、Struts、Hibernate、SpringBoot等。</p>
<h1 id="2-Spring框架"><a href="#2-Spring框架" class="headerlink" title="2.Spring框架"></a>2.Spring框架</h1><h2 id="2-1-Spring框架简介"><a href="#2-1-Spring框架简介" class="headerlink" title="2.1.Spring框架简介"></a>2.1.Spring框架简介</h2><p>Spring是一个基于java的轻量级的、一站式框架。 虽然Spring是一个轻量级框架，但并不表示它的功能少。实际上，spring是一个庞然大物，包罗万象。 时至今日，Spring已经成为java世界中事实上的标准。</p>
<p>Spring之父：Rod Johnson(罗德.约翰逊) 他是悉尼大学音乐学博士，而计算机仅仅是学士学位。 由于Rod对JAVAEE笨重、臃肿的现状深恶痛绝，以至于他将他在JAVAEE实战中的经历称为噩梦般的经历。他决定改变这种现状，于是就有了Spring。</p>
<p><img src="/2021/10/07/Spring/1604979623519-f4d4da3a-8e02-4214-a746-0afbf118cdc5-163505409965110.png"></p>
<h2 id="2-2-Spring体系架构"><a href="#2-2-Spring体系架构" class="headerlink" title="2.2.Spring体系架构"></a>2.2.Spring体系架构</h2><p><img src="/2021/10/07/Spring/1604979623542-f6978c97-76d9-4158-8051-ce4f898bbcc4-16339465211622.png"></p>
<p>Spring 总共大约有 20 个模块，由 1300 多个不同的文件构成。而这些组件被分别整合在6 个模块中：</p>
<ol>
<li>核心容器（Core Container）</li>
<li>AOP（Aspect Oriented Programming）</li>
<li>设备支持（Instrmentation）</li>
<li>数据访问及集成（Data Access/Integeration）</li>
<li>Web报文发送（Messaging）</li>
<li>Test测试</li>
</ol>
<h2 id="2-3-Spring两大核心"><a href="#2-3-Spring两大核心" class="headerlink" title="2.3.Spring两大核心"></a>2.3.Spring两大核心</h2><p>DI：依赖注入（Dependency Injection） AOP：面向切面编程（Aspect Oriented Programming）</p>
<h1 id="3-DI（依赖注入）"><a href="#3-DI（依赖注入）" class="headerlink" title="3.DI（依赖注入）"></a>3.DI（依赖注入）</h1><p>依赖注入（Dependency Injection）是一种设计模式，也是Spring框架的核心概念之一。其作用是去除组件之间的依赖关系，实现解耦合。 也就是说：所谓依赖注入，是指工程中需要的组件无须自己创建，而是依赖于外部环境注入。</p>
<p>Spring实现依赖注入有三种方式：注解方式（官方推荐方式）、xml配置文件方式、javaConfig方式。</p>
<h2 id="3-1-使用xml实现DI"><a href="#3-1-使用xml实现DI" class="headerlink" title="3.1.使用xml实现DI"></a>3.1.使用xml实现DI</h2><p>下面使用 Spring 来重构dao层组件与service层组件。 也就是说：由Spring创建dao层组件和service层组件，并使用Spring将dao层组件注入给service层组件。</p>
<h3 id="3-1-1-添加Spring依赖"><a href="#3-1-1-添加Spring依赖" class="headerlink" title="3.1.1.添加Spring依赖"></a>3.1.1.添加Spring依赖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>    &lt;groupId&gt;com.neusoft&lt;/groupId&gt;<br>    &lt;artifactId&gt;springtest&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;!-- 设置jdk版本 --&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;source&gt;1.8&lt;/source&gt;<br>                    &lt;target&gt;1.8&lt;/target&gt;<br>                    &lt;encoding&gt;utf-8&lt;/encoding&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>    &lt;properties&gt;<br>        &lt;!-- spring 版本号 --&gt;<br>        &lt;spring.version&gt;5.2.8.RELEASE&lt;/spring.version&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;!-- 此依赖会关联引用Spring中的所有基础jar包 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;<br></code></pre></td></tr></table></figure>

<h3 id="3-1-2-创建dao接口与实现类"><a href="#3-1-2-创建dao接口与实现类" class="headerlink" title="3.1.2.创建dao接口与实现类"></a>3.1.2.创建dao接口与实现类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.dao;<br>import com.neusoft.po.User;<br>public interface UserDao &#123;<br>    public User getUser();<br>&#125;<br>package com.neusoft.dao.impl;<br>import com.neusoft.dao.UserDao;<br>import com.neusoft.po.User;<br>public class UserDaoImpl implements UserDao&#123;<br>    @Override<br>    public User getUser() &#123;<br>        return new User(1,&quot;test&quot;,&quot;111&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-1-3-创建service接口与实现类"><a href="#3-1-3-创建service接口与实现类" class="headerlink" title="3.1.3.创建service接口与实现类"></a>3.1.3.创建service接口与实现类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.service;<br>import com.neusoft.po.User;<br>public interface UserService &#123;<br>    public User getUser();<br>&#125;<br>package com.neusoft.service.impl;<br>import com.neusoft.dao.UserDao;<br>import com.neusoft.po.User;<br>import com.neusoft.service.UserService;<br>public class UserServiceImpl implements UserService&#123;<br>    private UserDao userDao;<br>    @Override<br>    public User getUser() &#123;<br>        return userDao.getUser();<br>    &#125;<br>    public UserDao getUserDao() &#123;<br>        return userDao;<br>    &#125;<br>    public void setUserDao(UserDao userDao) &#123;<br>        this.userDao = userDao;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-1-4-创建Spring配置文件"><a href="#3-1-4-创建Spring配置文件" class="headerlink" title="3.1.4.创建Spring配置文件"></a>3.1.4.创建Spring配置文件</h3><p>在类路径下创建spring.xml配置文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans<br>    xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>                    http://www.springframework.org/schema/beans/spring-beans.xsd<br>                    http://www.springframework.org/schema/context <br>                    http://www.springframework.org/schema/context/spring-context.xsd<br>                    http://www.springframework.org/schema/aop <br>                    http://www.springframework.org/schema/aop/spring-aop-4.1.xsd&quot;&gt;<br>    &lt;bean id=&quot;userDao&quot; class=&quot;com.neusoft.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;<br>    &lt;bean id=&quot;userService&quot; class=&quot;com.neusoft.service.impl.UserServiceImpl&quot;&gt;<br>        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;<br>    &lt;/bean&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>Spring配置文件就相当于一个容器。此容器中负责创建对象，并实现对象与对象之间的装配。</p>
</li>
<li><p>java中每一个类都是一个bean。所以上面的bean标签，就是在容器中创建一个java对象。</p>
</li>
<li><p>bean标签中的class属性，就是类名； id属性，就是对象名。</p>
</li>
<li><p>property标签，是给bean的属性注入其它对象。name属性，就是对象属性名； ref属性，就是给属性注入的对象。（如果想要注入基本数据类型，那么使用value属性）</p>
</li>
<li><p>给bean的属性注入其它对象，默认使用 get/set 方法注入。也可以使用其它方式注入：构造方法注入、P命名空间注入等。</p>
</li>
</ol>
<h3 id="3-1-5-测试"><a href="#3-1-5-测试" class="headerlink" title="3.1.5. 测试"></a>3.1.5. 测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>import com.neusoft.po.User;<br>import com.neusoft.service.UserService;<br>public class MySpringTest &#123;<br>    public static void main(String[] args) &#123;<br>        //读取Spring配置文件,获取Spring容器<br>        ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>        //通过Spring容器的getBean方法获得对象<br>        UserService service = (UserService)context.getBean(&quot;userService&quot;);<br>        User user = service.getUser();<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="3-2-使用注解实现DI"><a href="#3-2-使用注解实现DI" class="headerlink" title="3.2.使用注解实现DI"></a>3.2.使用注解实现DI</h2><p>注解（Annotation），也叫元数据。它是一种代码级别的说明，是jdk1.5之后引入的一个特性。</p>
<p>注解的作用：</p>
<ol>
<li><p>编写文档：通过代码里标识的元数据生成文档。</p>
</li>
<li><p>代码分析：通过代码里标识的元数据对代码进行分析。</p>
</li>
<li><p>编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">//@Override就是一个编译检查注解<br>@Override<br>public int saveBusiness(String businessName) &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>注解基本语法：@注解名称(属性=属性值)</p>
<h3 id="3-2-1-修改dao实现类"><a href="#3-2-1-修改dao实现类" class="headerlink" title="3.2.1.修改dao实现类"></a>3.2.1.修改dao实现类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.dao.impl;<br>import org.springframework.stereotype.Component;<br>import com.neusoft.dao.UserDao;<br>import com.neusoft.po.User;<br>@Component<br>public class UserDaoImpl implements UserDao&#123;<br>    @Override<br>    public User getUser() &#123;<br>        return new User(1,&quot;test&quot;,&quot;111&quot;);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>@Component：创建此类的对象，并放入到Spring容器中。 @Component(“xxxx”)：创建此类的对象，取一个对象名，并放入到Spring容器中。</p>
<h3 id="3-2-2-修改Service实现类"><a href="#3-2-2-修改Service实现类" class="headerlink" title="3.2.2.修改Service实现类"></a>3.2.2.修改Service实现类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.service.impl;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.stereotype.Component;<br>import com.neusoft.dao.UserDao;<br>import com.neusoft.po.User;<br>import com.neusoft.service.UserService;<br>@Component(&quot;userService&quot;)<br>public class UserServiceImpl implements UserService&#123;<br>    @Autowired<br>    private UserDao userDao;<br>    @Override<br>    public User getUser() &#123;<br>        return userDao.getUser();<br>    &#125;<br>    //注意：UserDao属性自动注入，所以就可以不用get/set方法了<br>&#125;<br></code></pre></td></tr></table></figure>

<p>@Autowired：默认按照类型在Spring容器寻找对象，并注入到属性中。 所以此时要注意：UserDao接口的实现类只能有一个。</p>
<h3 id="3-2-3-修改Spring配置文件"><a href="#3-2-3-修改Spring配置文件" class="headerlink" title="3.2.3.修改Spring配置文件"></a>3.2.3.修改Spring配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans<br>    xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>                    http://www.springframework.org/schema/beans/spring-beans.xsd<br>                    http://www.springframework.org/schema/context <br>                    http://www.springframework.org/schema/context/spring-context.xsd<br>                    http://www.springframework.org/schema/aop <br>                    http://www.springframework.org/schema/aop/spring-aop-4.1.xsd&quot;&gt;<br>    &lt;!--开启注解扫描，设置需要扫描的包  --&gt;<br>    &lt;context:component-scan base-package=&quot;com.neusoft&quot;/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<p>context:component-scan标签中的base-package属性，设置需要扫描的包。 会到指定包（包括指定包下的所有子包）中扫描类、方法、属性上面是否有注解。（如有多个，可使用逗号分隔）</p>
<h3 id="3-2-4-测试"><a href="#3-2-4-测试" class="headerlink" title="3.2.4.测试"></a>3.2.4.测试</h3><p>测试类没有变化。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft;<br>import org.springframework.context.ApplicationContext;<br>import org.springframework.context.support.ClassPathXmlApplicationContext;<br>import com.neusoft.po.User;<br>import com.neusoft.service.UserService;<br>public class MySpringTest &#123;<br>    public static void main(String[] args) &#123;<br>        //读取Spring配置文件,获取Spring容器<br>        ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>        //通过Spring容器的getBean方法获得对象<br>        UserService service = (UserService)context.getBean(&quot;userService&quot;);<br>        User user = service.getUser();<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-2-5-相关注解说明"><a href="#3-2-5-相关注解说明" class="headerlink" title="3.2.5.相关注解说明"></a>3.2.5.相关注解说明</h3><h4 id="3-2-5-1-组件级注解"><a href="#3-2-5-1-组件级注解" class="headerlink" title="3.2.5.1.组件级注解"></a>3.2.5.1.组件级注解</h4><p>除了@Component这个泛指组件的注解外，Spring还提供了与@Component功能相同的三个语义化注解。</p>
<ol>
<li><p>@Service 业务层组件</p>
</li>
<li><p>@Controller 控制层组件</p>
</li>
<li><p>@Repository 数据层组件</p>
</li>
</ol>
<p>修改上面代码，使用@Repository 和 @Service 替换 dao 与 service 组件上的注解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@Repository<br>public class UserDaoImpl implements UserDao&#123; &#125;<br>@Service(&quot;userService&quot;)<br>public class UserServiceImpl implements UserService&#123; &#125;<br></code></pre></td></tr></table></figure>

<h4 id="3-2-5-2-Bean作用范围注解"><a href="#3-2-5-2-Bean作用范围注解" class="headerlink" title="3.2.5.2.Bean作用范围注解"></a>3.2.5.2.Bean作用范围注解</h4><p>@Scope() 注解：设置Bean的作用域。值如下：</p>
<p><img src="/2021/10/07/Spring/1604979623533-7ee8e19c-f65f-4f35-8d43-3d1cb7789021.png"></p>
<p>在UserServiceImpl中添加@Scope注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@Service(&quot;userService&quot;)<br>@Scope(&quot;prototype&quot;)<br>public class UserServiceImpl implements UserService&#123; &#125;<br></code></pre></td></tr></table></figure>

<p>在测试类中测试多例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>UserService service1 = (UserService)context.getBean(&quot;userService&quot;);<br>UserService service2 = (UserService)context.getBean(&quot;userService&quot;);<br>System.out.println(service1==service2);      //false<br></code></pre></td></tr></table></figure>

<h4 id="3-2-5-3-自动注入组件注解"><a href="#3-2-5-3-自动注入组件注解" class="headerlink" title="3.2.5.3.自动注入组件注解"></a>3.2.5.3.自动注入组件注解</h4><p>@Autowired 注解：默认按照类型自动给属性注入Spring容器中的对象。所以可以不取对象名。</p>
<p>如果需要按照对象名给属性注入，那么可以配合@Qualifier注解使用。</p>
<ol>
<li>首先，给UserDao取对象名</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@Repository(&quot;userDao&quot;)<br>public class UserDaoImpl implements UserDao&#123; &#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>使用@Qualifier通知@Autowired 注解，注入对象名为userDao的对象</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@Autowired<br>@Qualifier(&quot;userDao&quot;)<br>private UserDao userDao;<br></code></pre></td></tr></table></figure>

<h2 id="3-3-使用javaConfig实现DI"><a href="#3-3-使用javaConfig实现DI" class="headerlink" title="3.3.使用javaConfig实现DI"></a>3.3.使用javaConfig实现DI</h2><p>javaConfig，是在 Spring 3.0 开始从一个独立的项目并入到 Spring 中的。javaConfig 可以看成一个用于完成 Bean 装配的 Spring 配置文件，即 Spring 容器，只不过该容器不是 XML文件，而是由程序员使用 java 自己编写的 java 类。</p>
<p>一个类中只要标注了@Configuration注解，这个类就可以为spring容器提供Bean定义的信息了，或者说这个类就成为一个spring容器了。</p>
<p>标注了@Configuration和标注了@Component的类一样是一个Bean，可以被Spring的 context:component-scan 标签扫描到。类中的每个标注了@Bean的方法都相当于提供了一个Bean的定义信息。</p>
<h3 id="3-3-1-创建javaConfig类"><a href="#3-3-1-创建javaConfig类" class="headerlink" title="3.3.1.创建javaConfig类"></a>3.3.1.创建javaConfig类</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft;<br>import org.springframework.beans.factory.annotation.Configurable;<br>import org.springframework.context.annotation.Bean;<br>import org.springframework.context.annotation.Configuration;<br>import com.neusoft.dao.UserDao;<br>import com.neusoft.dao.impl.UserDaoImpl;<br>import com.neusoft.service.UserService;<br>import com.neusoft.service.impl.UserServiceImpl;<br>@Configuration<br>public class AppConfig &#123;<br>    @Bean<br>    public UserDao userDao() &#123;<br>        return new UserDaoImpl();<br>    &#125;<br>    @Bean<br>    public UserService userService() &#123;<br>        //这里不能声明接口类型<br>        UserServiceImpl userService = new UserServiceImpl();<br>        //配置依赖关系（需要set方法）<br>        userService.setUserDao(userDao());<br>        return userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-3-2-测试"><a href="#3-3-2-测试" class="headerlink" title="3.3.2.测试"></a>3.3.2.测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>UserService service = (UserService)context.getBean(&quot;userService&quot;);<br>User user = service.getUser();<br>System.out.println(user);<br></code></pre></td></tr></table></figure>

<h2 id="3-4-BeanFactory与ApplicationContext"><a href="#3-4-BeanFactory与ApplicationContext" class="headerlink" title="3.4.BeanFactory与ApplicationContext"></a>3.4.BeanFactory与ApplicationContext</h2><p>获取Spring容器也可以使用BeanFactory接口。BeanFactory与ApplicationContext的区别是：</p>
<ol>
<li>BeanFactory<br>Bean工厂（org.springframework.beans.factory.BeanFactory）是Spring框架最核心的接口，提供了IoC的配置机制，使管理不同类型的Java对象成为可能。特点是：采用延迟加载Bean，直到第一次使用Bean实例时才会创建Bean。</li>
<li>ApplicationContext<br>应用上下文（org.springframework.context.ApplicationContext），继承自BeanFactory，提供了更多面向应用的功能，比如国际化支持、框架事件体系，更易于创建实际应用。</li>
</ol>
<p>应用时，我们一般称BeanFactory为IoC容器，ApplicationContext为应用上下文：</p>
<ol>
<li><p>BeanFactory是Spring框架的基础设施，面向Spring本身；</p>
</li>
<li><p>ApplicationContext面向使用Spring框架的开发者；</p>
</li>
<li><p>几乎所有的应用场合都可以直接使用ApplicationContext而非底层的BeanFactory;</p>
</li>
</ol>
<h2 id="3-5-IOC与DI"><a href="#3-5-IOC与DI" class="headerlink" title="3.5.IOC与DI"></a>3.5.IOC与DI</h2><p>IOC：控制反转（Inversion of Control）：它是一种控制权的转移。即组件与组件之间的依赖由主动变为被动。也就是说：应用程序本身不再负责组件的创建、维护等，而是将控制权移交出去。从这一点来说，几乎所有的框架都是IOC框架。</p>
<p>DI：依赖注入（Dependency Injection）：依赖其他容器（比如spring）来创建和维护所需要的组件，并将其注入到应用程序中。</p>
<p>IOC只是将组件控制权移交出去，但并没有说明组件如何获取。而DI明确说明：组件依赖Spring容器获取。 所以可以这样说：DI是IOC思想的一种具体实现。</p>
<h1 id="4-AOP（面向切面）"><a href="#4-AOP（面向切面）" class="headerlink" title="4.AOP（面向切面）"></a>4.AOP（面向切面）</h1><p>AOP：全称是 Aspect Oriented Programming 即：面向切面编程。</p>
<p>简单的说它就是把我们程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对我们的已有方法进行增强。</p>
<p>即当需要扩展功能时，传统方式采用纵向继承方式实现。但这种方式有很多缺点。 比如：父类方法名称改变时，子类也要修改。给多个方法扩展功能时，子类也需要修改。 因此，spring的AOP，实际上是采用横向抽取机制，取代传统的纵向继承体系。</p>
<p>实现AOP示意图：</p>
<ol>
<li>先将方面代码抽取出来<br><img src="/2021/10/07/Spring/1604979623887-9e3b1c96-0dcf-46e2-ad14-238af06d56dd-16350540996446.png"></li>
<li>运行时将业务代码和方面代码编织在一起<br><img src="/2021/10/07/Spring/1604979623883-6aaf0e7d-d06c-45ca-928c-3d9cdb5aca49-16350540996444.png"></li>
</ol>
<p>Spring AOP 可以使用xml文件形式实现，也可以使用注解方式实现。下面只使用注解方式实现Spring AOP。</p>
<h2 id="4-1-使用注解方式实现AOP"><a href="#4-1-使用注解方式实现AOP" class="headerlink" title="4.1.使用注解方式实现AOP"></a>4.1.使用注解方式实现AOP</h2><p>下面例子功能为：在运行业务方法前，输出一段日志。</p>
<h3 id="4-1-1-添加aspectj依赖"><a href="#4-1-1-添加aspectj依赖" class="headerlink" title="4.1.1.添加aspectj依赖"></a>4.1.1.添加aspectj依赖</h3><p>Aspectj是一个基于java的、面向切面的AOP框架。Spring2.0之后增加了对Aspectj切点表达式的支持。而实际开发中一般都使用Aspectj方式来实现AOP。所以还要导入Aspectj相关jar包。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;org.aspectj&lt;/groupId&gt;<br>    &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;<br>    &lt;version&gt;1.8.7&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<h3 id="4-1-2-抽取方面代码封装通知对象"><a href="#4-1-2-抽取方面代码封装通知对象" class="headerlink" title="4.1.2.抽取方面代码封装通知对象"></a>4.1.2.抽取方面代码封装通知对象</h3><p>在实际开发中，除了业务逻辑这个主要功能之外，还需要处理许多辅助功能。 比如：日志、异常处理、事务、输入验证、安全等等，我们将这些代码称为：<strong>方面代码</strong>。而方面代码，就是我们要抽取出来的。</p>
<p>下面抽取日志方面代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.advice;<br>import org.aspectj.lang.JoinPoint;<br>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.springframework.stereotype.Component;<br>@Component<br>@Aspect     //@Aspect定义此类为方面代码，即是一个通知。<br>public class MyAdvice &#123;<br>    @Before(&quot;execution(* com.neusoft.service.impl.*.*(..))&quot;)<br>    public void beforeMethod(JoinPoint joinpoint)&#123;<br>        System.out.println(&quot;【前置通知日志】&quot; + joinpoint.toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>@Aspect注解：定义此类为方面代码，即是一个通知。</p>
</li>
<li><p>@Before注解：定义一个前置通知。即在目标方法执行前切入此注解标注的方法。</p>
</li>
<li><p>execution() 是一个Aspect表达式，语法为：execution(返回值类型 包名.类名.方法名 (参数) 异常)</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">/*<br> * 例如：execution(* com.neusoft.service.impl.*.*(..))<br> * 第一个 *：所有的返回值类型<br> * 第二个 *：所有的类<br> * 第三个 *：所有的方法<br> * 第四个 .. ：所有的参数<br> */<br></code></pre></td></tr></table></figure>

<h3 id="4-1-3-修改Spring配置文件"><a href="#4-1-3-修改Spring配置文件" class="headerlink" title="4.1.3.修改Spring配置文件"></a>4.1.3.修改Spring配置文件</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans<br>    xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans <br>                    http://www.springframework.org/schema/beans/spring-beans.xsd<br>                    http://www.springframework.org/schema/context <br>                    http://www.springframework.org/schema/context/spring-context.xsd<br>                    http://www.springframework.org/schema/aop <br>                    http://www.springframework.org/schema/aop/spring-aop-4.1.xsd&quot;&gt;<br>    &lt;!--开启注解扫描，设置需要扫描的包  --&gt;<br>    &lt;context:component-scan base-package=&quot;com.neusoft&quot;/&gt;<br>    &lt;!-- 声明自动为spring容器中那些配置@Aspect切面的bean创建代理，织入切面。 --&gt;<br>    &lt;aop:aspectj-autoproxy/&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<p>aop:aspectj-autoproxy标签：声明自动为spring容器中那些配置@Aspect切面的bean创建代理，织入切面。</p>
<h3 id="4-1-4-测试"><a href="#4-1-4-测试" class="headerlink" title="4.1.4.测试"></a>4.1.4.测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public static void main(String[] args) &#123;<br>    //读取Spring配置文件,获取Spring容器<br>    ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>    //通过Spring容器的getBean方法获得对象<br>    UserService service = (UserService)context.getBean(&quot;userService&quot;);<br>    User user = service.getUser();<br>    System.out.println(user);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-2-五种通知类型"><a href="#4-2-五种通知类型" class="headerlink" title="4.2.五种通知类型"></a>4.2.五种通知类型</h2><p>方面代码一般也称为通知：定义一个“切面”要实现的功能。通知有五种：</p>
<ol>
<li><p>前置通知：在某连接点（JoinPoint 就是要织入的业务方法）之前执行的通知。</p>
</li>
<li><p>后置通知：当某连接点退出时执行的通知（不论是正常结束还是发生异常）。</p>
</li>
<li><p>返回通知：（最终通知）在这里可以得到业务方法的返回值。但在发生异常时无法得到返回值。</p>
</li>
<li><p>环绕通知：包围一个连接点的通知，也就是在业务方法执行前和执行后执行的通知。</p>
</li>
<li><p>异常通知：在业务方法发生异常时执行的通知。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.advice;<br>import org.aspectj.lang.JoinPoint;<br>import org.aspectj.lang.ProceedingJoinPoint;<br>import org.aspectj.lang.annotation.After;<br>import org.aspectj.lang.annotation.AfterReturning;<br>import org.aspectj.lang.annotation.AfterThrowing;<br>import org.aspectj.lang.annotation.Around;<br>import org.aspectj.lang.annotation.Aspect;<br>import org.aspectj.lang.annotation.Before;<br>import org.aspectj.lang.annotation.Pointcut;<br>import org.springframework.stereotype.Component;<br>@Component<br>@Aspect<br>public class MyAdvice &#123;<br>    //定义通用Aspect表达式，下面通知方法就可以引用此方法的规则了<br>    @Pointcut(&quot;execution(* com.neusoft.service.impl.*.*(..))&quot;)<br>    private void anyMethod()&#123;&#125;<br>    @Before(&quot;anyMethod()&quot;)<br>    public void beforeMethod(JoinPoint joinpoint)&#123;<br>        System.out.println(&quot;【前置通知日志】&quot; + joinpoint.toString());<br>    &#125;<br>    @After(&quot;anyMethod()&quot;)<br>    public void afterMethod(JoinPoint joinpoint)&#123;<br>        System.out.println(&quot;后置通知日志&quot; + joinpoint.toString());<br>    &#125;<br>    @AfterReturning(pointcut=&quot;anyMethod()&quot;,returning=&quot;result&quot;)<br>    public void afterReturnning(JoinPoint joinpoint,Object result)&#123;<br>        System.out.println(&quot;返回通知日志&quot; + joinpoint.toString());<br>    &#125;<br>    @AfterThrowing(pointcut=&quot;anyMethod()&quot;,throwing=&quot;ex&quot;)<br>    public void afterThrowing(JoinPoint joinpoint,Exception ex)&#123;<br>        System.out.println(&quot;异常通知日志&quot; + joinpoint.toString());<br>    &#125;<br>    @Around(&quot;anyMethod()&quot;)<br>    public Object aroundMethod(ProceedingJoinPoint pjp) &#123;<br>        Object obj = null;<br>        try&#123;<br>            System.out.println(&quot;环绕通知日志&quot; + pjp.toString());<br>            obj = pjp.proceed();<br>        &#125;catch(Throwable e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        return obj;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>如果配置了环绕通知，那么业务方法的执行将在环绕通知中的obj = pjp.proceed();这段代码时开始执行。此时要注意：如果环绕通知方法不写返回值，或者obj = pjp.proceed()这段代码如果不取得返回值，那么返回通知也不能取得返回值。</p>
</li>
<li><p>有了环绕通知，异常通知也将失去作用。</p>
</li>
<li><p>实际上，如果要配置环绕通知，那么其他通知就失去意义了。因为在环绕通知中，也可以在方法执行前、执行后做方面代码，包括获取返回值、做异常处理等。</p>
</li>
</ol>
<h2 id="4-3-Spring动态代理的两种形式"><a href="#4-3-Spring动态代理的两种形式" class="headerlink" title="4.3.Spring动态代理的两种形式"></a>4.3.Spring动态代理的两种形式</h2><h3 id="4-3-1-两种动态代理"><a href="#4-3-1-两种动态代理" class="headerlink" title="4.3.1.两种动态代理"></a>4.3.1.两种动态代理</h3><p>动态代理是一种常用的设计模式，广泛应用于框架中，Spring框架的AOP特性就是应用动态代理实现的。</p>
<p><img src="/2021/10/07/Spring/1604979623912-ddd3cc33-6d61-4fae-b0e3-80d7a9b0c720-16350540996458.png"></p>
<p>实现动态代理有两种形式：</p>
<ol>
<li>jdk动态代理：根据目标类接口获取代理类实现规则，生成代理对象。这个代理对象，也是目标类接口的一个实现类。</li>
<li>cglib动态代理：根据目标类本身获取代理类实现规则，生成代理对象。这个代理对象，也是目标类的一个子类。 （如果目标类为final，则不能使用CGLib实现动态代理）</li>
</ol>
<p>SpringAOP可以自动在jdk动态代理和CGLib动态代理之间进行切换，规则如下：</p>
<ol>
<li><p>如果目标对象实现了接口，采用jdk动态代理实现aop。</p>
</li>
<li><p>如果目标对象没有实现接口，采用CGLib动态代理实现aop。</p>
</li>
<li><p>如果目标对象实现了接口，但仍然想要使用CGLIB实现aop，可以手动进行配置。</p>
</li>
</ol>
<h3 id="4-3-2-性能测试"><a href="#4-3-2-性能测试" class="headerlink" title="4.3.2.性能测试"></a>4.3.2.性能测试</h3><p>我们通过获取执行代码所耗费的时间，来实际测试两种动态代理方式的性能对比。</p>
<ol>
<li>jdk动态代理测试：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public static void main(String[] args) &#123;<br>    ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>    long begin = System.currentTimeMillis();<br>    //使用接口<br>    UserService service = (UserService)context.getBean(&quot;userService&quot;);<br>    User user = service.getUser();<br>    long end = System.currentTimeMillis();<br>    System.out.println(&quot;执行时间：&quot;+(end-begin));<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>cglib动态代理测试：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public static void main(String[] args) &#123;<br>    ApplicationContext context = new  ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>    long begin = System.currentTimeMillis();<br>    //不使用接口<br>    UserServiceImpl service = (UserServiceImpl)context.getBean(&quot;userService&quot;);<br>    User user = service.getUser();<br>    long end = System.currentTimeMillis();<br>    System.out.println(&quot;执行时间：&quot;+(end-begin));<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>dao层不能再实现接口。</li>
<li>service层不能再实现接口。</li>
</ol>
<h1 id="5-Spring集成MyBatis"><a href="#5-Spring集成MyBatis" class="headerlink" title="5.Spring集成MyBatis"></a>5.Spring集成MyBatis</h1><p>所谓的Spring集成MyBatis，就是由Spring给MyBatis注入需要的组件。比如：DataSource（数据源）、SqlSessionFactory、sqlSession、事务管理对象等。</p>
<h2 id="5-1-添加集成MyBatis的依赖"><a href="#5-1-添加集成MyBatis的依赖" class="headerlink" title="5.1.添加集成MyBatis的依赖"></a>5.1.添加集成MyBatis的依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;properties&gt;<br>    &lt;spring.version&gt;5.2.8.RELEASE&lt;/spring.version&gt;<br>&lt;/properties&gt;<br>&lt;dependencies&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--spring对jdbc的支持依赖包（关联spring-tx包） --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;<br>        &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;!-- mybatis-spring 依赖包 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>        &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;<br>        &lt;version&gt;2.0.0&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;!--mybatis 依赖包 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;org.mybatis&lt;/groupId&gt;<br>        &lt;artifactId&gt;mybatis&lt;/artifactId&gt;<br>        &lt;version&gt;3.5.1&lt;/version&gt;<br>    &lt;/dependency&gt;<br>    &lt;!-- mysql驱动 依赖包 --&gt;<br>    &lt;dependency&gt;<br>        &lt;groupId&gt;mysql&lt;/groupId&gt;<br>        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;<br>        &lt;version&gt;5.1.6&lt;/version&gt;<br>    &lt;/dependency&gt;<br>&lt;/dependencies&gt;<br></code></pre></td></tr></table></figure>

<h2 id="5-2-创建Mapper"><a href="#5-2-创建Mapper" class="headerlink" title="5.2.创建Mapper"></a>5.2.创建Mapper</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.ms.mapper;<br>import org.apache.ibatis.annotations.Mapper;<br>import org.apache.ibatis.annotations.Select;<br>import org.apache.ibatis.annotations.Update;<br>import com.neusoft.ms.po.Emp;<br>@Mapper<br>public interface EmpMapper &#123;<br>    @Select(&quot;select * from emp where empno=#&#123;empno&#125;&quot;)<br>    public Emp getEmpById(int empno);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在Mapper接口上添加@Mapper注解，Spring容器扫描到此注解后，就会将SqlSession注入给Mapper组件。</p>
<h2 id="5-3-添加db-properties文件"><a href="#5-3-添加db-properties文件" class="headerlink" title="5.3.添加db.properties文件"></a>5.3.添加db.properties文件</h2><figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.driver</span>=com.mysql.cj.jdbc.Driver<br><span class="hljs-attr">jdbc.url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/elm?useSSL=<span class="hljs-literal">false</span>&amp;allowPublicKeyRetrieval=<span class="hljs-literal">true</span>&amp;serverTimezone=UTC<br><span class="hljs-attr">jdbc.username</span>=root<br><span class="hljs-attr">jdbc.password</span>=<span class="hljs-number">486934.0</span><br></code></pre></td></tr></table></figure>

<h2 id="5-4-Spring容器中添加组件"><a href="#5-4-Spring容器中添加组件" class="headerlink" title="5.4.Spring容器中添加组件"></a>5.4.Spring容器中添加组件</h2><figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-comment">&lt;!--开启注解扫描，设置需要扫描的包（用于扫描测试时用的Service组件）  --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.foreknow&quot;</span>/&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 引入db配置文件  --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 配置dataSource数据源 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">      <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.driver&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.url&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.username&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;jdbc.password&#125;</span><span class="xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 创建SqlSessionFactory，并配置实体对象别名 --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;typeAliasesPackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.neusoft.ms.po&quot;</span> /&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br><span class="xml"><span class="hljs-comment">&lt;!-- 配置Mapper，自动扫描Mapper接口，并为其注入SqlSessionFactory --&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;basePackage&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.foreknow.mapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactoryBeanName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span></span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h2 id="5-5-测试"><a href="#5-5-测试" class="headerlink" title="5.5.测试"></a>5.5.测试</h2><p>创建Service组件，然后测试</p>
<figure class="highlight aspectj"><table><tr><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Service</span>(<span class="hljs-string">&quot;userService&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">User <span class="hljs-title">getEmpById</span><span class="hljs-params">(String UserId)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> userMapper.<span class="hljs-title">getUserByUserId</span><span class="hljs-params">(UserId)</span></span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args)&#123;<br>    ApplicationContext context = <span class="hljs-built_in">new</span> ClassPathXmlApplicationContext(&quot;spring.xml&quot;);<br>    UserService userService = (UserService) context.getBean(&quot;userService&quot;);<br>    <span class="hljs-keyword">User</span> <span class="hljs-keyword">user</span> = userService.getEmpById(&quot;11111111111&quot;);<br>    <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">user</span>.toString());<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-6-添加事务管理"><a href="#5-6-添加事务管理" class="headerlink" title="5.6.添加事务管理"></a>5.6.添加事务管理</h2><p>Spring为了支持事务管理，专门封装了事务管理对象。我们只要在Spring容器中配置这个对象，即可使用。</p>
<p>在Spring容器中添加事务管理的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- 配置Spring提供的事务管理器 --&gt;<br>&lt;bean id=&quot;transactionManager&quot;<br>    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;<br>    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/property&gt;<br>&lt;/bean&gt;<br>&lt;!-- 开启注解事务 --&gt;<br>&lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot; /&gt;<br></code></pre></td></tr></table></figure>

<p>在Service组件中，使用@Transactional注解，就可以给业务方法添加事务管理。</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span>(<span class="hljs-string">&quot;userService&quot;</span>)<br>public class UserServiceImpl implements UserService &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private UserMapper userMapper;<br>    <span class="hljs-variable">@Override</span><br>    <span class="hljs-variable">@Transactional</span><br>    public User getEmpById(String UserId) &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">userMapper</span><span class="hljs-selector-class">.getUserByUserId</span>(UserId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>需要事务管理的service，在方法上加上@Transactional 注解即可。</li>
<li>必须为public方法才行,不要捕捉异常，要让异常自动抛出，否则不能进行事务回滚。</li>
</ol>
</blockquote>
<h2 id="5-7-事务传播行为"><a href="#5-7-事务传播行为" class="headerlink" title="5.7.事务传播行为"></a>5.7.事务传播行为</h2><p>@Transactional 注解中的 propagation 属性，可以设置事务传播行为。属性值为：</p>
<ol>
<li>REQUIRED：如果当前没有事务，就新建一个事务，如果已经存在一个事务中，就加入到这个事务中。这是最常见的选择。</li>
<li>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。</li>
<li>MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。</li>
<li>REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。</li>
<li>NOT_SUPPORTED：以非事务方式执行操作，如果存在事务，就把当前事务挂起。</li>
<li>NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC</title>
    <url>/2021/10/25/SpringMVC/</url>
    <content><![CDATA[<h1 id="01-SpringMVC框架"><a href="#01-SpringMVC框架" class="headerlink" title="01.SpringMVC框架"></a>01.SpringMVC框架</h1><h1 id="1-SpringMVC框架简介"><a href="#1-SpringMVC框架简介" class="headerlink" title="1.SpringMVC框架简介"></a>1.SpringMVC框架简介</h1><h2 id="1-1-框架简介"><a href="#1-1-框架简介" class="headerlink" title="1.1.框架简介"></a>1.1.框架简介</h2><p>Spring MVC 是 Spring 提供给 Web 应用的框架设计。。</p>
<p>Spring MVC 角色划分清晰，分工明细，并且和 Spring 框架无缝结合。作为当今业界最主流的 Web 开发框架，Spring MVC 已经成为当前javaWeb框架事实上的标准。</p>
<h2 id="1-2-SpringMVC核心架构流程"><a href="#1-2-SpringMVC核心架构流程" class="headerlink" title="1.2.SpringMVC核心架构流程"></a>1.2.SpringMVC核心架构流程</h2><p><img src="/2021/10/25/SpringMVC/1604979789045-b6ac3995-e979-4b22-a2e6-41e1b4ae1383.png"></p>
<p>springMVC核心架构的具体流程步骤如下：</p>
<ol>
<li><p>首先用户发送请求——&gt;DispatcherServlet（前端控制器），前端控制器收到请求后自己不进行处理，而是委托给其他的解析器进行处理，作为统一访问点，进行全局的流程控制；</p>
</li>
<li><p>DispatcherServlet——&gt;HandlerMapping， HandlerMapping将会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象、多个HandlerInterceptor拦截器）对象，通过这种策略模式，很容易添加新的映射策略；</p>
</li>
<li><p>DispatcherServlet——&gt;HandlerAdapter，HandlerAdapter将会把处理器包装为适配器，从而支持多种类型的处理器，即适配器设计模式的应用，从而很容易支持很多类型的处理器；</p>
</li>
<li><p>HandlerAdapter——&gt;处理器功能处理方法的调用，HandlerAdapter将会根据适配的结果调用真正的处理器的功能处理方法，完成功能处理；并返回一个ModelAndView对象（包含模型数据、逻辑视图名）；</p>
</li>
<li><p>ModelAndView的逻辑视图名——&gt; ViewResolver， ViewResolver将把逻辑视图名解析为具体的View，通过这种策略模式，很容易更换其他视图技术；</p>
</li>
<li><p>View——&gt;渲染，View会根据传进来的Model模型数据进行渲染，此处的Model实际是一个Map数据结构，因此很容易支持其他视图技术；</p>
</li>
<li><p>返回控制权给DispatcherServlet，由DispatcherServlet返回响应给用户，到此一个流程结束。</p>
</li>
</ol>
<h2 id="1-3-前后端分离架构下的SpringMVC"><a href="#1-3-前后端分离架构下的SpringMVC" class="headerlink" title="1.3.前后端分离架构下的SpringMVC"></a>1.3.前后端分离架构下的SpringMVC</h2><p>上一节中，详细描述了SpringMVC的核心架构流程。 但是要注意：<strong>这是非前后端分离模式下的SpringMVC核心架构。</strong></p>
<p>所以，我们会看到：在Handler处理器执行后，返回一个ModelAndView；也就是说：在非前后端分离模式下，视图层是由服务器端控制的。</p>
<p>那么，在前后端分离模式下，视图层要分离出去，成为一个独立工程；或者说：视图层不在由服务器端控制。 <strong>所以，在前后端分离模式下，SpringMVC的核心架构流程修改如下：</strong></p>
<p><img src="/2021/10/25/SpringMVC/1604979788850-9d7fc948-ceb1-42d1-93e0-367e8dd07ccf.png"></p>
<p><strong>本教程中，讲解的都是在前后端分离模式下的SpringMVC</strong></p>
<h1 id="2-SpringMVC框架实例"><a href="#2-SpringMVC框架实例" class="headerlink" title="2.SpringMVC框架实例"></a>2.SpringMVC框架实例</h1><p>SpringMVC框架的开发有两种方式：</p>
<ol>
<li>配置文件方式</li>
<li>注解方式</li>
</ol>
<p><strong>本教程中，只讲解注解方式</strong>。</p>
<h2 id="2-1-创建Maven工程"><a href="#2-1-创建Maven工程" class="headerlink" title="2.1.创建Maven工程"></a>2.1.创建Maven工程</h2><p><img src="/2021/10/25/SpringMVC/image-20211027151858188.png"></p>
<p>项目结构</p>
<p><img src="/2021/10/25/SpringMVC/image-20211027152243854.png"></p>
<h2 id="2-2-在pom-xml文件中添加依赖"><a href="#2-2-在pom-xml文件中添加依赖" class="headerlink" title="2.2.在pom.xml文件中添加依赖"></a>2.2.在pom.xml文件中添加依赖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;<br>    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;<br>    &lt;groupId&gt;com.neusoft&lt;/groupId&gt;<br>    &lt;artifactId&gt;smvc&lt;/artifactId&gt;<br>    &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;<br>    &lt;packaging&gt;war&lt;/packaging&gt;<br>    &lt;build&gt;<br>        &lt;plugins&gt;<br>            &lt;!-- 设置jdk版本 --&gt;<br>            &lt;plugin&gt;<br>                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;<br>                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;<br>                &lt;configuration&gt;<br>                    &lt;source&gt;1.8&lt;/source&gt;<br>                    &lt;target&gt;1.8&lt;/target&gt;<br>                    &lt;encoding&gt;utf-8&lt;/encoding&gt;<br>                &lt;/configuration&gt;<br>            &lt;/plugin&gt;<br>        &lt;/plugins&gt;<br>    &lt;/build&gt;<br>    &lt;properties&gt;<br>        &lt;spring.version&gt;5.2.8.RELEASE&lt;/spring.version&gt;<br>    &lt;/properties&gt;<br>    &lt;dependencies&gt;<br>        &lt;!-- 此依赖会关联引用Spring中的所有基础jar包 --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;<br>            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;<br>        &lt;/dependency&gt;<br>        &lt;!-- spring-webmvc会依赖spring-web --&gt;<br>        &lt;dependency&gt;<br>            &lt;groupId&gt;org.springframework&lt;/groupId&gt;<br>            &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;<br>            &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;<br>        &lt;/dependency&gt;<br>    &lt;/dependencies&gt;<br>&lt;/project&gt;<br></code></pre></td></tr></table></figure>

<h2 id="2-3-配置SpringMVC前端控制器"><a href="#2-3-配置SpringMVC前端控制器" class="headerlink" title="2.3.配置SpringMVC前端控制器"></a>2.3.配置SpringMVC前端控制器</h2><p>在 web.xml 文件中配置 SpringMVC 前端控制器，也就是配置 DispatcherServlet 核心组件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;3.1&quot;&gt;<br>    &lt;servlet&gt;<br>        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;<br>        &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;<br>        &lt;!-- 也可不配置参数，默认加载 /WEB-INF/springmvc-servlet.xml --&gt;<br>        &lt;init-param&gt;<br>            &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;<br>            &lt;param-value&gt;classpath:springmvc-servlet.xml&lt;/param-value&gt;<br>        &lt;/init-param&gt;<br>    &lt;/servlet&gt;<br>    &lt;servlet-mapping&gt;<br>        &lt;servlet-name&gt;springmvc&lt;/servlet-name&gt;<br>        &lt;url-pattern&gt;/&lt;/url-pattern&gt;<br>    &lt;/servlet-mapping&gt;<br>&lt;/web-app&gt;<br></code></pre></td></tr></table></figure>

<p><img src="/2021/10/25/SpringMVC/1604979788776-2609b82f-59e6-4ea2-9fb0-9a7cb9095288.png"></p>
<h2 id="2-4-创建SpringMVC配置文件"><a href="#2-4-创建SpringMVC配置文件" class="headerlink" title="2.4.创建SpringMVC配置文件"></a>2.4.创建SpringMVC配置文件</h2><p>在resources文件夹下创建springmvc-servlet.xml 配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;beans<br>    xmlns=&quot;http://www.springframework.org/schema/beans&quot;<br>    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;<br>    xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;<br>    xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;<br>    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;<br>    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans<br>                        http://www.springframework.org/schema/beans/spring-beans.xsd<br>                        http://www.springframework.org/schema/context<br>                        http://www.springframework.org/schema/context/spring-context.xsd<br>                        http://www.springframework.org/schema/aop<br>                        http://www.springframework.org/schema/aop/spring-aop.xsd<br>                        http://www.springframework.org/schema/mvc<br>                        http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;&gt;<br>    &lt;!-- <br>           此标签能够自动加载注解的处理器映射和注解的处理器适配， <br>          而且还默认加载了很多其他方法。 比如：参数绑定到控制器参数、json转换解析器<br>    --&gt;                 <br>   &lt;mvc:annotation-driven /&gt;<br>   &lt;!-- 开启注解扫描，将包下带有@Controller注解的类纳入Spring容器中--&gt;<br>   &lt;context:component-scan base-package=&quot;com.neusoft.smvc.controller&quot; /&gt;<br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-创建Handler处理器"><a href="#2-5-创建Handler处理器" class="headerlink" title="2.5.创建Handler处理器"></a>2.5.创建Handler处理器</h2><p>在 com.neusoft.springmvc.controller 包下创建 HelloController 处理器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.foreknow.SpringMVC.controller;<br><br>import org.springframework.stereotype.Controller;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.ResponseBody;<br><br>@Controller<br>@RequestMapping(&quot;/HelloConreoller&quot;)<br>public class HelloConreoller &#123;<br>    @ResponseBody<br>    @RequestMapping(&quot;/sayHello&quot;)<br>    public String sayHello() throws Exception&#123;<br>        return &quot;hello&quot;;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>@Controller：此注解声明在类上，表示此类是一个 Handler 处理器类，并被纳入到 Spring 容器中； </p>
<p>@ResponseBody：此注解可以声明在类上，或者方法上；表示处理器方法直接返回数据；</p>
<p>@RequestMapping：此注解可以声明在类上，或者方法上；表示将一个请求url映射给处理器方法。</p>
</blockquote>
<h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6.测试"></a>2.6.测试</h2><p>将工程部署到Tomcat中，启动服务器，在浏览器地址栏中写入：<a href="http://localhost:8080/smvc/HelloConreoller/sayHello">http://localhost:8080/smvc/HelloConreoller/sayHello</a></p>
<h2 id="2-7-相关注解详解"><a href="#2-7-相关注解详解" class="headerlink" title="2.7.相关注解详解"></a>2.7.相关注解详解</h2><h3 id="2-7-1-ResponseBody注解"><a href="#2-7-1-ResponseBody注解" class="headerlink" title="2.7.1.@ResponseBody注解"></a>2.7.1.@ResponseBody注解</h3><p>@responseBody注解的作用是将controller的方法返回的数据写入到response对象的body区，也就是直接将数据写入到输出流中，效果等同于使用 response.getWriter() 输出流对象向前端返回数据。需要注意的是，在使用此注解之后，响应不会再走视图处理器。</p>
<ol>
<li>@responseBody 应用在处理器类上：此处理器类中的所有方法都直接返回数据。</li>
<li>@responseBody 应用在处理器类的某个方法上：此处理器类中的某个方法直接返回数据。</li>
</ol>
<h3 id="2-7-2-RequestMapping注解"><a href="#2-7-2-RequestMapping注解" class="headerlink" title="2.7.2.@RequestMapping注解"></a>2.7.2.@RequestMapping注解</h3><p>用于建立请求URL和处理器方法之间的对应关系。</p>
<ol>
<li>@RequestMapping 应用在处理器类上： 设置请求URL的第一级访问目录。此处不写的话，就相当于应用的根目录。写的话需要以 / 开头。 它出现的目的是为了使我们的URL可以按照模块化管理。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@Controller<br>@RequestMapping(&quot;/user&quot;)<br>public class HelloController &#123;<br>    @ResponseBody<br>    @RequestMapping(&quot;/hello&quot;)<br>    public String hello() throws Exception &#123;<br>        return &quot;hello world&quot;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面处理器方法请求url应该这样写：<a href="http://localhost:8080/springmvc/user/hello">http://localhost:8080/springmvc/user/hello</a></p>
<ol>
<li>@RequestMapping 应用在处理器类的某个方法上：请求URL的第二级访问目录。</li>
<li>@RequestMapping注解中常用属性有：<br>value：用于指定请求的URL。 method：用于指定请求的方式。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">@ResponseBody<br>@RequestMapping(value=&quot;/hello&quot;,method=RequestMethod.POST)<br>public String hello() throws Exception &#123;<br>    return &quot;hello world&quot;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果使用 get 方式访问此处理器方法时（比如：在地址栏中输入url访问），就会出现异常。</p>
<h3 id="2-7-3-GetMapping与-PostMapping"><a href="#2-7-3-GetMapping与-PostMapping" class="headerlink" title="2.7.3.@GetMapping与@PostMapping"></a>2.7.3.@GetMapping与@PostMapping</h3><p>@GetMapping是一个组合注解，是@RequestMapping(method = RequestMethod.GET)的缩写。</p>
<p>@PostMapping是一个组合注解，是@RequestMapping(method = RequestMethod.Post)的缩写。</p>
<h1 id="3-处理器方法的参数与返回值"><a href="#3-处理器方法的参数与返回值" class="headerlink" title="3.处理器方法的参数与返回值"></a>3.处理器方法的参数与返回值</h1><h2 id="3-1-处理器方法参数"><a href="#3-1-处理器方法参数" class="headerlink" title="3.1.处理器方法参数"></a>3.1.处理器方法参数</h2><p>SpringMVC也是基于Spring的，所以可以直接给处理器方法注入参数，自动绑定默认支持的各种数据类型。 这些默认支持的数据类型，或者说可以注入的对象类型有：</p>
<ol>
<li><p>HttpServletRequest对象。</p>
</li>
<li><p>HttpServletResponse对象。</p>
</li>
<li><p>HttpSession对象。（注意：ServletContext不会注入。）</p>
</li>
<li><p>简单数据类型。作用：获取客户端提交的单值参数。</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public String hello(String userName,String password) throws Exception &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>注意：处理器方法的参数名必须与提交参数名一致。</p>
<p>测试：<a href="http://localhost:8080/springmvc/user/hello?userName=zhangsan&amp;password=123">http://localhost:8080/springmvc/user/hello?userName=zhangsan&amp;password=123</a></p>
<ol start="5">
<li>数组类型。 作用：获取客户端提交的多值参数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public String hello(Integer[] aihao) throws Exception &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>注意：处理器方法的参数名必须与提交参数名一致。</p>
<p>测试：<a href="http://localhost:8080/springmvc/user/hello?aihao=1&amp;aihao=2&amp;aihao=3">http://localhost:8080/springmvc/user/hello?aihao=1&amp;aihao=2&amp;aihao=3</a></p>
<ol start="6">
<li>对象类型。 作用：获取客户端提交参数。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public String hello(User user) throws Exception &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>注意：处理器方法的参数名可以任意，但参数中的属性名必须与提交参数名一致。</p>
<p>测试：<a href="http://localhost:8080/springmvc/user/hello?userId=1&amp;userName=zhangsan&amp;password=123">http://localhost:8080/springmvc/user/hello?userId=1&amp;userName=zhangsan&amp;password=123</a></p>
<h2 id="3-2-使用-RequestParam匹配参数"><a href="#3-2-使用-RequestParam匹配参数" class="headerlink" title="3.2.使用@RequestParam匹配参数"></a>3.2.使用@RequestParam匹配参数</h2><p>获取客户端提交参数时，处理器的参数名必须与提交参数名一致。但如果处理器的参数名与提交参数名不一致时，可以使用@RequestParam注解来匹配参数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public String hello(@RequestParam(&quot;username&quot;) String un, <br>                    @RequestParam(&quot;password&quot;) String pw) throws Exception &#123;&#125;<br></code></pre></td></tr></table></figure>

<p>注意：@RequestParam的value值必须与提交参数名一致。</p>
<p>测试：<a href="http://localhost:8080/springmvc/user/hello?userName=zhangsan&amp;password=123">http://localhost:8080/springmvc/user/hello?userName=zhangsan&amp;password=123</a></p>
<h2 id="3-3-接收AJAX提交json数据"><a href="#3-3-接收AJAX提交json数据" class="headerlink" title="3.3.接收AJAX提交json数据"></a>3.3.接收AJAX提交json数据</h2><p>在前后端分离项目中，前端的 ajax 会向服务器端提交 json 数据，SpringMVC也可以直接接收 json 数据。</p>
<p>注意：</p>
<ol>
<li><p>提交的是json对象，所以 SpringMVC 也必须要使用对象来接收。</p>
</li>
<li><p>需要添加CORS过滤器，设置服务器端允许跨域（需要导入servlet-api.jar）。</p>
</li>
<li><p>pom.xml中添加servlet-api依赖</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;dependency&gt;<br>    &lt;groupId&gt;javax.servlet&lt;/groupId&gt;<br>    &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;<br>    &lt;version&gt;4.0.0&lt;/version&gt;<br>    &lt;scope&gt;provided&lt;/scope&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<ol>
<li>添加CORS过滤器</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">package com.neusoft.smvc.filter;<br>import java.io.IOException;<br>import javax.servlet.Filter;<br>import javax.servlet.FilterChain;<br>import javax.servlet.FilterConfig;<br>import javax.servlet.ServletException;<br>import javax.servlet.ServletRequest;<br>import javax.servlet.ServletResponse;<br>import javax.servlet.annotation.WebFilter;<br>import javax.servlet.http.HttpServletRequest;<br>import javax.servlet.http.HttpServletResponse;<br>@WebFilter(&quot;/*&quot;)<br>public class CorsFilter implements Filter &#123;<br>    @Override<br>    public void init(FilterConfig filterConfig) throws ServletException &#123;&#125;<br>    @Override<br>    public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain)<br>            throws IOException, ServletException &#123;<br>        HttpServletRequest request = (HttpServletRequest)req;<br>        HttpServletResponse response = (HttpServletResponse)resp;<br>        //设置允许跨域<br>        response.setHeader(&quot;Access-Control-Allow-Origin&quot;,request.getHeader(&quot;Origin&quot;));<br>        //设置开启Cookie<br>        response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); <br>        chain.doFilter(req, resp);    <br>    &#125;<br>    @Override<br>    public void destroy() &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>SpringMVC处理器中要使用对象接收提交的json数据</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">public String hello(User user) throws Exception &#123;&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>使用Axios提交</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;button onclick=&quot;hello()&quot;&gt;提交&lt;/button&gt;<br>&lt;script src=&quot;https://unpkg.com/axios/dist/axios.js&quot;&gt;&lt;/script&gt;<br>&lt;script src=&quot;https://cdn.bootcss.com/qs/6.5.1/qs.min.js&quot;&gt;&lt;/script&gt;<br>&lt;script&gt;<br>    let user = &#123;<br>        userId:1,<br>        userName:&#x27;zhangsan&#x27;,<br>        password:&#x27;123&#x27;<br>    &#125;;<br>    function hello() &#123;<br>        axios.post(&#x27;http://localhost:8080/smvc/user/hello&#x27;,Qs.stringify(user))<br>            .then(response=&gt;&#123;<br>                console.log(response.data);<br>            &#125;).catch(error=&gt;&#123;<br>                console.log(error);<br>            &#125;);    <br>        /*<br>        axios.get(&#x27;http://localhost:8080/smvc/user/hello&#x27;,&#123;params:user&#125;)<br>            .then(response=&gt;&#123;<br>                console.log(response.data);<br>            &#125;).catch(error=&gt;&#123;<br>                console.log(error);<br>            &#125;);<br>        */<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure>

<h2 id="3-4-处理器方法返回值"><a href="#3-4-处理器方法返回值" class="headerlink" title="3.4.处理器方法返回值"></a>3.4.处理器方法返回值</h2><p>SpringMVC的处理器方法可以返回 ModelAndView ，也可以直接返回数据。 在前后端分离模式中，SpringMVC的处理器方法直接返回数据。所以，返回 ModelAndView 的情况不做讨论。</p>
<ol>
<li>返回 String<br>上面实例中，SpringMVC的处理器方法就是直接返回String。</li>
<li>返回 json<br>首先，在 pom.xml 文件中添加 jackson 依赖：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;!-- jackson相关依赖 --&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;<br>    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;<br>    &lt;version&gt;2.9.0&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure>

<ol>
<li>服务器端代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">//返回值设置为对象或者集合<br>@ResponseBody<br>@RequestMapping(&quot;/hello&quot;)<br>public User hello(User user) throws Exception &#123;<br>System.out.println(user);<br>    return user;<br>&#125;<br>/*<br>@ResponseBody<br>@RequestMapping(&quot;/hello&quot;)<br>public List&lt;User&gt; hello(User user) throws Exception &#123;<br>    List&lt;User&gt; list = new ArrayList&lt;&gt;();<br>    list.add(user);<br>    list.add(user);<br>    list.add(user);<br>    return list;<br>&#125;<br>*/<br></code></pre></td></tr></table></figure>

<ol>
<li>前端代码：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">axios.post(&#x27;http://localhost:8080/smvc/user/hello&#x27;,Qs.stringify(user))<br>    .then(response=&gt;&#123;<br>        console.log(response.data);<br>    &#125;).catch(error=&gt;&#123;<br>        console.log(error);<br>    &#125;);<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>springmvc-servlet.xml 配置文件中必须要有 mvc:annotation-driven 标签配置。这里配置了json转换解析器。</li>
<li>只要 SpringMVC 的处理器返回值设置为对象，或者集合，那么就能返回 json 数据。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Java</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>mybatis入门</title>
    <url>/2021/10/02/mybatis/</url>
    <content><![CDATA[<h1 id="1、ORM思想"><a href="#1、ORM思想" class="headerlink" title="1、ORM思想"></a>1、ORM思想</h1><p>数据库中数据是以表的形式存在的，而java中使用的数据都是对象型的。所以不得不要将表数据转换成对象数据。 这样就会产生大量的没有技术含量的纯 “体力” 型代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>(rs.next()) &#123;<br>    Business business = <span class="hljs-keyword">new</span> Business();<br>    business.setBusinessId(rs.getInt(<span class="hljs-string">&quot;businessId&quot;</span>));<br>    business.setPassword(rs.getString(<span class="hljs-string">&quot;password&quot;</span>));<br>    business.setBusinessName(rs.getString(<span class="hljs-string">&quot;businessName&quot;</span>));<br>    business.setBusinessAddress(rs.getString(<span class="hljs-string">&quot;businessAddress&quot;</span>));<br>    business.setBusinessExplain(rs.getString(<span class="hljs-string">&quot;businessExplain&quot;</span>));<br>    business.setStarPrice(rs.getDouble(<span class="hljs-string">&quot;starPrice&quot;</span>));<br>    business.setDeliveryPrice(rs.getDouble(<span class="hljs-string">&quot;deliveryPrice&quot;</span>));<br>    list.add(business);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码就属于纯 “体力” 型代码。这些代码工作量大、单调枯燥、占用大量开发时间。为了解决这个问题，出现了ORM思想。</p>
<p><strong>ORM（对象-关系映射）：完成对象数据到关系型数据映射的机制称为对象-关系映射。</strong></p>
<h1 id="2、Mybatis框架简介"><a href="#2、Mybatis框架简介" class="headerlink" title="2、Mybatis框架简介"></a>2、Mybatis框架简介</h1><p>Java是一门面向对象的编程语言，而我们从数据库中查到的数据是以二维表的形式存在的，不仅违背了面向对象的思想而且会花费大量时间和精力去完成这部分代码，而Mybatis框架的出现就是为了解决这个问题。</p>
<p>Mybatis在底层封装了JDBC，将查到的数据自动封装到对象中，这样就不仅可以大大减少工作量，而且我们可以将精力主要集中在处理业务逻辑上。</p>
<p>MyBatis 本是apache的一个开源项目iBatis, 2010年这个项目由apache software foundation 迁移到了google code，并且改名为MyBatis 。 也就是说：iBatis3.0之后都要改名为MyBatis 。</p>
<p>MyBatis 是支持普通 SQL查询，存储过程和高级映射的优秀持久层框架。MyBatis 消除了几乎所有的JDBC代码和参数的手工设置以及结果集的检索。MyBatis 使用简单的 XML或注解用于配置和原始映射，将接口和 Java 的POJOs（Plain Old Java Objects，普通的 Java对象）映射成数据库中的记录。</p>
<p>实际上，MyBatis最核心的功能，就是实现了<strong>输入映射和输出映射</strong>。</p>
<h1 id="3、MyBatis实例"><a href="#3、MyBatis实例" class="headerlink" title="3、MyBatis实例"></a>3、MyBatis实例</h1><h2 id="2-1-添加Mybatis依赖"><a href="#2-1-添加Mybatis依赖" class="headerlink" title="2.1.添加Mybatis依赖"></a>2.1.添加Mybatis依赖</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.foreknow<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis_test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>jar<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.16<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--输出日志--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--单元测试--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="2-2-配置log4j"><a href="#2-2-配置log4j" class="headerlink" title="2.2.配置log4j"></a>2.2.配置log4j</h2><p>在resources下创建log4j.properties文件</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">### direct log messages to stdout ###</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.Target</span>=<span class="hljs-string">System.out</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n</span><br><span class="hljs-comment">### direct messages to file mylog.log ###</span><br><span class="hljs-comment">### log4j.appender.file=org.apache.log4j.FileAppender</span><br><span class="hljs-comment">### log4j.appender.file.File=d:mylog.log</span><br><span class="hljs-comment">### log4j.appender.file.layout=org.apache.log4j.PatternLayout</span><br><span class="hljs-comment">### log4j.appender.file.layout.ConversionPattern=%d&#123;yyyy-MM-dd HH:mm:ss&#125; %m%n</span><br><span class="hljs-comment">### set log levels - for more verbose logging change &#x27;debug?info?warn?error&#x27; ###</span><br><span class="hljs-comment">### log4j.rootLogger=debug,stdout,file</span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">debug,stdout</span><br></code></pre></td></tr></table></figure>

<h2 id="2-3-创建MyBatis配置文件"><a href="#2-3-创建MyBatis配置文件" class="headerlink" title="2.3.创建MyBatis配置文件"></a>2.3.创建MyBatis配置文件</h2><p>在 resources 文件夹中创建 SqlMapConfig.xml 配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置数据源相关属性和事务 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 可以配置多个数据源环境，默认使用default中的值 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 使用jdbc的事务管理 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span> /&gt;</span><br>            <span class="hljs-comment">&lt;!-- 配置数据源，并使用自带数据库连接池 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/jdbctest?useSSL=false<span class="hljs-symbol">&amp;amp;</span>allowPublicKeyRetrieval=true<span class="hljs-symbol">&amp;amp;</span>serverTimezone=UTC&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;486934.0&quot;</span> /&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 配置映射文件，可配置多个 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;mapper/studentMapper.xml&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>注意url中的转义字符</strong><code>&amp;amp;</code><strong>和mapper中的属性和属性值</strong></p>
<p>​    ①mapper中resources属性在使用xml配置文件的时候使用，属性值为xml文件的全路径，用“/”隔开</p>
<p>​    ②当属性值为class时，在使用注解的时候使用，属性值为dao接口的全路径，用“.”隔开</p>
<h2 id="2-4-创建po"><a href="#2-4-创建po" class="headerlink" title="2.4.创建po"></a>2.4.创建po</h2><p>在po包中创建student.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.po;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String sex;<br>    <span class="hljs-keyword">private</span> Integer grade;<br>    <span class="hljs-keyword">private</span> String phone;<br> 	<span class="hljs-keyword">private</span> String email;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">set</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>  	......<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong><code>注意：po类属性名必须与数据库表的字段名一致。</code></strong></p>
<h2 id="2-5-创建映射文件"><a href="#2-5-创建映射文件" class="headerlink" title="2.5.创建映射文件"></a>2.5.创建映射文件</h2><p>在resources包下创建一个mapper包，创建一个studentMapper.xml文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.foreknow.dao.UserDao&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getStuById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.foreknow.po.student&quot;</span>&gt;</span><br>        select * from student where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs explain">注意： mapper标签：映射文件的根标签。 mapper标签namespace属性：命名空间，对sql进行分类管理，可防止id重复<br><br>select标签：表示查询。 select标签id属性：此属性要唯一。这个id可称为statement的id。 select标签parameterType属性：sql参数的类型。 select标签resultType属性：sql语句执行后返回的类型,即告知mybatis要封装的类型，实体类的全路径 <br><br>sql语句：<br><br># &#123;&#125;： 表示sql参数，一个占位符。<br><br>当parameterType属性为对象类型时：#&#123;&#125; 中的参数名为对象的属性名。 当parameterType属性为单个值时，参数名可以任意。<br></code></pre></td></tr></table></figure>

<p>从映射文件中可以看到：MyBatis会根据字段名与实体对象中的属性名进行映射，从而实现自动将查询数据注入到实体对象的每一个属性中。这就是输出映射。</p>
<h2 id="2-6-测试"><a href="#2-6-测试" class="headerlink" title="2.6.测试"></a>2.6.测试</h2><p>在test包下的java包下创建com.foreknow.test,<code>注意是一级一级的创建</code>，之后在test包下创建mybatistest类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.test;<br><br><span class="hljs-keyword">import</span> com.foreknow.dao.UserDao;<br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.InputStream;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mybatistest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//1.读取配置文件</span><br>        InputStream in= Resources.getResourceAsStream(<span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>);<br>        <span class="hljs-comment">//2.创建SqlSessionFactory工厂</span><br>        SqlSessionFactoryBuilder builder=<span class="hljs-keyword">new</span> SqlSessionFactoryBuilder();<br>        SqlSessionFactory factory  = builder.build(in);<br>        <span class="hljs-comment">//3.使用工厂生产SqlSession对象</span><br>        SqlSession sqlSession = factory.openSession();<br>        <span class="hljs-comment">//4.使用SqlSession创建Dao接口的代理对象</span><br>        UserDao userDao = sqlSession.getMapper(UserDao.class);<br>        <span class="hljs-comment">//5.使用代理对象执行方向</span><br>        student stu = userDao.getStuById(<span class="hljs-number">1</span>);<br>        System.out.println(stu.toString());<br>        <span class="hljs-comment">//6.释放资源</span><br>        sqlSession.close();<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到已经查到信息了！！！</p>
<p><img src="/2021/10/02/mybatis/%E6%88%AA%E5%9B%BE.png"></p>
<h2 id="2-7-注解的使用"><a href="#2-7-注解的使用" class="headerlink" title="2.7.注解的使用"></a>2.7.注解的使用</h2><p>在dao接口中的方法上方添加注解<code>@Select(&quot; select * from student where id = #&#123;id&#125;&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.dao;<br><br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询学生信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Select(&quot; select * from student where id = #&#123;id&#125;&quot;)</span><br>    <span class="hljs-function">student <span class="hljs-title">getStuById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将主配置文件SqlMapConfig.xml中mapper的属性改为class,属性值为dao接口的全路径</p>
<p><img src="/2021/10/02/mybatis/%E6%88%AA%E5%9B%BE3.png"></p>
<p>可以看到结果和之前的一样</p>
<p><img src="/2021/10/02/mybatis/%E6%88%AA%E5%9B%BE1.png"></p>
<p>使用xml配置的方式不仅需要设置namespace,还需要设置id,parameterType,resultType，如果都配置对了还好，如果这几个地方有一个地方写错了那还得慢慢找错误….费时费力。相比较之下使用注解的方式显然更加简单便捷，但是这种方式也只适用于简单的查询         </p>
<h1 id="3-MyBatis核心接口和类"><a href="#3-MyBatis核心接口和类" class="headerlink" title="3.MyBatis核心接口和类"></a>3.MyBatis核心接口和类</h1><ol>
<li><p>SqlSessionFactoryBuilder负责构建SqlSessionFactory，并且提供了多个build()方法的重载。也就是说：此对象可以从xml配置文件，或从Configuration对象来构建SqlSessionFactory。</p>
</li>
<li><p>SqlSessionFactory就是创建SqlSession实例的工厂。通过openSession方法来获取SqlSession对象。而且，SqlSessionFactory一旦被创建，那么在整个应用程序期间都存在。</p>
</li>
<li><p>SqlSession是一个面向程序员的接口，它提供了面向数据库执行sql命令所需的所有方法。SqlSession对应一次数据库会话，它是线程不安全的。</p>
</li>
</ol>
<h1 id="4-封装持久层"><a href="#4-封装持久层" class="headerlink" title="4.封装持久层"></a>4.封装持久层</h1><h2 id="4-1-原始dao方式"><a href="#4-1-原始dao方式" class="headerlink" title="4.1.原始dao方式"></a>4.1.原始dao方式</h2><p>按照JDBC课程中封装dao层的方式，我们可以先封装一个 Util 工具类，在此工具类中封装一个获取SqlSessionFactory的方法。然后创建dao接口和实现类。</p>
<p>SqlSessionFactory工具类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.util;<br><span class="hljs-keyword">import</span> org.apache.ibatis.io.Resources;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactoryBuilder;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.io.Reader;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">sqlSessionFactoryUtil</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSessionFactory factory=<span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String  resource = <span class="hljs-string">&quot;SqlMapConfig.xml&quot;</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSessionFactory <span class="hljs-title">getSqlSessionFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (factory == <span class="hljs-keyword">null</span>) &#123;<br>            Reader reader = Resources.getResourceAsReader(resource);<br>            factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(reader);<br>        &#125;<br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>dao接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.dao;<br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有学生</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;student&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>dao实现:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.dao.DaoImpl;<br><br><span class="hljs-keyword">import</span> com.foreknow.dao.UserDao;<br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> com.foreknow.util.sqlSessionFactoryUtil;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;student&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>        SqlSession sqlSession = factory.openSession();<br>        List&lt;student&gt; list = sqlSession.selectList(<span class="hljs-string">&quot;stu.getAll&quot;</span>);<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>测试:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.test;<br><br><span class="hljs-keyword">import</span> com.foreknow.dao.DaoImpl.UserDaoImpl;<br><span class="hljs-keyword">import</span> com.foreknow.dao.UserDao;<br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mybatistest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        UserDao userDao=<span class="hljs-keyword">new</span> UserDaoImpl();<br>        List&lt;student&gt; list = userDao.getAll();<br>        <span class="hljs-keyword">for</span> (student s : list) &#123;<br>            System.out.println(s.toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li><p>从上面代码中可以发现，使用原始dao方式存在很多问题：</p>
<ol>
<li><p>dao实现类中存在大量重复代码</p>
</li>
<li><p>调用sqlSession方法时，将statement的id硬编码了</p>
<p>3.调用sqlSession方法时传入的参数，由于sqlSession使用了泛型，所以即使传入参数的数据类型错误，在编译阶段也不会报错。</p>
</li>
</ol>
</li>
</ol>
<h2 id="4-2-mapper代理"><a href="#4-2-mapper代理" class="headerlink" title="4.2.mapper代理"></a>4.2.mapper代理</h2><p>程序员只需要mapper接口和mapper.xml映射文件，Mybatis可以自动生成mapper接口实现类代理对象。程序员编写mapper接口需要遵循一些开发规范。</p>
<p>mapper代理方式开发规范：</p>
<ol>
<li><p>映射文件中的 namespace 必须是 mapper 接口的地址。</p>
</li>
<li><p>映射文件中 statement 的 id 必须与 mapper 接口中的方法名一致。</p>
<p>3.映射文件中 parameterType 必须与 mapper 接口中的方法参数类型一致。</p>
<p>4.映射文件中 resultType 必须与 mapper 接口中的返回值类型一致。（实际上，代理对象就是根据返回值类型来判断是使用selectOne方法还是selectList方法）</p>
</li>
</ol>
<h3 id="4-2-1-创建mapper接口"><a href="#4-2-1-创建mapper接口" class="headerlink" title="4.2.1.创建mapper接口"></a>4.2.1.创建mapper接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.dao;<br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> org.apache.ibatis.annotations.Select;<br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询所有学生</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">List&lt;student&gt; <span class="hljs-title">getAll</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据id查询学生信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">student <span class="hljs-title">getStuById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-2-创建mapper映射文件"><a href="#4-2-2-创建mapper映射文件" class="headerlink" title="4.2.2.创建mapper映射文件"></a>4.2.2.创建mapper映射文件</h3><blockquote>
<p>注意：mapper接口与映射文件最好在同一个文件夹内，并且接口名与映射文件名要一致</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;!DOCTYPE mapper PUBLIC <span class="hljs-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br>        <span class="hljs-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;<br>&lt;mapper namespace=<span class="hljs-string">&quot;com.foreknow.mapper.studentMapper&quot;</span>&gt;<br>    &lt;select id=<span class="hljs-string">&quot;getStuById&quot;</span> parameterType=<span class="hljs-string">&quot;int&quot;</span> resultType=<span class="hljs-string">&quot;com.foreknow.po.student&quot;</span>&gt;<br>        select * from student where id = #&#123;id&#125;<br>    &lt;/select&gt;<br>    &lt;select id=<span class="hljs-string">&quot;getAll&quot;</span> resultType=<span class="hljs-string">&quot;com.foreknow.po.student&quot;</span>&gt;<br>        select * from student<br>    &lt;/select&gt;<br>&lt;/mapper&gt;<br></code></pre></td></tr></table></figure>

<h3 id="4-2-3-注册mapper映射文件"><a href="#4-2-3-注册mapper映射文件" class="headerlink" title="4.2.3.注册mapper映射文件"></a>4.2.3.注册mapper映射文件</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;com/foreknow/mapper/studentMapper.xml&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-2-4-获取代理对象测试"><a href="#4-2-4-获取代理对象测试" class="headerlink" title="4.2.4.获取代理对象测试"></a>4.2.4.获取代理对象测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.foreknow.test;<br><br><span class="hljs-keyword">import</span> com.foreknow.mapper.studentMapper;<br><span class="hljs-keyword">import</span> com.foreknow.po.student;<br><span class="hljs-keyword">import</span> com.foreknow.util.sqlSessionFactoryUtil;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSession;<br><span class="hljs-keyword">import</span> org.apache.ibatis.session.SqlSessionFactory;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mybatistest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>        SqlSession sqlSession = factory.openSession();<br>        studentMapper userDao = sqlSession.getMapper(studentMapper.class);<br>        student stu1 = userDao.getStuById(<span class="hljs-number">1</span>);<br>        List&lt;student&gt; all = userDao.getAll();<br>        System.out.println(stu1.toString());<br>        System.out.println(<span class="hljs-string">&quot;-------------------分割线-------------------&quot;</span>);<br>        <span class="hljs-keyword">for</span> (student s:<br>             all) &#123;<br>            System.out.println(s.toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>**<code>注意：</code>**编译时提示错误 <code>Error parsing SQL Mapper Configuration. Cause: java.io.IOException: Could not find resource com/shao/mapping/userMapper.xml</code></p>
<p>即找不到userMapper.xml这个Mapper文件，仔细查看了目录设置，并没有错误，在网上找了半天，终于发现原因：</p>
<p>idea不会编译src的java目录的xml文件</p>
<p>所以解决思路就是：将IDEA maven项目中src源代码下的xml等资源文件编译进classes文件夹</p>
<p>具体操作方法就是：配置maven的pom文件配置，在节点下添加代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.xml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="5-MyBatis配置的优化"><a href="#5-MyBatis配置的优化" class="headerlink" title="5.MyBatis配置的优化"></a>5.MyBatis配置的优化</h1><h2 id="5-1-批量加载映射文件"><a href="#5-1-批量加载映射文件" class="headerlink" title="5.1.批量加载映射文件"></a>5.1.批量加载映射文件</h2><p>如果映射文件与mapper接口名称一致，且处在同一个文件夹内，那么就可以使用接口来批量加载映射文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;mappers&gt;<br>   &lt;package name=&quot;com.foreknow.mapper&quot;/&gt;<br>&lt;/mappers&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>自动加载com.foreknow.mapper包下，所有与接口名称一致的映射文件。（package标签可写多个）</p>
</blockquote>
<h2 id="5-2-批量定义类别名"><a href="#5-2-批量定义类别名" class="headerlink" title="5.2.批量定义类别名"></a>5.2.批量定义类别名</h2><p>在MyBatis中的配置文件中， parameterType和resultType都需要指定自定义类的全路径。类的全路径一般都很长，所以需要进行优化。也就是给类定义别名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;typeAliases&gt;<br>        &lt;package name=&quot;com.foreknow.po&quot;/&gt;<br>&lt;/typeAliases&gt;<br></code></pre></td></tr></table></figure>

<p>自动扫描指定包中的类，并自动为这些类定义别名。定义的别名就是类名，而且首字母大写小写均可。</p>
<p><strong><code>注意：typeAliases标签必须放在environments前面</code></strong></p>
<h2 id="5-3-数据库配置优化"><a href="#5-3-数据库配置优化" class="headerlink" title="5.3.数据库配置优化"></a>5.3.数据库配置优化</h2><p>创建db.properties数据库配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">jdbc.driver=com.mysql.cj.jdbc.Driver<br>jdbc.url=jdbc:mysql://localhost:3306/jdbctest?useSSL=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=UTC<br>jdbc.username=root<br>jdbc.password=486934.0<br></code></pre></td></tr></table></figure>

<p>在MyBatis配置文件中使用db.properties数据库配置文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><code class="hljs plain">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;<br>&lt;!DOCTYPE configuration<br>        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;<br>        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;<br>&lt;configuration&gt;<br>    &lt;!--加载数据库配置文件--&gt;<br>    &lt;properties resource=&quot;db.properties&quot;&gt;&lt;/properties&gt;<br>    &lt;!--定义类别名--&gt;<br>    &lt;typeAliases&gt;<br>        &lt;package name=&quot;com.foreknow.po&quot;/&gt;<br>    &lt;/typeAliases&gt;<br>    &lt;environments default=&quot;development&quot;&gt;<br>        &lt;!-- 可以配置多个数据源环境，默认使用default中的值 --&gt;<br>        &lt;environment id=&quot;development&quot;&gt;<br>            &lt;!-- 使用jdbc的事务管理 --&gt;<br>            &lt;transactionManager type=&quot;JDBC&quot; /&gt;<br>            &lt;!-- 配置数据源，并使用自带数据库连接池 --&gt;<br>            &lt;dataSource type=&quot;POOLED&quot;&gt;<br>                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot; /&gt;<br>                &lt;property name=&quot;url&quot;<br>                          value=&quot;$&#123;jdbc.url&#125;&quot; /&gt;<br>                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot; /&gt;<br>                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot; /&gt;<br>            &lt;/dataSource&gt;<br>        &lt;/environment&gt;<br>    &lt;/environments&gt;<br>    &lt;!-- 配置映射文件，可配置多个 --&gt;<br>    &lt;mappers&gt;<br>        &lt;package name=&quot;com.foreknow.mapper&quot;/&gt;<br>    &lt;/mappers&gt;<br><br>&lt;/configuration&gt;<br><br></code></pre></td></tr></table></figure>

<p>将有关数据库的配置分离出去，有利于分类管理。</p>
<h1 id="6-常用数据库操作"><a href="#6-常用数据库操作" class="headerlink" title="6.常用数据库操作"></a>6.常用数据库操作</h1><h2 id="6-1-多条件查询"><a href="#6-1-多条件查询" class="headerlink" title="6.1.多条件查询"></a>6.1.多条件查询</h2><p>查询食品表中<code>价格小于20</code>的<code>水饺</code>，<code>&amp;lt;</code>是“&lt;”的转义字符</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listFood&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;food&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;food&quot;</span>&gt;</span><br>    select * from food where foodName <br>    like concat(&#x27;%&#x27;,#&#123;foodName&#125;,&#x27;%&#x27;) and foodPrice <span class="hljs-symbol">&amp;lt;</span>20<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">food food=<span class="hljs-keyword">new</span> food();<br>food.setFoodName(<span class="hljs-string">&quot;水饺&quot;</span>);<br>List&lt;food&gt; list = mapper.listFood(food);<br><span class="hljs-keyword">for</span> (food f:<br>     list) &#123;<br>    System.out.println(f.toString());<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>parameterType只有一个。所以，有多个参数时使用对象传值（这就是<strong>输入映射</strong>）。</li>
<li>{} 中书写的是实体对象的属性名，所以要严格区分大小写。</li>
</ol>
</blockquote>
<h2 id="6-2-转义字符查询"><a href="#6-2-转义字符查询" class="headerlink" title="6.2.转义字符查询"></a>6.2.转义字符查询</h2><p>由于 &lt;（小于号）是标签关键词，因此不能识别小于号。所以MyBatis中设计了一些转义字符，来代替一些特殊字符：</p>
<p><img src="/2021/10/02/mybatis/1604979265608-5de92cc1-0a4d-4bf6-b4e7-2dbe34093b57.png"></p>
<h2 id="6-3-返回单值查询"><a href="#6-3-返回单值查询" class="headerlink" title="6.3.返回单值查询"></a>6.3.返回单值查询</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getAllFoodQuantity&quot;</span>  <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    select count(*) from food<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>SqlSession sqlSession = factory.openSession();<br>foodMapper mapper = sqlSession.getMapper(foodMapper.class);<br>Integer quantity = mapper.getAllFoodQuantity();<br>System.out.println(quantity);<br></code></pre></td></tr></table></figure>

<p><code>注意：只有返回单值（一行一列），resultType才能使用基本数据类型</code></p>
<h2 id="6-4-插入（不获取主键）"><a href="#6-4-插入（不获取主键）" class="headerlink" title="6.4.插入（不获取主键）"></a>6.4.插入（不获取主键）</h2><p>向用户表中插入一条数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span> &gt;</span><br> insert into user(userId,password,userName,userSex,userImg,delTag)<br> values (#&#123;userId&#125;,#&#123;password&#125;,#&#123;userName&#125;,#&#123;userSex&#125;,#&#123;userImg&#125;,#&#123;delTag&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>SqlSession sqlSession = factory.openSession();<br>userMapper mapper = sqlSession.getMapper(userMapper.class);<br>user user1=<span class="hljs-keyword">new</span> user();<br>user1.setDelTag(<span class="hljs-number">1</span>);<br>user1.setUserImg(<span class="hljs-string">&quot;Img&quot;</span>);<br>user1.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br>user1.setUserName(<span class="hljs-string">&quot;tom&quot;</span>);<br>user1.setUserSex(<span class="hljs-number">1</span>);<br>user1.setUserId(<span class="hljs-string">&quot;root&quot;</span>);<br><span class="hljs-keyword">int</span> i = mapper.saveUser(user1);<br>sqlSession.commit();<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<p><code>**注意：增删改都会返回int值，表示影响的行数。但是，insert标签中不能书写resultType属性**</code></p>
<h2 id="6-5-插入（获取主键）"><a href="#6-5-插入（获取主键）" class="headerlink" title="6.5.插入（获取主键）"></a>6.5.插入（获取主键）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;AFTER&quot;</span>&gt;</span><br>        select LAST_INSERT_ID()<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    insert into orders(userId,businessId,orderDate,orderTotal,daId,orderState)<br>    values (#&#123;userId&#125;,#&#123;businessId&#125;,#&#123;orderDate&#125;,#&#123;orderTotal&#125;,#&#123;daId&#125;,#&#123;orderState&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>SqlSession sqlSession = factory.openSession();<br>orderMapper mapper = sqlSession.getMapper(orderMapper.class);<br>orders orders =<span class="hljs-keyword">new</span> orders();<br>orders.setOrderTotal(<span class="hljs-number">20d</span>);<br>orders.setBusinessId(<span class="hljs-number">10001</span>);<br>orders.setDaId(<span class="hljs-number">1</span>);<br>Date date=<span class="hljs-keyword">new</span> Date();<br>SimpleDateFormat sdf=<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String orderDate = sdf.format(date);<br>orders.setOrderDate(orderDate);<br>orders.setOrderState(<span class="hljs-number">1</span>);<br>orders.setUserId(<span class="hljs-string">&quot;root&quot;</span>);<br><span class="hljs-keyword">int</span> i = mapper.saveOrder(orders);<br>sqlSession.commit();<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>selectKey标签中的 select LAST_INSERT_ID() 语句就能获取生成的主键</li>
<li>selectKey标签中的keyProperty属性就是主键名，MyBatis会自动将获取的主键封装给此属性。</li>
<li>order的值有两种：BEFORE、AFTER</li>
</ol>
<p>​        BEFORE：先获取主键，然后执行insert； 比如 Oracle数据库。<br>​        AFTER：先执行insert，然后获取主键； 比如 MySql数据库。</p>
</blockquote>
<h2 id="6-6-插入（获取主键）"><a href="#6-6-插入（获取主键）" class="headerlink" title="6.6.插入（获取主键）"></a>6.6.插入（获取主键）</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;orders&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;orderId&quot;</span>&gt;</span><br>    insert into orders(userId,businessId,orderDate,orderTotal,daId,orderState)<br>    values (#&#123;userId&#125;,#&#123;businessId&#125;,#&#123;orderDate&#125;,#&#123;orderTotal&#125;,#&#123;daId&#125;,#&#123;orderState&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>SqlSession sqlSession = factory.openSession();<br>orderMapper mapper = sqlSession.getMapper(orderMapper.class);<br>orders orders =<span class="hljs-keyword">new</span> orders();<br>orders.setOrderTotal(<span class="hljs-number">20d</span>);<br>orders.setBusinessId(<span class="hljs-number">10001</span>);<br>orders.setDaId(<span class="hljs-number">1</span>);<br>Date date=<span class="hljs-keyword">new</span> Date();<br>SimpleDateFormat sdf=<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String orderDate = sdf.format(date);<br>orders.setOrderDate(orderDate);<br>orders.setOrderState(<span class="hljs-number">1</span>);<br>orders.setUserId(<span class="hljs-string">&quot;root&quot;</span>);<br><span class="hljs-keyword">int</span> i = mapper.saveOrder(orders);<br>sqlSession.commit();<br>System.out.println(i);<br>System.out.println(orders.getOrderId()); <span class="hljs-comment">//获取主键</span><br></code></pre></td></tr></table></figure>

<p>useGeneratedKeys设置为true后，mybatis会使用JDBC的getGeneratedkeys方法获取由数据库内部自动生成的主键，并将该值赋值给由keyProperty指定的属性； 注意：此种方式只适合于有自增长列的数据库（mysql、sqlserver等）</p>
<h2 id="6-7-修改"><a href="#6-7-修改" class="headerlink" title="6.7.修改"></a>6.7.修改</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateOrder&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>    update orders set userId=#&#123;userId&#125;,businessId=#&#123;businessId&#125;,<br>    orderDate=#&#123;orderDate&#125;,orderTotal=#&#123;orderTotal&#125;,daId=#&#123;daId&#125;,orderState=#&#123;orderState&#125;<br>    where orderId=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>SqlSession sqlSession = factory.openSession();<br>orderMapper mapper = sqlSession.getMapper(orderMapper.class);<br>orders orders =<span class="hljs-keyword">new</span> orders();<br>orders.setOrderId(<span class="hljs-number">6</span>);<br>orders.setOrderTotal(<span class="hljs-number">250d</span>);<br>orders.setBusinessId(<span class="hljs-number">10001</span>);<br>orders.setDaId(<span class="hljs-number">1</span>);<br>Date date=<span class="hljs-keyword">new</span> Date();<br>SimpleDateFormat sdf=<span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br>String orderDate = sdf.format(date);<br>orders.setOrderDate(orderDate);<br>orders.setOrderState(<span class="hljs-number">1</span>);<br>orders.setUserId(<span class="hljs-string">&quot;wesker&quot;</span>);<br><span class="hljs-keyword">int</span> i = mapper.updateOrder(orders);<br>sqlSession.commit();<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：增删改都会返回int值，表示影响的行数。但是，xml标签中不能书写resultType属性</p>
</blockquote>
<h2 id="6-8-删除"><a href="#6-8-删除" class="headerlink" title="6.8.删除"></a>6.8.删除</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteOrderById&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span>&gt;</span><br>    delete from orders where orderId=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">SqlSessionFactory factory = sqlSessionFactoryUtil.getSqlSessionFactory();<br>SqlSession sqlSession = factory.openSession();<br>orderMapper mapper = sqlSession.getMapper(orderMapper.class);<br><span class="hljs-keyword">int</span> i = mapper.deleteOrderById(<span class="hljs-number">6</span>);<br>sqlSession.commit();<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<h1 id="7-动态sql"><a href="#7-动态sql" class="headerlink" title="7.动态sql"></a>7.动态sql</h1><p>动态sql主要用于解决查询条件不确定的情况。也就是说：在实际开发中，经常需要根据用户是否输入了某个值，来确定是否需要这个条件。 MyBatis中用于动态sql的元素主要有：if、where、trim、set、foreach、choose等</p>
<h2 id="7-1-if-where标签"><a href="#7-1-if-where标签" class="headerlink" title="7.1.if+where标签"></a>7.1.if+where标签</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listFood&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;food&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;food&quot;</span>&gt;</span><br>    select * from food<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;foodPrice != &#x27;&#x27; &quot;</span>&gt;</span><br>                foodPrice <span class="hljs-symbol">&amp;lt;</span>15<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">foodMapper mapper = sqlSession.get<span class="hljs-constructor">Mapper(<span class="hljs-params">foodMapper</span>.<span class="hljs-params">class</span>)</span>;<br>List&lt;food&gt; <span class="hljs-built_in">list</span> = mapper.<span class="hljs-built_in">list</span><span class="hljs-constructor">Food()</span>;<br><span class="hljs-keyword">for</span> (food f :<br>        <span class="hljs-built_in">list</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(f.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>if+where会实现以下功能：</p>
<ol>
<li>自动添加where</li>
<li>不需要考虑where后是否加and，mybatis会自动处理</li>
<li>不需要考虑是否加空格，mybatis会自动处理</li>
<li>没有 else 标签，也没有 else if 标签。</li>
</ol>
<p><code>注意： job!=&#39;&#39; 此处只可以判断是否为空，不能判断是否为某个值。也就是说：job!=&#39;经理&#39; 是不好使的。</code></p>
<h2 id="7-2-choose标签"><a href="#7-2-choose标签" class="headerlink" title="7.2.choose标签"></a>7.2.choose标签</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listFood&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;food&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;food&quot;</span>&gt;</span><br>    select * from food<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;foodPrice != &#x27;&#x27;&quot;</span>&gt;</span><br>                foodPrice <span class="hljs-symbol">&amp;gt;</span>15<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;foodName != &#x27;&#x27;&quot;</span>&gt;</span><br>                foodName like concat(&#x27;%&#x27;,&#x27;水饺&#x27;,&#x27;%&#x27;)   /*没执行*/<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">foodMapper mapper = sqlSession.getMapper(foodMapper.class);<br>List&lt;food&gt; list = mapper.listFood();<br><span class="hljs-keyword">for</span> (food f :<br>        list) &#123;<br>    System.out.println(f.toString());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>choose会实现如下功能：</p>
<ol>
<li>多个 when 标签中，只能执行一个。也就是说：当一个 when 条件满足并执行后，其它的 when 将不再执行。</li>
<li>当所有 when 都不满足条件时，执行 otherwise 标签。</li>
</ol>
<p><code>if 与 choose 的区别：if 相当于java中的if语句； choose相当于java中的switch语句。</code></p>
<h2 id="7-3-trim标签"><a href="#7-3-trim标签" class="headerlink" title="7.3.trim标签"></a>7.3.trim标签</h2><p>trim标签可以在自己包含的内容中加上某些前缀或后缀，与之对应的属性是：prefix、suffix。 还可以把包含内容的开始内容覆盖，即忽略。也可以把结束的某些内容覆盖，对应的属性是：prefixOverrides、suffixOverrides</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;saveUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;user&quot;</span> &gt;</span><br> insert into user<br> <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>     userId,password,<br>     <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userName !=null and userName !=&#x27;&#x27; &quot;</span>&gt;</span><br>         userName,<br>     <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>     userSex,userImg,delTag,<br> <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;values (&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;)&quot;</span>&gt;</span><br>      #&#123;userId&#125;,#&#123;password&#125;,#&#123;userName&#125;,#&#123;userSex&#125;,<br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userImg!=null and userImg!=&#x27;&#x27; &quot;</span>&gt;</span><br>          #&#123;userImg&#125;,<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;delTag!=null and delTag!=&#x27;&#x27; &quot;</span>&gt;</span><br>          #&#123;delTag&#125;<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">user user=<span class="hljs-keyword">new</span> user();<br>user.setUserId(<span class="hljs-string">&quot;10010&quot;</span>);<br>user.setUserSex(<span class="hljs-number">1</span>);<br>user.setUserName(<span class="hljs-string">&quot;cindy&quot;</span>);<br>user.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>user.setDelTag(<span class="hljs-number">1</span>);<br>user.setUserImg(<span class="hljs-string">&quot;Img&quot;</span>);<br><span class="hljs-keyword">int</span> i = mapper.saveUser(user);<br>sqlSession.commit();<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>prefix与suffix可以在sql语句中拼接出一对小括号。</li>
<li>suffixOberrides可以将最后一个逗号去掉。</li>
</ol>
</blockquote>
<h2 id="7-4-set标签"><a href="#7-4-set标签" class="headerlink" title="7.4.set标签"></a>7.4.set标签</h2><p>set标签主要用于更新操作时使用</p>
<p>根据userId修改用户密码:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUserPasswordByUserId&quot;</span>&gt;</span><br>    update  user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password !=null and password !=&#x27;&#x27; &quot;</span>&gt;</span><br>            password=#&#123;password&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;userId !=null and userId !=&#x27;&#x27; &quot;</span>&gt;</span><br>            userId=#&#123;userId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">update <span class="hljs-built_in"> user </span><span class="hljs-builtin-name">set</span>( <span class="hljs-attribute">password</span>=#&#123;password&#125;) where <span class="hljs-attribute">userId</span>=#&#123;userId&#125;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">user</span> <span class="hljs-keyword">user</span>=<span class="hljs-built_in">new</span> <span class="hljs-keyword">user</span>();<br><span class="hljs-keyword">user</span>.setUserId(&quot;root&quot;);<br><span class="hljs-keyword">user</span>.setPassword(&quot;456&quot;);<br><span class="hljs-type">int</span> i = mapper.updateUserPasswordByUserId(<span class="hljs-keyword">user</span>);<br>sqlSession.<span class="hljs-keyword">commit</span>();<br><span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(i);<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>set可以在sql语句中自动加上set关键词。</li>
<li>可以自动将最后的逗号去掉。</li>
<li>set标签中，必须要保证有一个if成立</li>
</ol>
<h2 id="7-5-foreach标签"><a href="#7-5-foreach标签" class="headerlink" title="7.5.foreach标签"></a>7.5.foreach标签</h2><p>foreach标签可以在sql中迭代一个集合或数组，主要用于拼接in条件。下面是一个批量删除示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUserByUserId&quot;</span>&gt;</span><br>    delete from user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        userId in<br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;array&quot;</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;(&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>            #&#123;userId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>相当于执行了</p>
<p><code>delete from user WHERE userId in ( ? , ? , ? )</code> </p>
<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String[] arr=&#123;<span class="hljs-string">&quot;10010&quot;</span>,<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-string">&quot;root&quot;</span>&#125;;<br><span class="hljs-keyword">int</span> i = mapper.deleteUserByUserId(arr);<br>sqlSession.commit();<br>System.out.println(i);<br></code></pre></td></tr></table></figure>

<blockquote>
<p>foreach标签的属性：</p>
<ol>
<li>collection：需要遍历的类型，值有：list、array</li>
<li>item：表示遍历出来的对象</li>
<li>open：表示语句的开始部分</li>
<li>close：表示语句的结束部分</li>
<li>separator：表示每次迭代之间以什么符号为间隔</li>
<li>index：每次迭代的位置索引，就是循环变量</li>
</ol>
</blockquote>
<h1 id="8-MyBatis的输入映射和输出映射"><a href="#8-MyBatis的输入映射和输出映射" class="headerlink" title="8.MyBatis的输入映射和输出映射"></a>8.MyBatis的输入映射和输出映射</h1><h2 id="8-1-输入映射总结"><a href="#8-1-输入映射总结" class="headerlink" title="8.1.输入映射总结"></a>8.1.输入映射总结</h2><p>当sql语句需要一个参数时：</p>
<ol>
<li>接口方法参数为一个基本数据类型；parameterType配置一个基本数据类型；</li>
</ol>
<p>当sql语句需要多个参数时：</p>
<ol>
<li>接口方法参数为一个实体对象类型；parameterType配置一个实体对象类型；</li>
<li>接口方法参数为一个集合类型（List、Map）；parameterType配置集合中元素的类型；</li>
</ol>
<p>注意：当sql语句中需要判断一个基本数据类型的值是否为空时：</p>
<ol>
<li>值的类型必须为包装类。</li>
<li>即使是只传一个基本数据类型，也要使用实体对象传值。 因为：如果在parameterType中设置Integer类型，那么Mybatis会自动寻找get方法来获取对象属性值。因此会出现没有get方法异常。</li>
</ol>
<h2 id="8-2-输出映射总结"><a href="#8-2-输出映射总结" class="headerlink" title="8.2.输出映射总结"></a>8.2.输出映射总结</h2><p>当sql语句中的字段名与实体对象中的属性名一致时，使用resultType：</p>
<ol>
<li><p>返回一条记录时，resultType可以配置成对象类型。</p>
</li>
<li><p>返回多条记录时，resultType也要配置成对象类型(表示集合中存储的对象)。</p>
</li>
<li><p>返回一条记录，且只有一列时，resultType可以配置成简单数据类型。</p>
</li>
</ol>
<p>当sql语句中的字段名与实体对象中的属性名不一致时，使用resultMap：</p>
<ol>
<li>在resultMap中，显式的书写sql字段名与实体对象属性名的映射</li>
</ol>
<h2 id="8-3-resultMap的使用"><a href="#8-3-resultMap的使用" class="headerlink" title="8.3.resultMap的使用"></a>8.3.resultMap的使用</h2><p>当sql语句中的字段名与实体对象中的字段名不一致时，可以使用resultMap来显式的进行映射。常用语sql语句中给字段起别名的时候使用</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">&lt;select <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;listFood&quot;</span> parameterType=<span class="hljs-string">&quot;food&quot;</span> resultMap=<span class="hljs-string">&quot;foodMap&quot;</span>&gt;<br>    select foodId <span class="hljs-built_in">id</span>,<br>    foodName <span class="hljs-built_in">name</span>,<br>    foodExplain fexplain,<br>    foodPrice price,<br>    businessId bId,<br>    remarks<br>    <span class="hljs-keyword">from</span>  food<br>&lt;/select&gt;<br>&lt;resultMap <span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;foodMap&quot;</span> type=<span class="hljs-string">&quot;food&quot;</span>&gt;<br>    &lt;<span class="hljs-built_in">id</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;foodId&quot;</span> column=<span class="hljs-string">&quot;id&quot;</span>&gt;&lt;/<span class="hljs-built_in">id</span>&gt;<br>    &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;foodName&quot;</span> column=<span class="hljs-string">&quot;name&quot;</span>/&gt;<br>    &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;foodExplain&quot;</span> column=<span class="hljs-string">&quot;explain&quot;</span>/&gt;<br>    &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;foodPrice&quot;</span> column=<span class="hljs-string">&quot;price&quot;</span>/&gt;<br>    &lt;<span class="hljs-literal">result</span> <span class="hljs-keyword">property</span>=<span class="hljs-string">&quot;businessId&quot;</span> column=<span class="hljs-string">&quot;bId&quot;</span>/&gt;<br>&lt;/resultMap&gt;<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;food&gt; list = mapper.listFood();<br><span class="hljs-keyword">for</span> (food f : list) &#123;<br>    System.out.println(f.toString());<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>resultMap标签中的 id 属性：是此resultMap的唯一标识。</li>
<li>resultMap标签中的 type 属性：是此resultMap 映射的实体对象。</li>
<li>resultMap标签中的子标签id，用来配置主键的映射；子标签 result 用来配置其它字段的映射。</li>
<li>子标签id 和子标签 result 中的 property 属性，对应实体类中的属性，column 属性对应sql语句中的字段。</li>
</ol>
</blockquote>
<h1 id="9-MyBatis关联查询"><a href="#9-MyBatis关联查询" class="headerlink" title="9.MyBatis关联查询"></a>9.MyBatis关联查询</h1><h2 id="9-1-多表连接形式"><a href="#9-1-多表连接形式" class="headerlink" title="9.1.多表连接形式"></a>9.1.多表连接形式</h2><h3 id="9-1-1-多对一关联查询"><a href="#9-1-1-多对一关联查询" class="headerlink" title="9.1.1.多对一关联查询"></a>9.1.1.多对一关联查询</h3><h4 id="9-1-1-1-修改实体类"><a href="#9-1-1-1-修改实体类" class="headerlink" title="9.1.1.1.修改实体类"></a>9.1.1.1.修改实体类</h4><figure class="highlight lasso"><table><tr><td class="code"><pre><code class="hljs lasso"><span class="hljs-keyword">public</span> class orderdetailet &#123; <span class="hljs-comment">//订单明细   many</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> odId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> orderId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> foodId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">Integer</span> quantity;<br>    <span class="hljs-keyword">private</span> orders <span class="hljs-keyword">order</span>;   <span class="hljs-comment">//订单类  one</span><br><br>    <span class="hljs-keyword">public</span> orders getOrder() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">order</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-literal">void</span> setOrder(orders <span class="hljs-keyword">order</span>) &#123;<br>        this.<span class="hljs-keyword">order</span> = <span class="hljs-keyword">order</span>;<br>    &#125;<br>    <span class="hljs-params">...</span><br>   &#125;<br></code></pre></td></tr></table></figure>

<p><code>订单明细是多的一方，订单是一的一方，在多的一方的实体类当中添加一的属性，这就实现了实体类之间多对一的关联。</code></p>
<h4 id="9-1-1-2-使用resultMap映射关联"><a href="#9-1-1-2-使用resultMap映射关联" class="headerlink" title="9.1.1.2.使用resultMap映射关联"></a>9.1.1.2.使用resultMap映射关联</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listorderdetailetMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;orderdetailet&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;odId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;oI&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;oId&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;fId&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;quantity&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;oq&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;order&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orderId&quot;</span>/&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;userId&quot;</span>/&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;businessId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;businessId&quot;</span>/&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderDate&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orderDate&quot;</span>/&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderTotal&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orderTotal&quot;</span>/&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;daId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;daId&quot;</span>/&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderState&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orderState&quot;</span>/&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listorderdetailet&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;listorderdetailetMap&quot;</span>&gt;</span><br>    select o.*,<br>    od.odId oI,<br>    od.orderId oId,<br>    od.foodId fId,<br>    od.quantity oq<br>    from orders o<br>    left join orderdetailet od on od.orderId=o.orderId<br>    where od.odId=#&#123;odId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">orderdetailet od=<span class="hljs-keyword">new</span> orderdetailet();<br>od.setOdId(<span class="hljs-number">1</span>);<br>orderdetailet listorderdetailet = mapper.listorderdetailet(od);<br>orders order = listorderdetailet.getOrder();<br>System.out.println(listorderdetailet.toString()+<span class="hljs-string">&quot;---&quot;</span>+order.toString());<br></code></pre></td></tr></table></figure>

<blockquote>
<p>association表示配置单个对象的关联映射 ：</p>
<ol>
<li>association标签中的property：many的一方的实体类中，添加的属性名。</li>
<li>association标签中的javaType：many的一方的实体类中，添加的属性类型。</li>
<li>id标签和result标签中的property：one的一方的实体类中的属性名。</li>
<li>id标签和result标签中的column：one的一方的，查询出来的字段名。</li>
</ol>
</blockquote>
<h3 id="9-1-2-一对多关联查询"><a href="#9-1-2-一对多关联查询" class="headerlink" title="9.1.2.一对多关联查询"></a>9.1.2.一对多关联查询</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">business</span> </span>&#123;   <span class="hljs-comment">//商家    one</span><br>    <span class="hljs-keyword">private</span> Integer businessId;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> businessName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> businessAddress;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> businessExplain;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> businessImg;<br>    <span class="hljs-keyword">private</span> Integer orderTypeId;<br>    <span class="hljs-keyword">private</span> Double starPrice;<br>    <span class="hljs-keyword">private</span> Double deliveryPrice;<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">String</span> remarks;<br>    List&lt;food&gt; foodList;   	<span class="hljs-comment">//食品   many</span><br><br>    <span class="hljs-keyword">public</span> List&lt;food&gt; <span class="hljs-function"><span class="hljs-title">getFoodList</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> foodList;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">setFoodList</span>(<span class="hljs-params">List&lt;food&gt; foodList</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.foodList = foodList;<br>    &#125;<br>    ...<br>    &#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>business是one的一方，food是many的一方； 在one的一方添加many的一方的集合，这就配置了实体类之间的一对多关联。</p>
</blockquote>
<h4 id="9-1-2-2-使用resultMap映射关联"><a href="#9-1-2-2-使用resultMap映射关联" class="headerlink" title="9.1.2.2.使用resultMap映射关联"></a>9.1.2.2.使用resultMap映射关联</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.foreknow.mapper.businessMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;foodResultMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;business&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;businessId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;bI&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;businessName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;bN&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodList&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;food&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;fI&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;fN&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodExplain&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;fE&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodPrice&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;fP&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getFoodByBusinessId&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;business&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;foodResultMap&quot;</span>&gt;</span><br>        select<br>        b.businessName bN ,<br>        b.businessId bI ,<br>        f.foodId fI ,<br>        f.foodName fN ,<br>        f.foodExplain fE ,<br>        f.foodPrice fP<br>        from business b<br>        join food f on b.businessId=f.businessId<br>        where b.businessId=#&#123;businessId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">business b=<span class="hljs-keyword">new</span> business<span class="hljs-literal">()</span>;<br>b.set<span class="hljs-constructor">BusinessId(10001)</span>;<br>business bs = mapper.get<span class="hljs-constructor">FoodByBusinessId(<span class="hljs-params">b</span>)</span>;<br>List&lt;food&gt; foodList = bs.get<span class="hljs-constructor">FoodList()</span>;<br><span class="hljs-keyword">for</span> (food f : foodList) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(b.get<span class="hljs-constructor">BusinessName()</span>+<span class="hljs-string">&quot;---&quot;</span>+f.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>collection表示配置多个对象的集合的关联映射 ：</p>
<ol>
<li>collection标签中的property：one的一方的实体类中，添加的集合属性名。</li>
<li>collection标签中的ofType：one的一方的实体类中，添加的集合中的元素类型。</li>
<li>id标签和result标签中的property：many的一方的实体类中的属性名。</li>
<li>id标签和result标签中的column： many的一方的，查询出来的字段名。</li>
</ol>
</blockquote>
<h2 id="9-2-单独查询形式"><a href="#9-2-单独查询形式" class="headerlink" title="9.2.单独查询形式"></a>9.2.单独查询形式</h2><h3 id="9-2-1-多对一关联查询"><a href="#9-2-1-多对一关联查询" class="headerlink" title="9.2.1.多对一关联查询"></a>9.2.1.多对一关联查询</h3><h4 id="9-2-1-1-先在one的一方添加关联查询"><a href="#9-2-1-1-先在one的一方添加关联查询" class="headerlink" title="9.2.1.1.先在one的一方添加关联查询"></a>9.2.1.1.先在one的一方添加关联查询</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getbusinessLazy&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;business&quot;</span>&gt;</span><br>    select * from business where businessId=#&#123;businessId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>注意：此查询可以不在接口中书写响应的方法</code></p>
<h4 id="9-2-1-2-many的一方添加查询"><a href="#9-2-1-2-many的一方添加查询" class="headerlink" title="9.2.1.2.many的一方添加查询"></a>9.2.1.2.many的一方添加查询</h4><figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listFoodById&quot;</span>  <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;listFoodMap&quot;</span>&gt;</span></span><br><span class="xml">        select * from food where foodId=#</span><span class="hljs-template-variable">&#123;foodId&#125;</span><span class="xml"></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span></span><br><span class="xml">    </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;listFoodMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;food&quot;</span>&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;foodId&quot;</span>/&gt;</span>                 <span class="hljs-comment">&lt;!--可以省略--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;foodName&quot;</span>/&gt;</span>         <span class="hljs-comment">&lt;!--可以省略--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodExplain&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;foodExplain&quot;</span>/&gt;</span>   <span class="hljs-comment">&lt;!--可以省略--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;foodPrice&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;foodPrice&quot;</span>/&gt;</span>       <span class="hljs-comment">&lt;!--可以省略--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;businessId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;businessId&quot;</span>/&gt;</span>     <span class="hljs-comment">&lt;!--可以省略--&gt;</span></span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;business&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;businessId&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                     <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;business&quot;</span></span></span><br><span class="hljs-tag"><span class="xml">                  <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.foreknow.mapper.businessMapper.getbusinessLazy&quot;</span>/&gt;</span></span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h4 id="9-2-1-3-测试"><a href="#9-2-1-3-测试" class="headerlink" title="9.2.1.3.测试"></a>9.2.1.3.测试</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">food f= mapper.listFoodById(<span class="hljs-number">1</span>);<br>business business = f.getBusiness();<br>System.out.println(<span class="hljs-string">&quot;食品信息：&quot;</span>+f.toString());<br>System.out.println(<span class="hljs-string">&quot;所属商家信息：&quot;</span>+business.toString());<br></code></pre></td></tr></table></figure>

<p><code>测试时，可以在日志中看到，执行了两次sql语句。</code></p>
<p><img src="/2021/10/02/mybatis/image-20211006105935349.png"></p>
<h3 id="9-2-2-一对多关联查询"><a href="#9-2-2-一对多关联查询" class="headerlink" title="9.2.2.一对多关联查询"></a>9.2.2.一对多关联查询</h3><h4 id="9-2-2-1-先在many的一方添加关联查询"><a href="#9-2-2-1-先在many的一方添加关联查询" class="headerlink" title="9.2.2.1.先在many的一方添加关联查询"></a>9.2.2.1.先在many的一方添加关联查询</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getorderdetailetLazy&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;int&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;orderdetailet&quot;</span>&gt;</span><br>    select * from orderdetailet where orderId=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>注意：此查询可以不在接口中书写响应的方法</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getorderByorderId&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;getorderByorderIdMap&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>      select * from orders where orderId=#&#123;orderId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getorderByorderIdMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;orders&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orderId&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;orderdetailetList&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.foreknow.mapper.orderdetailetMapper.getorderdetailetLazy&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;orderId&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;orderdetailetList&quot;</span></span><br><span class="hljs-tag">    /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="9-2-2-3-测试"><a href="#9-2-2-3-测试" class="headerlink" title="9.2.2.3.测试"></a>9.2.2.3.测试</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">orders o=<span class="hljs-keyword">new</span> orders<span class="hljs-literal">()</span>;<br>o.set<span class="hljs-constructor">OrderId(4)</span>;<br>o= mapper.getorder<span class="hljs-constructor">ByorderId(<span class="hljs-params">o</span>)</span>;<br>List&lt;orderdetailet&gt; <span class="hljs-built_in">list</span> = o.get<span class="hljs-constructor">OrderdetailetList()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;订单信息：&quot;</span>+o.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;订单明细：&quot;</span>);<br><span class="hljs-keyword">for</span> (orderdetailet od : <span class="hljs-built_in">list</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(od.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>测试时，可以在日志中看到，执行了两次sql语句。</code></p>
<p><img src="/2021/10/02/mybatis/image-20211006113122888.png"></p>
<h2 id="9-3-关联映射总结"><a href="#9-3-关联映射总结" class="headerlink" title="9.3.关联映射总结"></a>9.3.关联映射总结</h2><p>使用resultMap实现关联映射时：</p>
<p>1.使用association标签完成多对一或一对一映射。</p>
<ol>
<li><p>a. association标签：将关联查询信息映射到一个po对象中。</p>
</li>
<li><p>b. association标签中的javaType属性：表示该po对象的类型。</p>
</li>
<li><p>c. association标签中的select属性：表示应用哪一个关联查询。</p>
</li>
<li><p>d. association标签中的column属性：表示应用关联查询的条件。</p>
</li>
</ol>
<p>2.使用collection标签完成一对多，多对多映射。</p>
<ol>
<li><p>a. collection标签：将关联查询信息映射到一个list集合中。</p>
</li>
<li><p>b. collection标签的ofType属性：表示该集合中的元素对象的类型。</p>
</li>
<li><p>c. collection标签中的select属性：表示应用哪一个关联查询。</p>
</li>
<li><p>d. collection标签中的column属性：表示应用关联查询的条件。</p>
</li>
</ol>
<h2 id="9-4-关联查询的延迟加载"><a href="#9-4-关联查询的延迟加载" class="headerlink" title="9.4.关联查询的延迟加载"></a>9.4.关联查询的延迟加载</h2><p>延迟加载：执行查询时，关联查询不会立即加载。只有在使用关联数据时才会加载。 优点：按需加载，提高效率。</p>
<p><code>注意： 要使用关联查询的延迟加载，就必须要使用单独查询形式。并且，需要先启用MyBatis的延迟加载配置（需要配置两项）：</code></p>
<ol>
<li>lazyLoadingEnabled：延迟加载的全局开关（默认为false）。</li>
<li>aggressiveLazyLoading：延迟加载整个对象（默认为true； false：对象的每个属性都会延迟加载，即属性按需加载）</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--延迟加载的全局开关（默认为false）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--延迟加载整个对象（默认为true； false：对象的每个属性都会延迟加载，即属性按需加载）--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><code>重新测试上面的关联查询（要测试单独查询形式）： 当不需要使用关联数据时，关联查询将不会执行。</code></p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">orders o=<span class="hljs-keyword">new</span> orders<span class="hljs-literal">()</span>;<br>o.set<span class="hljs-constructor">OrderId(4)</span>;<br>o= mapper.getorder<span class="hljs-constructor">ByorderId(<span class="hljs-params">o</span>)</span>;<br>List&lt;orderdetailet&gt; <span class="hljs-built_in">list</span> = o.get<span class="hljs-constructor">OrderdetailetList()</span>;<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;订单信息：&quot;</span>+o.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(<span class="hljs-string">&quot;订单明细：&quot;</span>);<br><span class="hljs-keyword">for</span> (orderdetailet od : <span class="hljs-built_in">list</span>) &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(od.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="10-使用注解实现MyBatis映射"><a href="#10-使用注解实现MyBatis映射" class="headerlink" title="10.使用注解实现MyBatis映射"></a>10.使用注解实现MyBatis映射</h1><p>MyBatis也支持使用注解来配置映射语句。 主要有四种注解来实现增删改查：@Select、@Insert、@Update、@Delete</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">@Insert(&quot;insert into user(userId,password,userName,userSex,userImg,delTag) &quot; +<br>            &quot;values (#&#123;userId&#125;,#&#123;password&#125;,#&#123;userName&#125;,#&#123;userSex&#125;,&quot; +<br>            &quot;#&#123;userImg&#125;,#&#123;delTag&#125;)&quot;)<br>    int saveUser(user user);<br><br>    @Update(&quot;update user set password=#&#123;password&#125; where userId=#&#123;userId&#125;&quot;)<br>    int updateUserPasswordByUserId(user user);<br><br>    @Delete(&quot;delete from user where userId=#&#123;userId&#125;&quot;)<br>    int deleteUserByUserId(String userId);<br><br>    @Select(&quot;select * from user &quot;)<br>    List<span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span> listAlluser();<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>在映射文件中使用的所有的CRUD操作，都可以使用注解的形式完成。</li>
<li>当使用基于注解的映射器接口时，就不再需要映射配置文件了。</li>
<li>在实际开发中，可以单独使用映射文件，也可以单独使用注解，也可以混合使用。</li>
</ol>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>框架</tag>
        <tag>Java</tag>
        <tag>Mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习</title>
    <url>/2022/06/06/docker%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="1-docker概述"><a href="#1-docker概述" class="headerlink" title="1.docker概述"></a>1.docker概述</h1><p>docker官网：<a href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>docker文档：<a href="https://docs.docker.com/">https://docs.docker.com/</a>     非常详细！！</p>
<p>docker仓库：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>docker为什么会出现？</p>
<h1 id="2-docker的基本组成"><a href="#2-docker的基本组成" class="headerlink" title="2.docker的基本组成"></a>2.docker的基本组成</h1><p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAY3JheW9uLXNoaW4tY2hhbg==,size_20,color_FFFFFF,t_70,g_se,x_16" alt="img"></p>
<p><strong>镜像（image）：</strong></p>
<p>docker镜像就好比是一个模板，可以通过模板来创建容器服务，tomcat镜像==&gt;run===&gt;tomcat01容器（提供服务），通过这个镜像可以创建多个容器，服务或项目就是在容器中来运行</p>
<p><strong>容器（container）:</strong></p>
<p>通过镜像来创建，独立运行一个或是一组应用，可以简单的理解为一个简易的linux系统，</p>
<p>启动，停止，删除基本命令</p>
<p><strong>仓库（repository）：</strong></p>
<p>仓库就是存放镜像的地方</p>
<p>仓库分为私有仓库和公有仓库</p>
<h1 id="3-安装docker"><a href="#3-安装docker" class="headerlink" title="3.安装docker"></a>3.安装docker</h1><blockquote>
<p>环境准备</p>
</blockquote>
<p>1.linux基础</p>
<p>2.centOS</p>
<p>3.xshell</p>
<blockquote>
<p>安装</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">1、卸载旧版本</span><br>yum remove docker \<br>                  docker-client \<br>                  docker-client-latest \<br>                  docker-common \<br>                  docker-latest \<br>                  docker-latest-logrotate \<br>                  docker-logrotate \<br>                  docker-engine<br><span class="hljs-meta">#</span><span class="bash">2、安装工具包</span><br>yum install -y yum-utils<br><span class="hljs-meta">#</span><span class="bash">3、设置镜像仓库</span><br>yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br><span class="hljs-meta">#</span><span class="bash">更新软件包索引</span><br>yum makecache fast<br><span class="hljs-meta">#</span><span class="bash">4、安装docker相关的内容   ce社区版  ee企业版</span><br>yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin<br><span class="hljs-meta">#</span><span class="bash">5、启动docker</span><br>systemctl start docker<br><span class="hljs-meta">#</span><span class="bash">6、查看版本</span><br>docker version   <br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220606185418472-16545155856833.png" alt="image-20220606185418472"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">7、测试hello-world</span><br>docker run hello-world<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220606185747560-16545155969414.png" alt="image-20220606185747560"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">8、查看下载的镜像</span><br>docker images<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220606190052284-16545156056555.png" alt="image-20220606190052284"></p>
<p>卸载docker:</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">yum remove docker-ce docker-ce-<span class="hljs-keyword">cli</span> containerd.io docker-compose-<span class="hljs-keyword">plugin</span><br><br><span class="hljs-keyword">rm</span> -rf /<span class="hljs-keyword">var</span>/lib/docker<br><br><span class="hljs-keyword">rm</span> -rf /<span class="hljs-keyword">var</span>/lib/containerd<br></code></pre></td></tr></table></figure>

<h1 id="4-阿里云镜像加速"><a href="#4-阿里云镜像加速" class="headerlink" title="4.阿里云镜像加速"></a>4.阿里云镜像加速</h1><p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220606204529936.png" alt="image-20220606204529936"></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">mkdir -p <span class="hljs-regexp">/etc/</span>docker<br><br>tee <span class="hljs-regexp">/etc/</span>docker/daemon.json &lt;&lt;-<span class="hljs-string">&#x27;EOF&#x27;</span><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://vn54avlu.mirror.aliyuncs.com&quot;</span>]<br>&#125;<br>EOF<br><br>systemctl daemon-reload<br><br>systemctl restart docker<br></code></pre></td></tr></table></figure>

<h1 id="5-docker的常用命令"><a href="#5-docker的常用命令" class="headerlink" title="5.docker的常用命令"></a>5.docker的常用命令</h1><p>docker命令官方文档：<a href="https://docs.docker.com/engine/reference/run/">https://docs.docker.com/engine/reference/run/</a></p>
<h2 id="5-1-帮助命令"><a href="#5-1-帮助命令" class="headerlink" title="5.1.帮助命令"></a>5.1.帮助命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker version 			#docker的版本信息<br>docker info				#docker的系统信息，包括镜像和容器的数量<br>docker [命令] --help     #帮助<br></code></pre></td></tr></table></figure>

<h2 id="5-2-镜像命令"><a href="#5-2-镜像命令" class="headerlink" title="5.2.镜像命令"></a>5.2.镜像命令</h2><h3 id="docker-images-查看所有镜像"><a href="#docker-images-查看所有镜像" class="headerlink" title="docker images  查看所有镜像"></a>docker images  查看所有镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@Wesker ~]# docker images<br>REPOSITORY    TAG       IMAGE ID       CREATED        SIZE<br>hello-world   latest    feb5d9fea6a5   8 months ago   13.3kB<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">解释</span><br>REPOSITORY  镜像仓库源的名字<br>TAG			镜像的标签<br>IMAGE ID    镜像的ID<br>CREATED     镜像的创建时间<br>SIZE	    镜像的大小<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可选项</span><br>  -a, --all             展示所有镜像，默认隐藏半成品镜像<br>      --digests         显示摘要<br>  -f, --filter filter   根据提供的条件过滤输出<br>      --format string   用go语言输出镜像<br>      --no-trunc        不截断输出<br>  -q, --quiet           仅显示ID<br><br></code></pre></td></tr></table></figure>



<h3 id="docker-search-搜索镜像"><a href="#docker-search-搜索镜像" class="headerlink" title="docker search 搜索镜像"></a>docker search 搜索镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@Wesker ~]# docker search mysql<br>NAME                           DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql                          MySQL is a widely used, open-source relation…   12689     [OK]       <br>mariadb                        MariaDB Server is a high performing open sou…   4870      [OK]       <br>percona                        Percona Server is a fork of the MySQL relati…   579       [OK]       <br>phpmyadmin                     phpMyAdmin - A web interface for MySQL and M…   550       [OK]       <br>bitnami/mysql                  Bitnami MySQL Docker Image                      71         [OK]<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">可选项</span>   <br><span class="hljs-meta">#</span><span class="bash">--filter   根据条件过滤</span><br>docker search filter=3000<br>[root@Wesker ~]# docker search mysql --filter=STARS=3000<br>NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>mysql     MySQL is a widely used, open-source relation…   12689     [OK]       <br>mariadb   MariaDB Server is a high performing open sou…   4870      [OK]<br></code></pre></td></tr></table></figure>

<h3 id="docker-pull-下载镜像"><a href="#docker-pull-下载镜像" class="headerlink" title="docker pull 下载镜像"></a>docker pull 下载镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@Wesker ~]# docker pull mysql<br>Using default tag: latest   #默认最新版<br>latest: Pulling from library/mysql<br>72a69066d2fe: Pull complete 	#分层下载，docker image的核心   联合文件系统<br>93619dbc5b36: Pull complete <br>99da31dd6142: Pull complete <br>626033c43d70: Pull complete <br>37d5d7efb64e: Pull complete <br>ac563158d721: Pull complete <br>d2ba16033dad: Pull complete <br>688ba7d5c01a: Pull complete <br>00e060b6d11d: Pull complete <br>1c04857f594f: Pull complete <br>4d7cfa90e6ea: Pull complete <br>e0431212d27d: Pull complete <br>Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709	#签名<br>Status: Downloaded newer image for mysql:latest<br>docker.io/library/mysql:latest	#真实地址<br><br>docker pull mysql  <br><span class="hljs-meta">#</span><span class="bash">等价于</span>  <br>docker pull docker.io/library/mysql:latest<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">指定版本下载</span><br>[root@Wesker ~]# docker pull mysql:5.7<br>5.7: Pulling from library/mysql<br>72a69066d2fe: Already exists 		#已经存在的不用下载，极大节省内存<br>93619dbc5b36: Already exists <br>99da31dd6142: Already exists <br>626033c43d70: Already exists <br>37d5d7efb64e: Already exists <br>ac563158d721: Already exists <br>d2ba16033dad: Already exists <br>0ceb82207cd7: Pull complete <br>37f2405cae96: Pull complete <br>e2482e017e53: Pull complete <br>70deed891d42: Pull complete <br>Digest: sha256:f2ad209efe9c67104167fc609cca6973c8422939491c9345270175a300419f94<br>Status: Downloaded newer image for mysql:5.7<br>docker.io/library/mysql:5.7<br></code></pre></td></tr></table></figure>

<h3 id="docker-rmi-删除镜像"><a href="#docker-rmi-删除镜像" class="headerlink" title="docker rmi 删除镜像"></a>docker rmi 删除镜像</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@Wesker ~]# docker rmi -f 镜像id   				#删除指定的镜像<br>[root@Wesker ~]# docker rmi -f 镜像id 镜像id 镜像id    #删除多个镜像，空格连接<br>[root@Wesker ~]# docker rmi -f $(docker images -aq)   #删除所有镜像<br></code></pre></td></tr></table></figure>

<h2 id="5-3-容器命令"><a href="#5-3-容器命令" class="headerlink" title="5.3.容器命令"></a>5.3.容器命令</h2><p>==说明==：<strong>要有镜像才能创建容器，以centos为例</strong></p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit">[root<span class="hljs-symbol">@Wesker</span> ~]<span class="hljs-meta"># docker pull centos</span><br></code></pre></td></tr></table></figure>

<p><strong>新建容器并启动</strong></p>
<figure class="highlight tcl"><table><tr><td class="code"><pre><code class="hljs tcl">[root@Wesker ~]# docker run [可选参数] image<br><br><span class="hljs-comment">#参数说明</span><br>--name		容器名称，用来区分容器<br>-d			后台方式运行<br>-it			使用交互方式运行，进入容器查看内容<br>-p			小写p,指定容器端口	<br>	-p ip：主机端口：容器端口<br>	-p 主机端口：容器端口（常用）<br>	-p 容器端口<br>	容器端口<br>-P			大写p，随机指定端口<br><br><span class="hljs-comment">#启动并进入容器</span><br>[root@Wesker ~]# docker run -it centos /bin/bash<br>[root@<span class="hljs-number">69</span>c42de25a7b /]# ls		#查看容器内的centos<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  <span class="hljs-keyword">proc</span><span class="hljs-title">  root</span> <span class="hljs-title"> run</span> <span class="hljs-title"> sbin</span> <span class="hljs-title"> srv</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span><br><br>#退出回到主机<br>[root@c98eb94523bb /]#<span class="hljs-title"> exit</span><br>exit<br>[root@Wesker /]#<span class="hljs-title"> ls</span><br>bin<span class="hljs-title">  boot</span> <span class="hljs-title"> data</span> <span class="hljs-title"> dev</span> <span class="hljs-title"> etc</span> <span class="hljs-title"> home</span> <span class="hljs-title"> lib</span> <span class="hljs-title"> lib64</span> <span class="hljs-title"> lost+found</span> <span class="hljs-title"> media</span> <span class="hljs-title"> mnt</span> <span class="hljs-title"> opt</span> <span class="hljs-title"> proc</span> <span class="hljs-title"> root</span> <span class="hljs-title"> run</span> <span class="hljs-title"> sbin</span> <span class="hljs-title"> srv</span> <span class="hljs-title"> sys</span> <span class="hljs-title"> tmp</span> <span class="hljs-title"> usr</span> <span class="hljs-title"> var</span> <span class="hljs-title"> www</span><br></code></pre></td></tr></table></figure>

<h3 id="docker-ps-列出所有运行的容器"><a href="#docker-ps-列出所有运行的容器" class="headerlink" title="docker ps 列出所有运行的容器"></a>docker ps 列出所有运行的容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@Wesker /]# docker ps		#列出当前正在运行的容器<br>CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES<br>[root@Wesker /]# docker ps -a  	#列出正在运行的容器和历史运行过的容器信息<br>CONTAINER ID   IMAGE          COMMAND       CREATED         STATUS                     PORTS     NAMES<br>c98eb94523bb   centos         &quot;/bin/bash&quot;   3 minutes ago   Exited (0) 3 minutes ago             beautiful_hugle<br>69c42de25a7b   centos         &quot;/bin/bash&quot;   8 minutes ago   Exited (0) 5 minutes ago             sharp_hugle<br>3a7ac66c931b   feb5d9fea6a5   &quot;/hello&quot;      4 hours ago     Exited (0) 4 hours ago               jovial_shamir<br>[root@Wesker /]# docker ps -a -n=1   # -n=表示显示最近的容器<br>CONTAINER ID   IMAGE     COMMAND       CREATED         STATUS                     PORTS     NAMES<br>c98eb94523bb   centos    &quot;/bin/bash&quot;   6 minutes ago   Exited (0) 6 minutes ago             beautiful_hugle<br><br>[root@Wesker /]# docker ps -aq		#只显示编号<br>c98eb94523bb<br>69c42de25a7b<br>3a7ac66c931b<br></code></pre></td></tr></table></figure>

<h3 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">exit    #直接停止并退出<br>Ctrl +p +q #快捷键，容器不停止并退出<br>[root@Wesker /]# docker run -it centos /bin/bash<br>[root@def06b3a11fb /]# [root@Wesker /]# <br>[root@Wesker /]# docker ps		#查看正在运行的容器<br>CONTAINER ID   IMAGE     COMMAND       CREATED              STATUS              PORTS     NAMES<br>def06b3a11fb   centos    &quot;/bin/bash&quot;   About a minute ago   Up About a minute             heuristic_brattain<br></code></pre></td></tr></table></figure>

<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker rm 容器id					#删除指定的容器,不能强制删除正在运行的<br><br>[root@Wesker /]# docker rm c98eb94523bb<br>c98eb94523bb<br>[root@Wesker /]# docker ps -a<br>CONTAINER ID   IMAGE          COMMAND       CREATED          STATUS                      PORTS     NAMES<br>def06b3a11fb   centos         &quot;/bin/bash&quot;   7 minutes ago    Up 7 minutes                          heuristic_brattain<br>69c42de25a7b   centos         &quot;/bin/bash&quot;   25 minutes ago   Exited (0) 22 minutes ago             sharp_hugle<br>3a7ac66c931b   feb5d9fea6a5   &quot;/hello&quot;      4 hours ago      Exited (0) 4 hours ago                jovial_shamir<br><br>docker rm -f $(docker ps -aq)		#删除所有容器<br>docker ps -aq|xargs docker rm		#删除所有容器<br></code></pre></td></tr></table></figure>

<h3 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker start 容器id 		#启动一个容器<br>docker restart 容器id 	#重启一个容器<br>docker stop 容器id		#停止当前正在运行的容器<br>docker kill 容器id		#强制停止容器<br></code></pre></td></tr></table></figure>

<h2 id="5-4-其他常用命令"><a href="#5-4-其他常用命令" class="headerlink" title="5.4.其他常用命令"></a>5.4.其他常用命令</h2><h3 id="后台启动"><a href="#后台启动" class="headerlink" title="后台启动"></a>后台启动</h3><p>docker run -d 镜像名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d centos<br>f4062788bd764880fc8f36d99d60f22b15e61a03aaa169fdb0cc523e5905b8bf<br></code></pre></td></tr></table></figure>

<p><code>docker run -d 后使用docker ps查看发现后台没有运行的容器，这是因为必须要有一个前台进程，docker发现没有应用就会停止</code></p>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><p>docker logs</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">可选项</span><br>Options:<br>      --details        显示提供给日志的其他详细信息 <br>  -f, --follow         跟踪日志输出<br>      --since string   显示自时间戳以来的日志 (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)<br>  -n, --tail string    从日志末尾显示的行数 (default &quot;all&quot;)<br>  -t, --timestamps     显示时间戳<br>      --until string   在时间戳之前显示日志 (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220619133305026.png" alt="image-20220619133305026"></p>
<h3 id="查看容器中的进程信息"><a href="#查看容器中的进程信息" class="headerlink" title="查看容器中的进程信息"></a>查看容器中的进程信息</h3><p>docker top 容器id</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220619133837425.png" alt="image-20220619133837425"></p>
<h3 id="查看容器的元数据"><a href="#查看容器的元数据" class="headerlink" title="查看容器的元数据"></a>查看容器的元数据</h3><p>docker inspect 容器id </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker inspect 6d8d42763a1c<br>[<br>    &#123;<br>        &quot;Id&quot;: &quot;6d8d42763a1c1cfdcf14028a6aa964eae4a33168b73a42c8099d3efccc415e51&quot;,<br>        &quot;Created&quot;: &quot;2022-06-19T05:19:04.6104985Z&quot;,<br>        &quot;Path&quot;: &quot;/bin/bash&quot;,<br>        &quot;Args&quot;: [],<br>        &quot;State&quot;: &#123;<br>            &quot;Status&quot;: &quot;running&quot;,<br>            &quot;Running&quot;: true,<br>            &quot;Paused&quot;: false,<br>            &quot;Restarting&quot;: false,<br>            &quot;OOMKilled&quot;: false,<br>            &quot;Dead&quot;: false,<br>            &quot;Pid&quot;: 15788,<br>            &quot;ExitCode&quot;: 0,<br>            &quot;Error&quot;: &quot;&quot;,<br>            &quot;StartedAt&quot;: &quot;2022-06-19T05:19:05.8744944Z&quot;,<br>            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;<br>        &#125;,<br>        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,<br>        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/6d8d42763a1c1cfdcf14028a6aa964eae4a33168b73a42c8099d3efccc415e51/resolv.conf&quot;,<br>        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/6d8d42763a1c1cfdcf14028a6aa964eae4a33168b73a42c8099d3efccc415e51/hostname&quot;,<br>        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/6d8d42763a1c1cfdcf14028a6aa964eae4a33168b73a42c8099d3efccc415e51/hosts&quot;,<br>        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/6d8d42763a1c1cfdcf14028a6aa964eae4a33168b73a42c8099d3efccc415e51/6d8d42763a1c1cfdcf14028a6aa964eae4a33168b73a42c8099d3efccc415e51-json.log&quot;,<br>        &quot;Name&quot;: &quot;/hopeful_banzai&quot;,<br>        &quot;RestartCount&quot;: 0,<br>        &quot;Driver&quot;: &quot;devicemapper&quot;,<br>        &quot;Platform&quot;: &quot;linux&quot;,<br>        &quot;MountLabel&quot;: &quot;&quot;,<br>        &quot;ProcessLabel&quot;: &quot;&quot;,<br>        &quot;AppArmorProfile&quot;: &quot;&quot;,<br>        &quot;ExecIDs&quot;: null,<br>        &quot;HostConfig&quot;: &#123;<br>            &quot;Binds&quot;: null,<br>            &quot;ContainerIDFile&quot;: &quot;&quot;,<br>            &quot;LogConfig&quot;: &#123;<br>                &quot;Type&quot;: &quot;json-file&quot;,<br>                &quot;Config&quot;: &#123;&#125;<br>            &#125;,<br>            &quot;NetworkMode&quot;: &quot;default&quot;,<br>            &quot;PortBindings&quot;: &#123;&#125;,<br>            &quot;RestartPolicy&quot;: &#123;<br>                &quot;Name&quot;: &quot;no&quot;,<br>                &quot;MaximumRetryCount&quot;: 0<br>            &#125;,<br>            &quot;AutoRemove&quot;: false,<br>            &quot;VolumeDriver&quot;: &quot;&quot;,<br>            &quot;VolumesFrom&quot;: null,<br>            &quot;CapAdd&quot;: null,<br>            &quot;CapDrop&quot;: null,<br>            &quot;CgroupnsMode&quot;: &quot;host&quot;,<br>            &quot;Dns&quot;: [],<br>            &quot;DnsOptions&quot;: [],<br>            &quot;DnsSearch&quot;: [],<br>            &quot;ExtraHosts&quot;: null,<br>            &quot;GroupAdd&quot;: null,<br>            &quot;IpcMode&quot;: &quot;private&quot;,<br>            &quot;Cgroup&quot;: &quot;&quot;,<br>            &quot;Links&quot;: null,<br>            &quot;OomScoreAdj&quot;: 0,<br>            &quot;PidMode&quot;: &quot;&quot;,<br>            &quot;Privileged&quot;: false,<br>            &quot;PublishAllPorts&quot;: false,<br>            &quot;ReadonlyRootfs&quot;: false,<br>            &quot;SecurityOpt&quot;: null,<br>            &quot;UTSMode&quot;: &quot;&quot;,<br>            &quot;UsernsMode&quot;: &quot;&quot;,<br>            &quot;ShmSize&quot;: 67108864,<br>            &quot;Runtime&quot;: &quot;runc&quot;,<br>            &quot;ConsoleSize&quot;: [<br>                0,<br>                0<br>            ],<br>            &quot;Isolation&quot;: &quot;&quot;,<br>            &quot;CpuShares&quot;: 0,<br>            &quot;Memory&quot;: 0,<br>            &quot;NanoCpus&quot;: 0,<br>            &quot;CgroupParent&quot;: &quot;&quot;,<br>            &quot;BlkioWeight&quot;: 0,<br>            &quot;BlkioWeightDevice&quot;: [],<br>            &quot;BlkioDeviceReadBps&quot;: null,<br>            &quot;BlkioDeviceWriteBps&quot;: null,<br>            &quot;BlkioDeviceReadIOps&quot;: null,<br>            &quot;BlkioDeviceWriteIOps&quot;: null,<br>            &quot;CpuPeriod&quot;: 0,<br>            &quot;CpuQuota&quot;: 0,<br>            &quot;CpuRealtimePeriod&quot;: 0,<br>            &quot;CpuRealtimeRuntime&quot;: 0,<br>            &quot;CpusetCpus&quot;: &quot;&quot;,<br>            &quot;CpusetMems&quot;: &quot;&quot;,<br>            &quot;Devices&quot;: [],<br>            &quot;DeviceCgroupRules&quot;: null,<br>            &quot;DeviceRequests&quot;: null,<br>            &quot;KernelMemory&quot;: 0,<br>            &quot;KernelMemoryTCP&quot;: 0,<br>            &quot;MemoryReservation&quot;: 0,<br>            &quot;MemorySwap&quot;: 0,<br>            &quot;MemorySwappiness&quot;: null,<br>            &quot;OomKillDisable&quot;: false,<br>            &quot;PidsLimit&quot;: null,<br>            &quot;Ulimits&quot;: null,<br>            &quot;CpuCount&quot;: 0,<br>            &quot;CpuPercent&quot;: 0,<br>            &quot;IOMaximumIOps&quot;: 0,<br>            &quot;IOMaximumBandwidth&quot;: 0,<br>            &quot;MaskedPaths&quot;: [<br>                &quot;/proc/asound&quot;,<br>                &quot;/proc/acpi&quot;,<br>                &quot;/proc/kcore&quot;,<br>                &quot;/proc/keys&quot;,<br>                &quot;/proc/latency_stats&quot;,<br>                &quot;/proc/timer_list&quot;,<br>                &quot;/proc/timer_stats&quot;,<br>                &quot;/proc/sched_debug&quot;,<br>                &quot;/proc/scsi&quot;,<br>                &quot;/sys/firmware&quot;<br>            ],<br>            &quot;ReadonlyPaths&quot;: [<br>                &quot;/proc/bus&quot;,<br>                &quot;/proc/fs&quot;,<br>                &quot;/proc/irq&quot;,<br>                &quot;/proc/sys&quot;,<br>                &quot;/proc/sysrq-trigger&quot;<br>            ]<br>        &#125;,<br>        &quot;GraphDriver&quot;: &#123;<br>            &quot;Data&quot;: &#123;<br>                &quot;DeviceId&quot;: &quot;39&quot;,<br>                &quot;DeviceName&quot;: &quot;docker-253:0-416859-69a71ae6760bc0b71d8f68180021abca897513fe2ee301df4b72a6b66d86a280&quot;,<br>                &quot;DeviceSize&quot;: &quot;10737418240&quot;<br>            &#125;,<br>            &quot;Name&quot;: &quot;devicemapper&quot;<br>        &#125;,<br>        &quot;Mounts&quot;: [],<br>        &quot;Config&quot;: &#123;<br>            &quot;Hostname&quot;: &quot;6d8d42763a1c&quot;,<br>            &quot;Domainname&quot;: &quot;&quot;,<br>            &quot;User&quot;: &quot;&quot;,<br>            &quot;AttachStdin&quot;: true,<br>            &quot;AttachStdout&quot;: true,<br>            &quot;AttachStderr&quot;: true,<br>            &quot;Tty&quot;: true,<br>            &quot;OpenStdin&quot;: true,<br>            &quot;StdinOnce&quot;: true,<br>            &quot;Env&quot;: [<br>                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;<br>            ],<br>            &quot;Cmd&quot;: [<br>                &quot;/bin/bash&quot;<br>            ],<br>            &quot;Image&quot;: &quot;centos&quot;,<br>            &quot;Volumes&quot;: null,<br>            &quot;WorkingDir&quot;: &quot;&quot;,<br>            &quot;Entrypoint&quot;: null,<br>            &quot;OnBuild&quot;: null,<br>            &quot;Labels&quot;: &#123;<br>                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,<br>                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,<br>                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,<br>                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,<br>                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;<br>            &#125;<br>        &#125;,<br>        &quot;NetworkSettings&quot;: &#123;<br>            &quot;Bridge&quot;: &quot;&quot;,<br>            &quot;SandboxID&quot;: &quot;4a28ac0c2d7e597b765f9b51361bd52c8c718a03b64395f0116571255250bc44&quot;,<br>            &quot;HairpinMode&quot;: false,<br>            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,<br>            &quot;LinkLocalIPv6PrefixLen&quot;: 0,<br>            &quot;Ports&quot;: &#123;&#125;,<br>            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/4a28ac0c2d7e&quot;,<br>            &quot;SecondaryIPAddresses&quot;: null,<br>            &quot;SecondaryIPv6Addresses&quot;: null,<br>            &quot;EndpointID&quot;: &quot;b8bcbf2d94837a94e2f13400d636b2194190bae5b8b7f59d1a731e8f32782dbd&quot;,<br>            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>            &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>            &quot;GlobalIPv6PrefixLen&quot;: 0,<br>            &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>            &quot;IPPrefixLen&quot;: 16,<br>            &quot;IPv6Gateway&quot;: &quot;&quot;,<br>            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>            &quot;Networks&quot;: &#123;<br>                &quot;bridge&quot;: &#123;<br>                    &quot;IPAMConfig&quot;: null,<br>                    &quot;Links&quot;: null,<br>                    &quot;Aliases&quot;: null,<br>                    &quot;NetworkID&quot;: &quot;6d2e73bca31a31161b091f8c95b82c9de0afe7f75844aa327a9abccc327d056a&quot;,<br>                    &quot;EndpointID&quot;: &quot;b8bcbf2d94837a94e2f13400d636b2194190bae5b8b7f59d1a731e8f32782dbd&quot;,<br>                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,<br>                    &quot;IPAddress&quot;: &quot;172.17.0.2&quot;,<br>                    &quot;IPPrefixLen&quot;: 16,<br>                    &quot;IPv6Gateway&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,<br>                    &quot;GlobalIPv6PrefixLen&quot;: 0,<br>                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:02&quot;,<br>                    &quot;DriverOpts&quot;: null<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>]<br>[root@localhost ~]# <br><br></code></pre></td></tr></table></figure>

<h3 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h3><p>容器通常都是在 后台运行，我们需要进入容器进行一些操作，比如修改一些配置</p>
<p>方式一：docker exec -it 容器id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES<br>6d8d42763a1c   centos    &quot;/bin/bash&quot;   33 minutes ago   Up 33 minutes             hopeful_banzai<br>[root@localhost ~]# docker exec -it 6d8d42763a1c /bin/bash<br>[root@6d8d42763a1c /]# ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 05:19 pts/0    00:00:00 /bin/bash<br>root        33     0  1 05:53 pts/1    00:00:00 /bin/bash<br>root        47    33  0 05:53 pts/1    00:00:00 ps -ef<br>[root@6d8d42763a1c /]# <br></code></pre></td></tr></table></figure>

<p>方式二：</p>
<p>docker attach 容器id</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES<br>6d8d42763a1c   centos    &quot;/bin/bash&quot;   37 minutes ago   Up 37 minutes             hopeful_banzai<br>[root@localhost ~]# docker attach 6d8d42763a1c<br>[root@6d8d42763a1c /]# ps -ef<br>UID        PID  PPID  C STIME TTY          TIME CMD<br>root         1     0  0 05:19 pts/0    00:00:00 /bin/bash<br>root        48     1  0 05:59 pts/0    00:00:00 ps -ef<br></code></pre></td></tr></table></figure>

<p><strong>区别：</strong></p>
<p>exec进入容器后开启一个新的终端，可以在里面操作</p>
<p>attach进入正在执行的终端，不会启动新的进程</p>
<h3 id="从容器中拷贝文件到主机"><a href="#从容器中拷贝文件到主机" class="headerlink" title="从容器中拷贝文件到主机"></a>从容器中拷贝文件到主机</h3><p>docker cp 容器id:容器内路径 目的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@6d8d42763a1c home]# touch wesker.java 						#新建wesker.java文件<br>[root@6d8d42763a1c home]# ls										#查看文件<br>wesker.java<br>[root@6d8d42763a1c home]# exit<br>[root@localhost ~]# docker cp 6d8d42763a1c:/home/wesker.java /home  #复制<br>[root@localhost ~]# ls /home										#查看复制结果<br>wesker.java  www<br></code></pre></td></tr></table></figure>

<h1 id="6-练习"><a href="#6-练习" class="headerlink" title="6.练习"></a>6.练习</h1><h2 id="6-1-安装nginx"><a href="#6-1-安装nginx" class="headerlink" title="6.1.安装nginx"></a>6.1.安装nginx</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker search nginx -f=STARS=100		#搜索镜像<br>NAME                DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED<br>nginx               Official build of Nginx.                        16965     [OK]       <br>linuxserver/nginx   An Nginx container, brought to you by LinuxS…   169                  <br>bitnami/nginx       Bitnami nginx Docker Image                      131                  [OK]<br>[root@localhost ~]# docker pull nginx				#下载镜像<br>Using default tag: latest<br>latest: Pulling from library/nginx<br>a2abf6c4d29d: Pull complete <br>a9edb18cadd1: Pull complete <br>589b7251471a: Pull complete <br>186b1aaa4aa6: Pull complete <br>b4df32aa5a72: Pull complete <br>a0bcbecc962e: Pull complete <br>Digest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31<br>Status: Downloaded newer image for nginx:latest<br>docker.io/library/nginx:latest<br>[root@localhost ~]# docker images			#查看镜像<br>REPOSITORY   TAG       IMAGE ID       CREATED        SIZE<br>nginx        latest    605c77e624dd   5 months ago   141MB<br>centos       latest    5d0da3dc9764   9 months ago   231MB<br><span class="hljs-meta">#</span><span class="bash">启动容器</span><br>[root@hadoop01 ~]# docker run -d --name nginx01 -p 3344:80 nginx<br>691e347dbea2148928b1f3751fac0e89b691f03e4a4d791c8d08a0f67f939e01<br><span class="hljs-meta">#</span><span class="bash">查看容器</span><br>[root@hadoop01 ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                   NAMES<br>691e347dbea2   nginx     &quot;/docker-entrypoint.…&quot;   6 seconds ago   Up 3 seconds   0.0.0.0:3344-&gt;80/tcp, :::3344-&gt;80/tcp   nginx01<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看nginx是否启动成功</span><br>[root@hadoop01 ~]# curl localhost:3344<br>&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>&lt;title&gt;Welcome to nginx!&lt;/title&gt;               #说明启动成功<br>&lt;style&gt;<br>html &#123; color-scheme: light dark; &#125;<br>body &#123; width: 35em; margin: 0 auto;<br>font-family: Tahoma, Verdana, Arial, sans-serif; &#125;<br>&lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;<br>&lt;p&gt;If you see this page, the nginx web server is successfully installed and<br>working. Further configuration is required.&lt;/p&gt;<br><br>&lt;p&gt;For online documentation and support please refer to<br>&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;<br>Commercial support is available at<br>&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;<br><br>&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br><br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220619192556840.png" alt="image-20220619192556840"></p>
<h2 id="6-2-安装tomcat"><a href="#6-2-安装tomcat" class="headerlink" title="6.2.安装tomcat"></a>6.2.安装tomcat</h2><p>官方：</p>
<p>$ docker run -it –rm tomcat:9.0</p>
<p>–rm代表用完就删掉，一般用于测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@hadoop01 ~]# docker run -d -p 3355:8080 --name tomcat01 tomcat:9.0<br>aeccd4502988dc94910dd469036fb706ce5e6570cc8ed2aa5d0a61006157b094<br>CONTAINER ID   IMAGE        COMMAND             CREATED              STATUS              PORTS                                       NAMES<br>aeccd4502988   tomcat:9.0   &quot;catalina.sh run&quot;   About a minute ago   Up About a minute   0.0.0.0:3355-&gt;8080/tcp, :::3355-&gt;8080/tcp   tomcat01<br></code></pre></td></tr></table></figure>

<p>外网测试：</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220619195851909.png" alt="image-20220619195851909"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入容器</span><br>[root@hadoop01 ~]# docker exec -it tomcat01 /bin/bash<br>root@aeccd4502988:/usr/local/tomcat# ls<br>BUILDING.txt  CONTRIBUTING.md  LICENSE	NOTICE	README.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work<br><span class="hljs-meta">#</span><span class="bash">问题</span><br><span class="hljs-meta">#</span><span class="bash">1.linux 命令少了</span><br><span class="hljs-meta">#</span><span class="bash">2.没有webapps</span><br><span class="hljs-meta">#</span><span class="bash">阿里云镜像的原因，默认是最小的镜像，所以将不必要的给剔除掉，保证最小可运行的环境</span><br></code></pre></td></tr></table></figure>

<h2 id="6-3-部署elasticsearch-kibana"><a href="#6-3-部署elasticsearch-kibana" class="headerlink" title="6.3.部署elasticsearch+kibana"></a>6.3.部署elasticsearch+kibana</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">es暴露的端口多</span><br><span class="hljs-meta">#</span><span class="bash">耗内存</span><br><span class="hljs-meta">#</span><span class="bash">数据一般需要放到安全位置，挂载</span><br><br>docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot;  elasticsearch:8.2.3<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">启动了就会变得非常卡！！！！非常耗内存</span><br><span class="hljs-meta">#</span><span class="bash">docker stats 查看cpu状态</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">-e 分配内存</span><br>docker run -d --name elasticsearch -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:8.2.3<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220619210914663.png" alt="image-20220619210914663"></p>
<h2 id="6-4-可视化工具"><a href="#6-4-可视化工具" class="headerlink" title="6.4.可视化工具"></a>6.4.可视化工具</h2><ul>
<li>portainer</li>
</ul>
<p>docker图形化界面管理工具，提供一个后台面板供我们操作</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker run -d -p 8088:9000 \ --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true  portainer/portainer<br></code></pre></td></tr></table></figure>

<p>测试：</p>
<p>能够成功访问，设置密码</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620153416077.png" alt="image-20220620153416077"></p>
<p>portainer主页</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620153931710.png" alt="image-20220620153931710"></p>
<p>可以看到本地的镜像以及创建的一些容器及其信息</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620154339347.png" alt="image-20220620154339347"></p>
<ul>
<li>rancher</li>
</ul>
<h1 id="7-docker镜像讲解"><a href="#7-docker镜像讲解" class="headerlink" title="7.docker镜像讲解"></a>7.docker镜像讲解</h1><h2 id="7-1-镜像是什么"><a href="#7-1-镜像是什么" class="headerlink" title="7.1.镜像是什么"></a>7.1.镜像是什么</h2><p>镜像是一种轻量级，可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件的所有内容，包括代码，运行时，库，环境变量和配置文件。</p>
<p>如何得到镜像？</p>
<p>1.从远程仓库获取</p>
<p>2.拷贝</p>
<p>3.自己制作（dockerfile）</p>
<h2 id="7-2-联合文件系统（UnionFS）"><a href="#7-2-联合文件系统（UnionFS）" class="headerlink" title="7.2.联合文件系统（UnionFS）"></a>7.2.联合文件系统（UnionFS）</h2><p>什么是 UnionFS？</p>
<blockquote>
<p>联合文件系统（UnionFile System）：</p>
<p> 2004年由纽约州立大学开发，它可以把多个目录内容联合挂载到同一个目录下，而目录的物理位置是分开的。UnionFS可以把只读和可读写文件系统合并在一起，具有写时复制功能，允许只读文件系统的修改可以保存到可写文件系统当中。</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下</p>
<p>Union 文件系统是 Docker 镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p><strong>特性： 一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录。</strong></p>
<p> 在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载。</p>
<p>为什么一个Tomcat镜像500Mb：因为它有很多层依赖<br>在这里插入图片描述</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg4MDA1NQ==,size_16,color_FFFFFF,t_70.png" alt="img"></p>
<p>分层的原因：</p>
<ol>
<li><p>分层最大的一个好处就是共享资源</p>
</li>
<li><p>有多个镜像都从相同的base镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像；</p>
</li>
<li><p>同时内存中也只需加载一份base镜像，就可以为所有容器服务了，而且镜像的每一层都可以被共享。</p>
</li>
</ol>
<h2 id="7-3-提交镜像"><a href="#7-3-提交镜像" class="headerlink" title="7.3.提交镜像"></a>7.3.提交镜像</h2><p>tomcat默认webapps里面没有东西，每次新创建一个新的tomcat的容器都需要将webapps.dist里面的东西复制到webapps内,我们需要创建一个新的镜像，这个镜像的webapps内是有内容的。</p>
<ol>
<li>启动一个容器</li>
<li>将这个容器修改为我们想要的效果</li>
<li>利用commit命令将该容器包装为一个新的镜像</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d -p 8080:8080 --name tomcat01 tomcat:9.0<br>5c90c68b87645b21d0adcde91d2a34ddba483592de943cb720711679b9679c64<br>[root@localhost ~]# docker exec -it tomcat01  /bin/bash<br>root@5c90c68b8764:/usr/local/tomcat# ls<br>BUILDING.txt  CONTRIBUTING.md  LICENSE	NOTICE	README.md  RELEASE-NOTES  RUNNING.txt  bin  conf  lib  logs  native-jni-lib  temp  webapps  webapps.dist  work<br><br>root@5c90c68b8764:/usr/local/tomcat# cp -r  webapps.dist/*  webapps  #复制到webapps<br>root@5c90c68b8764:/usr/local/tomcat# ls webapps<br>ROOT  docs  examples  host-manager  manager<br>root@5c90c68b8764:/usr/local/tomcat# read escape sequence<br>[root@localhost ~]# docker ps<br>CONTAINER ID   IMAGE        COMMAND             CREATED         STATUS         PORTS                                       NAMES<br>5c90c68b8764   tomcat:9.0   &quot;catalina.sh run&quot;   4 minutes ago   Up 4 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01<br>[root@localhost ~]# docker restart tomcat01 <br>tomcat01<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">利用commit将容器包装为一个新的镜像</span><br>[root@localhost ~]# docker commit -m=&quot;add webapps&quot; -a=&quot;wesker&quot; 5c90c68b8764 tomcat02:1.0<br>sha256:10e52365781c878f5e55f6abc3f70ede35d57f1b6152d55ce8e55ee928fc7dfb<br>[root@localhost ~]# docker images<br>REPOSITORY            TAG       IMAGE ID       CREATED         SIZE<br>tomcat02              1.0       10e52365781c   6 seconds ago   685MB	#新的镜像<br>tomcat                9.0       ae6026892279   10 days ago     680MB<br>elasticsearch         8.2.3     59306705ed62   11 days ago     1.2GB<br>nginx                 latest    0e901e68141f   3 weeks ago     142MB<br>portainer/portainer   latest    12b0b8dced14   6 weeks ago     75.4MB<br></code></pre></td></tr></table></figure>

<h1 id="8-容器数据卷"><a href="#8-容器数据卷" class="headerlink" title="8.容器数据卷"></a>8.容器数据卷</h1><h2 id="8-1-什么是容器数据卷？"><a href="#8-1-什么是容器数据卷？" class="headerlink" title="8.1.什么是容器数据卷？"></a>8.1.什么是容器数据卷？</h2><h2 id="8-2-使用数据卷"><a href="#8-2-使用数据卷" class="headerlink" title="8.2.使用数据卷"></a>8.2.使用数据卷</h2><blockquote>
<p>使用命令来挂载  -v</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">运行centos,</span><br>[root@localhost /]# docker run -it -v /home/test:/home centos /bin/bash<br>[root@localhost test]# docker inspect e462ab601e46<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620181123718.png" alt="image-20220620181123718"></p>
<p>测试：</p>
<p>在容器中的home目录下创建wesker.java文件，宿主机在路径为/home/test下也会生成相应的文件wesker.java</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620185017101.png" alt="image-20220620185017101"></p>
<p>继续测试</p>
<p>将容器停止运行，在宿主机上编辑wesker.java文件，容器中对应的文件也会发生相应的变化。</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620190424073.png" alt="image-20220620190424073"></p>
<p>好处：需要修改容器内的某些文件时，不必进入到容器内去修改，在宿主机相对应的位置修改即可</p>
<h2 id="8-3-实战：安装mysql"><a href="#8-3-实战：安装mysql" class="headerlink" title="8.3.实战：安装mysql"></a>8.3.实战：安装mysql</h2><p>mysql的数据持久化问题</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">下载mysql镜像</span><br>[root@localhost test]# docker pull mysql:8.0.29<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">官方</span><br><span class="hljs-meta">$</span><span class="bash"> docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">启动容器，端口映射为宿主机的3310端口</span><br>[root@localhost ~]# docker run -d -p 3310:3306 -v /home/mysql/conf:/ect/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=486934.0 --name mysql01 mysql:8.0.29<br>e64017007d17ea80f65bf8786556a7b88b7b22e22c1656fe13da0ea1c8ea2e01<br>[root@localhost ~]# docker ps<br>CONTAINER ID   IMAGE          COMMAND                  CREATED         STATUS         PORTS                                                  NAMES<br>e64017007d17   mysql:8.0.29   &quot;docker-entrypoint.s…&quot;   5 seconds ago   Up 4 seconds   33060/tcp, 0.0.0.0:3310-&gt;3306/tcp, :::3310-&gt;3306/tcp   mysql01<br></code></pre></td></tr></table></figure>

<p>启动成功之后，使用Navicat尝试连接，可能会出现2059的错误，<a href="https://wesker.top/2022/06/20/mysql%E5%87%BA%E7%8E%B02059/">点击解决</a></p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620195627032.png" alt="image-20220620195627032"></p>
<p>连接成功之后创建名为test的数据库进行测试</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620201125057.png" alt="image-20220620201125057"></p>
<p>进入宿主机下的/home/mysql/data目录，查看是否同步</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220620201431071.png" alt="image-20220620201431071"></p>
<blockquote>
<p>即使删除了容器本身，挂载到宿主机当中的数据依旧存在，实现了数据持久化功能</p>
</blockquote>
<h2 id="8-4-具名和匿名挂载"><a href="#8-4-具名和匿名挂载" class="headerlink" title="8.4.具名和匿名挂载"></a>8.4.具名和匿名挂载</h2><blockquote>
<p>具名挂载：挂载到宿主机上的时候指定具体的卷名</p>
</blockquote>
<p><strong>-v 卷名：容器内的路径</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d -P --name nginx02 -v nginx-juming:/etc/nginx nginx <br>4a1c46b08a6a2cb131e46fbcc0206c2a0f599d5b88a9cd1006e564b4c7c4f42b<br>[root@localhost ~]# docker volume ls	#查询所有的卷<br>DRIVER    VOLUME NAME<br>local     1516df7d492c53d2abaa0ec880b94d9eeabf620fad90092d56b367b4f515ce1d<br>local     nginx-juming					#启动容器时指定的卷名<br></code></pre></td></tr></table></figure>

<p>查看nginx-juming卷的信息，没有指定宿主机挂载位置的情况下，默认挂载到宿主机的<code>/var/lib/docker/volumes</code>目录下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker volume inspect nginx-juming<br>[<br>    &#123;<br>        &quot;CreatedAt&quot;: &quot;2022-06-20T20:32:32+08:00&quot;,<br>        &quot;Driver&quot;: &quot;local&quot;,<br>        &quot;Labels&quot;: null,<br>        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/nginx-juming/_data&quot;,#默认挂载到宿主机的该位置<br>        &quot;Name&quot;: &quot;nginx-juming&quot;,<br>        &quot;Options&quot;: null,<br>        &quot;Scope&quot;: &quot;local&quot;<br>    &#125;<br>]<br><br><br>[root@localhost ~]# cd /var/lib/docker/volumes #进入/var/lib/docker/volumes`目录<br>[root@localhost volumes]# ls<br>1516df7d492c53d2abaa0ec880b94d9eeabf620fad90092d56b367b4f515ce1d  backingFsBlockDev  metadata.db  nginx-juming<br><br>[root@localhost volumes]# cd nginx-juming/  #进入挂载目录中<br>[root@localhost nginx-juming]# ls<br>_data<br>[root@localhost nginx-juming]# cd _data/<br>[root@localhost _data]# ls					#同步成功<br>conf.d  fastcgi_params  mime.types  modules  nginx.conf  scgi_params  uwsgi_params<br><br></code></pre></td></tr></table></figure>





<blockquote>
<p>匿名挂载：不设置具体的卷名，直接将容器中需要挂载的内容挂载即可</p>
</blockquote>
<p><strong>-v 容器内的路径</strong></p>
<p>匿名挂载在启动容器的时候会随机生成一个卷名，默认挂载位置在宿主机的<code>/var/lib/docker/volumes</code>路径下，一般不推荐使用。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d -P --name nginx03 -v /etc/nginx nginx<br>ce9bb79ebeac520f2660b2b4e7d9aaa640e125aa508069de3f1ecd84df09bcf5<br>[root@localhost ~]# docker ps<br>CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS                                     NAMES<br>ce9bb79ebeac   nginx     &quot;/docker-entrypoint.…&quot;   6 seconds ago   Up 4 seconds   0.0.0.0:49154-&gt;80/tcp, :::49154-&gt;80/tcp   nginx03<br>[root@localhost ~]# docker volume  ls<br>DRIVER    VOLUME NAME<br>local     8f4013a8faf485e21fc4e77f0ce4faeeac7e89df1af488d24144013b7559b0e4<br>local     1516df7d492c53d2abaa0ec880b94d9eeabf620fad90092d56b367b4f515ce1d<br>local     nginx-juming<br><br></code></pre></td></tr></table></figure>

<p><strong>总结：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">-v 容器路径							  #匿名挂载<br>-v 卷名:容器路径		 		         #具名挂载<br>-v /宿主机路径：容器路径				  #指定路径挂载<br></code></pre></td></tr></table></figure>

<p><strong>拓展：</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">-v 容器内路径:ro	rw  改变读写权限<br>ro:readonly			#只读		容器内改不了内容，只能通过宿主机来修改内容<br>rw:readwrite		#读写		容器可以查看也可以修改内容，默认是rw<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">这个权限是相对于容器而言，一旦设置了容器权限，容器挂载出来的内容就会有限制</span><br><br>docker run -d -P --name nginx02 -v nginx-juming:/etc/nginx:ro nginx		#ro<br>docker run -d -P --name nginx02 -v nginx-juming:/etc/nginx:rw nginx		#rw<br></code></pre></td></tr></table></figure>

<h2 id="8-5-初识dockerfile"><a href="#8-5-初识dockerfile" class="headerlink" title="8.5.初识dockerfile"></a>8.5.初识dockerfile</h2><p>dockerfile就是用来构建docker镜像的构建文件，命令脚本！通过脚本可以生成镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">创建一个dockerfile文件，名字建议就叫dockerfile</span><br><span class="hljs-meta">#</span><span class="bash">docker中的内容</span><br>FROM centos<br><br>VOLUME [&quot;volume01&quot;,&quot;volume01&quot;]<br><br>CMD echo &quot;-----end-----&quot;<br>CMD /bin/bash<br></code></pre></td></tr></table></figure>

<p>构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile  -t centos-test:1.0 .<br>Sending build context to Docker daemon  2.048kB<br>Step 1/4 : FROM centos				#每个步骤就是一层<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 5d0da3dc9764</span><br>Step 2/4 : VOLUME [&quot;volume01&quot;,&quot;volume01&quot;]<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 7de0da8bdf8a</span><br>Removing intermediate container 7de0da8bdf8a<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> cd79526439ec</span><br>Step 3/4 : CMD echo &quot;-----end-----&quot;<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 903f2270360e</span><br>Removing intermediate container 903f2270360e<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 41ad50620448</span><br>Step 4/4 : CMD /bin/bash<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 88ef8f870a6e</span><br>Removing intermediate container 88ef8f870a6e<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 95160d7d677a</span><br>Successfully built 95160d7d677a<br>Successfully tagged centos-test:1.0<br><br></code></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost docker-test-volume]# docker run -it centos-test:1.0 /bin/bash<br>[root@fe1f4388abe7 /]# ls<br>bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var  volume01	volume02<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621115729853.png" alt="image-20220621115729853"></p>
<p>这个卷和宿主机一定有一个同步的目录</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621115926682.png" alt="image-20220621115926682"> </p>
<p>我们在容器内的数据卷目录中创建一个文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@381c8c8664d3 volume01]# touch container.txt<br>[root@381c8c8664d3 volume01]# ls<br>container.txt<br></code></pre></td></tr></table></figure>

<p>查看一下宿主机匿名挂载的路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker inspect 381c8c8664d3<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621120435412.png" alt="image-20220621120435412"></p>
<p>进入宿主机匿名挂载的位置</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621121027469.png" alt="image-20220621121027469"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">进入volume01对应宿主机中的目录下的_data文件夹，查看是否同步成功</span><br>[root@localhost ~]# cd /var/lib/docker/volumes/ec797574c1557e6cc75655c7e1a1cddc398ddffe4b7bfa1f4c6c9560d265f20f/_data<br>[root@localhost _data]# ls<br>container.txt				#同步成功<br></code></pre></td></tr></table></figure>

<h2 id="8-6-数据卷容器"><a href="#8-6-数据卷容器" class="headerlink" title="8.6.数据卷容器"></a>8.6.数据卷容器</h2><p>多个容器之间可以通过数据卷技术达到同步数据</p>
<blockquote>
<p>–volumes-from 父容器</p>
</blockquote>
<p>测试：</p>
<p>启动docker01</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621151526862.png" alt="image-20220621151526862"></p>
<p>启动docker02</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621152026609.png" alt="image-20220621152026609"></p>
<p>在docker01中创建文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker attach docker01			#进入docker01<br>[root@5a5216d69ec0 /]# ls -l			#查看当前文件夹下的所有文件<br>total 0<br>lrwxrwxrwx   1 root root   7 Nov  3  2020 bin -&gt; usr/bin<br>drwxr-xr-x   5 root root 360 Jun 21 07:14 dev<br>drwxr-xr-x   1 root root  66 Jun 21 07:14 etc<br>drwxr-xr-x   2 root root   6 Nov  3  2020 home<br>lrwxrwxrwx   1 root root   7 Nov  3  2020 lib -&gt; usr/lib<br>lrwxrwxrwx   1 root root   9 Nov  3  2020 lib64 -&gt; usr/lib64<br>drwx------   2 root root   6 Sep 15  2021 lost+found<br>drwxr-xr-x   2 root root   6 Nov  3  2020 media<br>drwxr-xr-x   2 root root   6 Nov  3  2020 mnt<br>drwxr-xr-x   2 root root   6 Nov  3  2020 opt<br>dr-xr-xr-x 245 root root   0 Jun 21 07:14 proc<br>dr-xr-x---   2 root root 162 Sep 15  2021 root<br>drwxr-xr-x  11 root root 163 Sep 15  2021 run<br>lrwxrwxrwx   1 root root   8 Nov  3  2020 sbin -&gt; usr/sbin<br>drwxr-xr-x   2 root root   6 Nov  3  2020 srv<br>dr-xr-xr-x  13 root root   0 Jun 21 03:54 sys<br>drwxrwxrwt   7 root root 171 Sep 15  2021 tmp<br>drwxr-xr-x  12 root root 144 Sep 15  2021 usr<br>drwxr-xr-x  20 root root 262 Sep 15  2021 var<br>drwxr-xr-x   2 root root   6 Jun 21 07:14 volume01<br>drwxr-xr-x   2 root root   6 Jun 21 07:14 volume02<br>[root@5a5216d69ec0 /]# cd volume01		#进入volume01文件夹下<br>[root@5a5216d69ec0 volume01]# ls      <br>[root@5a5216d69ec0 volume01]# touch test.java		#创建test.java文件<br>[root@5a5216d69ec0 volume01]# ls<br>test.java								#创建成功<br></code></pre></td></tr></table></figure>

<p>查看docker02是否同步成功</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost _data]# docker attach docker02		#进入docker02<br>[root@752ed4fb0025 /]# cd volume01			#进入volume01目录下<br>[root@752ed4fb0025 volume01]# ls -l				#查看当前目录下的文件<br>total 0<br>-rw-r--r-- 1 root root 0 Jun 21 07:22 test.java			#同步成功<br></code></pre></td></tr></table></figure>

<blockquote>
<p>这是一种备份机制，即使父容器删除或者数据丢失，其他的容器不会收到影响</p>
</blockquote>
<p>可用于多个mysql数据库实现数据共享</p>
<h1 id="9-dockerfile"><a href="#9-dockerfile" class="headerlink" title="9.dockerfile"></a>9.dockerfile</h1><h2 id="9-1-dockerfile介绍"><a href="#9-1-dockerfile介绍" class="headerlink" title="9.1.dockerfile介绍"></a>9.1.dockerfile介绍</h2><p>dockerfile 是用来构建docker镜像的文件！</p>
<p>构建步骤：</p>
<ol>
<li>编写一个dockerfile文件</li>
<li>docker build 构建为一个docker镜像</li>
<li>docker run 运行镜像</li>
<li>docker push ( dockerhub、阿里云镜像仓库)</li>
</ol>
<h2 id="9-2-构建过程"><a href="#9-2-构建过程" class="headerlink" title="9.2.构建过程"></a>9.2.构建过程</h2><p>基础知识：</p>
<ol>
<li>每个保留关键字（指令）都必须是大写的</li>
<li>指令是从上到下顺序执行</li>
<li>#表示注释</li>
<li>一个指令都会提交新的镜像层，并提交</li>
</ol>
<p>dockerfile是面向开发的，我们以后要发布项目，做镜像都要编写dockerfile文件</p>
<h2 id="9-3-dockerfile的命令"><a href="#9-3-dockerfile的命令" class="headerlink" title="9.3.dockerfile的命令"></a>9.3.dockerfile的命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">FROM		#指定基础镜像<br>MAINTAINER	#镜像时谁写的<br>RUN			#镜像构建的时候需要运行的命令<br>ADD			#在基础镜像上添加新的镜像<br>WORKDIR		#镜像的工作目录<br>VOLUME		#挂载的目录<br>EXPOSE		#指定暴露的端口<br>CMD			#指定容器启动后运行的命令,只有最后一个会生效，可被替代<br>ENTRYPOINT	#指定容器启动后运行的命令，可以追加命令<br>ONBUILD		#当构建一个被继承dockerfile,这个时候会触发ONBUILD指令<br>COPY		#类似ADD，将我们的文件拷贝到镜像中<br>ENV			#构建的时候设置环境变量<br></code></pre></td></tr></table></figure>

<h2 id="9-4-实战测试-centos"><a href="#9-4-实战测试-centos" class="headerlink" title="9.4.实战测试:centos"></a>9.4.实战测试:centos</h2><p>dockerhub中99%的镜像都是从这个基础镜像过来的，然后配置我们需要的软件和配置</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621161909688.png" alt="image-20220621161909688"></p>
<blockquote>
<p>创建一个自己的centos，添加了vim编辑器和net-stools</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">编写dockerfile文件</span><br>FROM centos<br>MAINTAINEER wesker&lt;841448329@qq.com&gt;<br><br>ENV MYPATH /usr/local<br>WORKDIR $MYPAYH<br><br><br>RUN yum -y install vim<br>RUN yun -y install net-stools<br><br>EXPOSE 80<br><br>CMD echo $MYPATH<br>CMD echo &quot;----end----&quot;<br>CMD /bin/bash<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">创建镜像</span><br>-f dockerfile路径 -t生成的镜像名：生成的版本号<br>[root@localhost dockerfile]# docker build -f mydockerfile -t mycentos:0.1 .<br>Successfully built a7cbb513aa69<br>Successfully tagged mycentos:0.1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">测试</span><br>[root@localhost dockerfile]# docker run -it mycentos:0.1	#启动镜像<br>[root@df6c33caef1c local]# vim test.txt 				#测试vim编辑器是否可用<br>[root@df6c33caef1c local]# ifconfig		#测试ipconfig是否可用<br>eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500<br>        inet 172.17.0.2  netmask 255.255.0.0  broadcast 172.17.255.255<br>        ether 02:42:ac:11:00:02  txqueuelen 0  (Ethernet)<br>        RX packets 8  bytes 656 (656.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536<br>        inet 127.0.0.1  netmask 255.0.0.0<br>        loop  txqueuelen 1000  (Local Loopback)<br>        RX packets 0  bytes 0 (0.0 B)<br>        RX errors 0  dropped 0  overruns 0  frame 0<br>        TX packets 0  bytes 0 (0.0 B)<br>        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0<br><br>[root@df6c33caef1c local]# vim test.txt <br><br></code></pre></td></tr></table></figure>

<p>除此之外默认工作路径改为了usr/local</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621184944952.png" alt="image-20220621184944952"></p>
<p>我们还可以通过docker history 镜像id/（镜像名：版本号）来查看镜像的历史变更信息</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621185404108.png" alt="image-20220621185404108"></p>
<blockquote>
<p>CMD和ENTRYPOINT的区别</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">CMD			#指定容器启动后运行的命令,只有最后一个会生效，可被替代<br>ENTRYPOINT	#指定容器启动后运行的命令，可以追加命令<br></code></pre></td></tr></table></figure>

<p>CMD测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">构建dockerfile文件</span><br>vim dockerfile-cmd <br>FROM centos:7<br>CMD [&quot;ls&quot;,&quot;-a&quot;]		<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">构建镜像</span><br>[root@localhost dockerfile]# docker build -f dockerfile-cmd -t centos-cmd:0.1 .<br>Sending build context to Docker daemon  3.072kB<br>Step 1/2 : FROM centos:7<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> eeb6ee3f44bd</span><br>Step 2/2 : CMD [&quot;ls&quot;,&quot;-a&quot;]<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> Running <span class="hljs-keyword">in</span> 757abe8012a9</span><br>Removing intermediate container 757abe8012a9<br><span class="hljs-meta"> ---&gt;</span><span class="bash"> 74e2cb6a5b6b</span><br>Successfully built 74e2cb6a5b6b<br>Successfully tagged centos-cmd:0.1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">运行  ls -a命令生效</span><br>[root@localhost dockerfile]# docker run centos-cmd:0.1<br>.<br>..<br>.dockerenv<br>anaconda-post.log<br>bin<br>dev<br>etc<br>home<br>lib<br>lib64<br>media<br>mnt<br>opt<br>proc<br>root<br>run<br>sbin<br>srv<br>sys<br>tmp<br>usr<br>var<br><span class="hljs-meta">#</span><span class="bash">如果我们想在ls -a的基础上追加一个命令</span><br>[root@localhost dockerfile]# docker run centos-cmd:0.1 -l<br>docker: Error response from daemon: failed to create shim task: OCI runtime create failed: runc create failed: unable to start container process: exec: &quot;-l&quot;: executable file not found in $PATH: unknown.<br><span class="hljs-meta">#</span><span class="bash">这时 -l会替换原来的ls -a命令，-l 不是命令因此报错</span><br></code></pre></td></tr></table></figure>

<p>ENTRYPOINT测试：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">构建dockerfile文件</span><br>vim centos-entrypoint<br>FROM centos:7<br>ENTRYPOINT [&quot;ls&quot;,&quot;-a&quot;]<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">构建镜像</span><br>docker build -f centos-entrypoint -t centos-entrypoint:0.1 .<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">运行测试</span><br>[root@localhost dockerfile]# docker run centos-entrypoint:0.1<br>.<br>..<br>.dockerenv<br>anaconda-post.log<br>bin<br>dev<br>etc<br>home<br>lib<br>lib64<br>media<br>mnt<br>opt<br>proc<br>root<br>run<br>sbin<br>srv<br>sys<br>tmp<br>usr<br>var<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">-l是直接拼接在ls -a后面的</span><br>[root@localhost dockerfile]# docker run centos-entrypoint:0.1 -l	#追加命令<br>total 12<br>drwxr-xr-x   1 root root     6 Jun 21 11:30 .<br>drwxr-xr-x   1 root root     6 Jun 21 11:30 ..<br>-rwxr-xr-x   1 root root     0 Jun 21 11:30 .dockerenv<br>-rw-r--r--   1 root root 12114 Nov 13  2020 anaconda-post.log<br>lrwxrwxrwx   1 root root     7 Nov 13  2020 bin -&gt; usr/bin<br>drwxr-xr-x   5 root root   340 Jun 21 11:30 dev<br>drwxr-xr-x   1 root root    66 Jun 21 11:30 etc<br>drwxr-xr-x   2 root root     6 Apr 11  2018 home<br>lrwxrwxrwx   1 root root     7 Nov 13  2020 lib -&gt; usr/lib<br>lrwxrwxrwx   1 root root     9 Nov 13  2020 lib64 -&gt; usr/lib64<br>drwxr-xr-x   2 root root     6 Apr 11  2018 media<br>drwxr-xr-x   2 root root     6 Apr 11  2018 mnt<br>drwxr-xr-x   2 root root     6 Apr 11  2018 opt<br>dr-xr-xr-x 253 root root     0 Jun 21 11:30 proc<br>dr-xr-x---   2 root root   114 Nov 13  2020 root<br>drwxr-xr-x  11 root root   148 Nov 13  2020 run<br>lrwxrwxrwx   1 root root     8 Nov 13  2020 sbin -&gt; usr/sbin<br>drwxr-xr-x   2 root root     6 Apr 11  2018 srv<br>dr-xr-xr-x  13 root root     0 Jun 21 03:54 sys<br>drwxrwxrwt   7 root root   132 Nov 13  2020 tmp<br>drwxr-xr-x  13 root root   155 Nov 13  2020 usr<br>drwxr-xr-x  18 root root   238 Nov 13  2020 var<br></code></pre></td></tr></table></figure>

<h2 id="9-5-实战测试-tomcat"><a href="#9-5-实战测试-tomcat" class="headerlink" title="9.5.实战测试:tomcat"></a>9.5.实战测试:tomcat</h2><p>1、准备镜像文件tomcat压缩包，jdk的压缩包</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220621201412669.png" alt="image-20220621201412669"></p>
<p>2、编写Dockerfile文件，官方命名Dockerfile，build会自动找到这个文件，就不需要-f 指定了</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">FROM centos:7<br>MAINTAINER wesker&lt;841448329@qq.com&gt;<br>COPY readme.txt /usr/local/readme.txt<br><br>ADD apache-tomcat-8.5.57.rar /usr/local/<br>ADD jdk-8u281-linux-x64.tar.gz /usr/local/<br><br>RUN yum -y install vim<br><br>ENV  MYPATH /usr/local<br>WORKDIR $MYPATH<br><br>ENV JAVA_HOME /usr/local/jdk1.8.2<br>ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVAHOME/lib/tools.jar<br>ENV CATALINA_HOME /usr/local/apache-tomcat-8.5.57<br>ENV CATALINA_BASH /usr/lcoal/apache-tomcat-8.5.57<br>ENV PATH $PATH:$JAVA_HOME/bin;$CATALINA_HOME/bin;$CATALINA_HOME/lib<br><br>EXPOSE 8080<br><br>CMD /usr/local/apache-tomcat-8.5.57/bin/startup.sh &amp;&amp; tail -F /url/local/apache-tomcat-8.5.57/bin/logs/catalina.out<br><br></code></pre></td></tr></table></figure>

<p>3、构建镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost tomcat]# docker build -t diytomcat .<br>Successfully built 72607def5338<br>Successfully tagged diytomcat:latest<br><br></code></pre></td></tr></table></figure>

<p>4、启动镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost tomcat]# docker run -d -p 9090:8080 -v /home/tomcat/test:/usr/local/apache-tomcat-8.5.79/webapps/test -v /home/tomcat/tomcatlogs/:/usr/local/apache-tomcat-8.5.79/logs diytomcat<br><br>[root@localhost tomcat]# docker ps<br>CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                                       NAMES<br>91a0b1af76ec   diytomcat   &quot;/bin/sh -c &#x27;/usr/lo…&quot;   9 minutes ago   Up 9 minutes   0.0.0.0:9090-&gt;8080/tcp, :::9090-&gt;8080/tcp   nostalgic_khorana<br><br></code></pre></td></tr></table></figure>

<p>5、外网测试</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622151700480.png" alt="image-20220622151700480"></p>
<p>6、发布项目</p>
<p>进入到/home/tomcat/test目录下，创建WEB-INF文件夹，在该文件夹下创建web.xml和index.html。</p>
<p>web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee</span></span><br><span class="hljs-string"><span class="hljs-tag">                               http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;2.5&quot;</span>&gt;</span><br> <br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>index.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">HTML</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>hello wesker<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">base</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://titan/listings/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;author&quot;</span> <span class="hljs-attr">content</span>= <span class="hljs-string">&quot;Adam Freeman&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>= <span class="hljs-string">&quot;A simple example&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">re1</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/css&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;styles.css&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;shortcut icon&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;favicon.ico&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/x- icon&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/page2.html&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>hello world <span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>测试成功！</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622154010809.png" alt="image-20220622154010809"></p>
<h2 id="9-6-发布镜像"><a href="#9-6-发布镜像" class="headerlink" title="9.6.发布镜像"></a>9.6.发布镜像</h2><blockquote>
<p>dockerhub</p>
</blockquote>
<p>地址：<a href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<p>1、注册账号</p>
<p>2、登录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker login --help<br><br>Usage:  docker login [OPTIONS] [SERVER]<br><br>Log in to a Docker registry.<br>If no server is specified, the default is defined by the daemon.<br><br>Options:<br>  -p, --password string   Password<br>      --password-stdin    Take the password from stdin<br>  -u, --username string   Username<br>[root@localhost ~]# docker login -u wesker6666<br>Password: <br>WARNING! Your password will be stored unencrypted in /root/.docker/config.json.<br>Configure a credential helper to remove this warning. See<br>https://docs.docker.com/engine/reference/commandline/login/#credentials-store<br><br>Login Succeeded<br></code></pre></td></tr></table></figure>

<p>3、提交镜像</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">不能直接提交镜像，需要使用docker tag 镜像名:版本号 dockerhub账户名/镜像名:版本号</span><br>[root@localhost tomcat]# docker tag diytomcat:latest wesker6666/tomcat:1.0<br>[root@localhost tomcat]# docker images<br>REPOSITORY            TAG       IMAGE ID       CREATED             SIZE<br>diytomcat             latest    626d380ed5c0   About an hour ago   802MB<br>wesker6666/tomcat     1.0       626d380ed5c0   About an hour ago   802MB<br>centos-entrypoint     0.1       58869fd1e2ac   21 hours ago        204MB<br>mycentos              0.1       a7cbb513aa69   22 hours ago        601MB<br>centos-test           1.0       442318326f1b   28 hours ago        231MB<br>tomcat02              1.0       10e52365781c   47 hours ago        685MB<br>tomcat                9.0       ae6026892279   12 days ago         680MB<br>elasticsearch         8.2.3     59306705ed62   13 days ago         1.2GB<br>nginx                 latest    0e901e68141f   3 weeks ago         142MB<br>mysql                 8.0.29    65b636d5542b   3 weeks ago         524MB<br>portainer/portainer   latest    12b0b8dced14   6 weeks ago         75.4MB<br>centos                7         eeb6ee3f44bd   9 months ago        204MB<br>centos                latest    5d0da3dc9764   9 months ago        231MB<br>[root@localhost tomcat]# docker push wesker6666/tomcat:1.0		#提交镜像<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622162656710.png" alt="image-20220622162656710"></p>
<blockquote>
<p>发布到阿里云镜像</p>
</blockquote>
<p>1、登录阿里云</p>
<p>2、找到容器镜像服务    <a href="https://cr.console.aliyun.com/cn-hangzhou/instances">https://cr.console.aliyun.com/cn-hangzhou/instances</a></p>
<p>3、创建命名空间</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622164531311.png" alt="image-20220622164531311"></p>
<p>4、创建镜像仓库</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622164731683.png" alt="image-20220622164731683"></p>
<p>5、登录阿里云Docker Registry</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">$ docker <span class="hljs-keyword">login</span> <span class="hljs-comment">--username=wesker registry.cn-hangzhou.aliyuncs.com</span><br></code></pre></td></tr></table></figure>

<p>用于登录的用户名为阿里云账号全名，密码为开通服务时设置的密码。</p>
<p>6、将镜像推送到Registry</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">$ docker login --username=wesker registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com$ docker tag <span class="hljs-selector-attr">[ImageId]</span> registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com/wesker_tomcat/wesker-test:<span class="hljs-selector-attr">[镜像版本号]</span>$ docker push registry<span class="hljs-selector-class">.cn-hangzhou</span><span class="hljs-selector-class">.aliyuncs</span>.com/wesker_tomcat/wesker-test:<span class="hljs-selector-attr">[镜像版本号]</span><br></code></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622170211137.png" alt="image-20220622170211137"></p>
<h1 id="10-docker网络"><a href="#10-docker网络" class="headerlink" title="10.docker网络"></a>10.docker网络</h1><h2 id="理解docker0"><a href="#理解docker0" class="headerlink" title="理解docker0"></a>理解docker0</h2><p>清空所有环境</p>
<blockquote>
<p>测试</p>
</blockquote>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622181803451.png" alt="image-20220622181803451"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d -P --name tomcat01 tomcat<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">查看容器的内部网络地址</span><br>[root@localhost ~]# docker exec -it tomcat01 ip addr<br>1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000<br>    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00<br>    inet 127.0.0.1/8 scope host lo<br>       valid_lft forever preferred_lft forever<br>22: eth0@if23: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UP group default <br>    link/ether 02:42:ac:11:00:02 brd ff:ff:ff:ff:ff:ff<br>    inet 172.17.0.2/16 brd 172.17.255.255 scope global eth0<br>       valid_lft forever preferred_lft forever<br><span class="hljs-meta">#</span><span class="bash">尝试ping容器</span><br>[root@localhost ~]# ping 172.17.0.2<br>PING 172.17.0.2 (172.17.0.2) 56(84) bytes of data.<br>64 bytes from 172.17.0.2: icmp_seq=1 ttl=64 time=0.339 ms<br>64 bytes from 172.17.0.2: icmp_seq=2 ttl=64 time=0.131 ms<br>64 bytes from 172.17.0.2: icmp_seq=3 ttl=64 time=0.206 ms<br>64 bytes from 172.17.0.2: icmp_seq=4 ttl=64 time=0.358 ms<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">能ping通</span><br><br></code></pre></td></tr></table></figure>

<p>我们每启动一个容器，docker就会给每个容器分配一个ip，我们只要安装了docker ,就会有一个docker0,桥接模式</p>
<p>使用的是evth-pair技术</p>
<p>再次测试ip addr，会多了一个网卡</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622191154621.png" alt="image-20220622191154621"></p>
<p>再启动一个容器测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d -P --name tomcat02 tomcat:8.0<br></code></pre></td></tr></table></figure>

<p>再次使用ip addr,发现又多了一对网卡</p>
<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622191350025.png" alt="image-20220622191350025"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker exec -it tomcat02 ip addr #进入容器并运行 ip addr 命令<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220622191751990.png" alt="image-20220622191751990"></p>
<p>我们发现每启动一个容器都会带来一对网卡，evth-pair就是一对虚拟设备接口，一端连着协议，一端彼此相连，正因为有这个特性，evth-pair 用来充当桥梁，连接各种虚拟网络设备</p>
<p>测试一下tomcat01和tomcat02是否可以ping通</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">root@80145b9ed29a:/usr/local/tomcat# ping 172.17.0.3	#tomcat01 ping tomcat02<br>PING 172.17.0.3 (172.17.0.3) 56(84) bytes of data.<br>64 bytes from 172.17.0.3: icmp_seq=1 ttl=64 time=0.377 ms<br>64 bytes from 172.17.0.3: icmp_seq=2 ttl=64 time=0.188 ms<br>64 bytes from 172.17.0.3: icmp_seq=3 ttl=64 time=0.117 ms<br>64 bytes from 172.17.0.3: icmp_seq=4 ttl=64 time=0.125 ms<br>^C<br>--- 172.17.0.3 ping statistics ---<br>4 packets transmitted, 4 received, 0% packet loss, time 3004ms<br>rtt min/avg/max/mdev = 0.117/0.201/0.377/0.106 ms<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">结论</span><br><span class="hljs-meta">#</span><span class="bash">容器和容器之间能ping通</span><br><span class="hljs-meta">#</span><span class="bash">tomcat01和tomcat02是共用一个路由器 docker0</span><br><span class="hljs-meta">#</span><span class="bash">所有容器不指定网络的情况下，都是docker0路由的，运行容器的时候docker会给容器分配一个默认的可用ip</span><br><span class="hljs-meta">#</span><span class="bash">删除容器后对应的网桥就没了</span><br></code></pre></td></tr></table></figure>



<h2 id="–link"><a href="#–link" class="headerlink" title="–link"></a>–link</h2><p>容器每次启动，ip就会发生改变，能不能直接ping 容器名</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat:8.0<br>04924be2a65cc78078faab5135a7e5bc3dcca4d88381f747029201a25ddf2a7f<br>[root@localhost ~]# docker exec -it tomcat03 ping tomcat02<br>PING tomcat02 (172.17.0.3) 56(84) bytes of data.<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=1 ttl=64 time=0.381 ms<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=2 ttl=64 time=0.143 ms<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=3 ttl=64 time=0.117 ms<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=4 ttl=64 time=0.148 ms<br>64 bytes from tomcat02 (172.17.0.3): icmp_seq=5 ttl=64 time=0.147 ms<br>^C<br>--- tomcat02 ping statistics ---<br>5 packets transmitted, 5 received, 0% packet loss, time 4003ms<br>rtt min/avg/max/mdev = 0.117/0.187/0.381/0.097 ms<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">反向能ping通嘛？</span><br>[root@localhost ~]# docker exec -it tomcat02 ping tomcat03<br>ping: unknown host tomcat03		#不行<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">原因</span><br><span class="hljs-meta">#</span><span class="bash">查看tomcat03的hosts文件,发现多了‘172.17.0.3	tomcat02 e5b2577b0dda’，也就是说--link tomcat02其实就是在hosts文件当中添加了tomcat02的ip映射</span><br>[root@localhost ~]# docker exec -it tomcat03 cat /etc/hosts<br>127.0.0.1	localhost<br>::1	localhost ip6-localhost ip6-loopback<br>fe00::0	ip6-localnet<br>ff00::0	ip6-mcastprefix<br>ff02::1	ip6-allnodes<br>ff02::2	ip6-allrouters<br>172.17.0.3	tomcat02 e5b2577b0dda	<br>172.17.0.4	04924be2a65c<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">而tomcat02的host文件是没有tomcat03的ip地址的映射的，所以反过来ping不通</span><br>[root@localhost ~]# clear<br>[root@localhost ~]# docker exec -it tomcat02 cat /etc/hosts<br>127.0.0.1	localhost<br>::1	localhost ip6-localhost ip6-loopback<br>fe00::0	ip6-localnet<br>ff00::0	ip6-mcastprefix<br>ff02::1	ip6-allnodes<br>ff02::2	ip6-allrouters<br>172.17.0.3	e5b2577b0dda<br></code></pre></td></tr></table></figure>

<p>已经不建议–link</p>
<p><strong>docker0问题：docker0不支持容器名连接访问</strong></p>
<h2 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h2><p>容器互联</p>
<blockquote>
<p>查看所有的docker网络</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker network ls<br>NETWORK ID     NAME      DRIVER    SCOPE<br>d95b8735082b   bridge    bridge    local<br>455cd3558dd6   host      host      local<br>98e137b8cd9f   none      null      local<br></code></pre></td></tr></table></figure>

<p><strong>网络模式</strong></p>
<ul>
<li>​    bridge：桥接（默认，自己创建网络用的就是桥接）</li>
<li>​    none：不配置网络</li>
<li>​    host：和宿主机共享网络</li>
<li>​    container：容器网络联通（局限性大，用得少）</li>
</ul>
<p><strong>测试</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker run -d --name tomcat01 --net bridge tomcat<br><span class="hljs-meta">#</span><span class="bash">默认和</span><br>[root@localhost ~]# docker run -d --name tomcat01  tomcat<br><span class="hljs-meta">#</span><span class="bash">是一样的</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">创建网络</span><br>[root@localhost ~]# docker network create --driver bridge --subnet 192.168.0.0/16 --gateway 192.168.0.1 mynet<br>--drive birdge  # 网络模式设为bridge，桥接模式，默认也是桥接<br>--subnet		#设置子网ip<br>--gateway		#设置网关ip<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">在我们创建的网络上运行两个tomcat容器</span><br>[root@localhost ~]# docker run -d -P --network mynet --name tomcat01 tomcat:8.0<br>[root@localhost ~]# docker run -d -P --network mynet --name tomcat02 tomcat:8.0<br><span class="hljs-meta">#</span><span class="bash">进入tomcat01并且ping tomcat02，能ping通</span><br>[root@localhost ~]# docker exec -it tomcat01 ping tomcat02<br>PING tomcat02 (192.168.0.3) 56(84) bytes of data.<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.229 ms<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.114 ms<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.115 ms<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=4 ttl=64 time=0.153 ms<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=5 ttl=64 time=0.144 ms<br>^C<br>--- tomcat02 ping statistics ---<br><span class="hljs-meta">#</span><span class="bash">尝试进入tomcat02并且ping tomcat01，也能ping通</span><br>[root@localhost ~]# docker exec -it tomcat02 ping tomcat01<br>PING tomcat01 (192.168.0.2) 56(84) bytes of data.<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.173 ms<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.180 ms<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.144 ms<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=4 ttl=64 time=0.115 ms<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=5 ttl=64 time=0.150 ms<br>^C<br>--- tomcat01 ping statistics ---<br><br></code></pre></td></tr></table></figure>

<h2 id="网络联通"><a href="#网络联通" class="headerlink" title="网络联通"></a>网络联通</h2><p>创建两个新的tomcat容器tomcat03和tomcat04，使用默认网络docker0</p>
<p>尝试使用mynet网络中的docker01 去ping docker03</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker exec -it tomcat01 ping tomcat03<br>ping: unknown host tomcat03<br></code></pre></td></tr></table></figure>

<p>发现是ping不通的，这是因为两个容器分别处于不同的网段。</p>
<p>docker network connect可实现容器连接到一个网络</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">docker network connect [OPTIONS] NETWORK CONTAINER<br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220623122111164.png" alt="image-20220623122111164"></p>
<blockquote>
<p>测试打通mynet</p>
</blockquote>
<p>连通之后其本质就是将容器tomcat03放到了mynet网络下，且给其分配了一个可用ip，也就是说这个容器有了两个ip地址</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">[root@localhost ~]# docker network connect mynet tomcat03<br>[root@localhost ~]# docker network inspect mynet <br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220623123511033.png" alt="image-20220623123511033"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">查看容器tomcat03的元数据</span><br>[root@localhost ~]# docker network tomcat03 <br></code></pre></td></tr></table></figure>

<p><img src="/2022/06/06/docker%E5%AD%A6%E4%B9%A0/image-20220623123829613.png" alt="image-20220623123829613"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">尝试再次用tomcat03去ping tomcat01和tomcat02,能正常ping通</span><br>[root@localhost ~]# docker exec -it tomcat03 ping tomcat02<br>PING tomcat02 (192.168.0.3) 56(84) bytes of data.<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=1 ttl=64 time=0.353 ms<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=2 ttl=64 time=0.142 ms<br>64 bytes from tomcat02.mynet (192.168.0.3): icmp_seq=3 ttl=64 time=0.155 ms<br>^C<br>--- tomcat02 ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2004ms<br>rtt min/avg/max/mdev = 0.142/0.216/0.353/0.098 ms<br>[root@localhost ~]# docker exec -it tomcat03 ping tomcat01<br>PING tomcat01 (192.168.0.2) 56(84) bytes of data.<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=1 ttl=64 time=0.288 ms<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=2 ttl=64 time=0.142 ms<br>64 bytes from tomcat01.mynet (192.168.0.2): icmp_seq=3 ttl=64 time=0.144 ms<br>^C<br>--- tomcat01 ping statistics ---<br>3 packets transmitted, 3 received, 0% packet loss, time 2000ms<br>rtt min/avg/max/mdev = 0.142/0.191/0.288/0.069 ms<br>[root@localhost ~]# <br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
</search>
